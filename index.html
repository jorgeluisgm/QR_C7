<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control de Rondas Corporativo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 30px;
            margin-bottom: 20px;
            transition: transform 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .connection-status {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .status-active {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .role-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .role-button {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 40px 20px;
            font-size: 1.3rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .role-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }

        .role-button.supervisor {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .plant-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .plant-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 30px 20px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .plant-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .turn-info {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .turn-auto {
            background: #e8f5e8;
            border-color: #c8e6c9;
            color: #2e7d32;
        }

        .password-container {
            max-width: 400px;
            margin: 0 auto;
        }

        .password-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1.1rem;
            margin-bottom: 15px;
            text-align: center;
        }

        .password-input:focus {
            outline: none;
            border-color: #4facfe;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 15px 30px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ff8008 0%, #ffc837 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .progress-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #11998e 0%, #38ef7d 100%);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .locations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .location-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .location-card.completed {
            border-color: #28a745;
            background: #f8fff8;
        }

        .location-card.active {
            border-color: #007bff;
            background: #f8f9ff;
        }

        /* NUEVO: Estilos mejorados para QR Scanner */
        .qr-scanner {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            border: 3px dashed #2196f3;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.2);
            animation: pulse-border 2s infinite;
        }

        @keyframes pulse-border {
            0% { border-color: #2196f3; }
            50% { border-color: #ff9800; }
            100% { border-color: #2196f3; }
        }

        .qr-video-container {
            position: relative;
            display: inline-block;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin: 15px 0;
        }

        #qrVideo {
            width: 100%;
            max-width: 400px;
            height: auto;
            border-radius: 15px;
            background: #000;
        }

        .qr-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 3px solid #ff5722;
            border-radius: 15px;
            pointer-events: none;
        }

        .qr-overlay::before,
        .qr-overlay::after {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            border: 4px solid #ff5722;
        }

        .qr-overlay::before {
            top: -4px;
            left: -4px;
            border-right: transparent;
            border-bottom: transparent;
        }

        .qr-overlay::after {
            bottom: -4px;
            right: -4px;
            border-left: transparent;
            border-top: transparent;
        }

        .scan-status {
            font-size: 1.1rem;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .scan-status.scanning {
            background: #e3f2fd;
            color: #1976d2;
        }

        .scan-status.success {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .scan-status.error {
            background: #ffebee;
            color: #c62828;
        }

        .floating-button {
    position: fixed !important;
    bottom: 20px !important;
    right: 20px !important;
    width: 60px !important;
    height: 60px !important;
    background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%) !important;
    color: white !important;
    border: none !important;
    border-radius: 50% !important;
    font-size: 1.5rem !important;
    cursor: pointer !important;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3) !important;
    transition: all 0.3s ease !important;
    z-index: 99999 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    visibility: visible !important;
    opacity: 1 !important;
    transform: scale(1) !important;
}

.floating-button:hover {
    transform: scale(1.1) !important;
    box-shadow: 0 8px 20px rgba(255, 65, 108, 0.6) !important;
}

.floating-button.hidden {
    display: none !important;
}

        .floating-button:hover {
            transform: scale(1.1);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            overflow-y: auto;
        }

        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: #999;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        .form-group select, 
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .camera-container {
            text-align: center;
            margin: 20px 0;
        }

        .camera-preview {
            width: 100%;
            max-width: 400px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .dashboard {
            display: none;
        }

        .dashboard-tabs {
            display: flex;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .dashboard-tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s ease;
        }

        .dashboard-tab.active {
            background: #007bff;
            color: white;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border-left: 4px solid #007bff;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #007bff;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        .incidents-list {
            background: white;
            border-radius: 10px;
            padding: 20px;
        }

        .incident-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            margin-bottom: 10px;
        }

        .incident-item:last-child {
            border-bottom: none;
        }

        .incident-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .incident-type {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .type-personas { background: #ffe6e6; color: #d32f2f; }
        .type-seguridad { background: #fff3e0; color: #f57c00; }
        .type-mantenimiento { background: #e8f5e8; color: #388e3c; }
        .type-materiales { background: #e3f2fd; color: #1976d2; }

        .back-button {
            margin-bottom: 20px;
        }

        .hidden {
            display: none !important;
        }

        /* NUEVO: Botones de control QR mejorados */
        .qr-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .qr-controls .btn {
            width: auto;
            min-width: 150px;
            margin: 0;
        }

        /* NUEVO: Efecto de vibraciÃ³n visual cuando se detecta QR */
        .qr-success {
            animation: qr-detected 0.5s ease-in-out;
        }

        @keyframes qr-detected {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); background: #4caf50; }
            100% { transform: scale(1); }
        }

        /* NUEVO: Indicador de carga para cÃ¡mara */
        .camera-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #2196f3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .role-selector, .plant-selector {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .locations-grid {
                grid-template-columns: 1fr;
            }

            .qr-controls {
                flex-direction: column;
                align-items: center;
            }

            .qr-controls .btn {
                width: 100%;
                max-width: 300px;
            }
        }

        /* =============================================== */
/* ğŸ¨ ESTILOS PARA DASHBOARD AVANZADO */
/* =============================================== */

.filters-container {
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
}

.filters-container:hover {
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
}

.rounds-timeline {
    background: white;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.round-timeline-item {
    border-left: 4px solid #007bff;
    padding: 15px 20px;
    margin: 10px 0;
    background: #f8f9fa;
    border-radius: 0 8px 8px 0;
    transition: all 0.3s ease;
    cursor: pointer;
}

.round-timeline-item:hover {
    background: #e3f2fd;
    transform: translateX(5px);
    box-shadow: 0 3px 15px rgba(0,123,255,0.2);
}

.round-timeline-item.urgent {
    border-left-color: #dc3545;
    background: #fff5f5;
}

.round-timeline-item.complete {
    border-left-color: #28a745;
}

.round-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.round-title {
    font-weight: bold;
    font-size: 1.1rem;
    color: #333;
}

.round-time {
    color: #666;
    font-size: 0.9rem;
}

.round-summary {
    color: #555;
    margin-bottom: 10px;
    line-height: 1.4;
}

.round-actions {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
}

.heat-map-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-top: 20px;
}

.heat-location {
    padding: 15px;
    border-radius: 8px;
    text-align: center;
    font-weight: bold;
    color: white;
    transition: all 0.3s ease;
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.heat-location:hover {
    transform: scale(1.05);
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
}

.heat-location::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left 0.5s;
}

.heat-location:hover::before {
    left: 100%;
}

.heat-level-0 { background: linear-gradient(135deg, #4CAF50, #45a049); }
.heat-level-1 { background: linear-gradient(135deg, #FFC107, #ffb300); }
.heat-level-2 { background: linear-gradient(135deg, #FF9800, #f57c00); }
.heat-level-3 { background: linear-gradient(135deg, #F44336, #d32f2f); }

.urgent-incident {
    background: linear-gradient(135deg, #ffebee 0%, #fff5f5 100%);
    border: 2px solid #f44336;
    border-radius: 10px;
    padding: 20px;
    margin: 15px 0;
    box-shadow: 0 3px 15px rgba(244, 67, 54, 0.2);
    transition: all 0.3s ease;
}

.urgent-incident:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 25px rgba(244, 67, 54, 0.3);
}

.urgent-incident.resolved {
    background: linear-gradient(135deg, #e8f5e8 0%, #f1f8e9 100%);
    border-color: #4caf50;
    opacity: 0.7;
}

.incident-priority {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: bold;
    text-transform: uppercase;
}

.priority-urgent {
    background: #f44336;
    color: white;
    animation: pulse 2s infinite;
}

.priority-high {
    background: #ff9800;
    color: white;
}

.priority-normal {
    background: #2196f3;
    color: white;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(244, 67, 54, 0); }
    100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); }
}

.recommendation-item {
    background: white;
    border-left: 4px solid #4CAF50;
    padding: 15px;
    margin: 10px 0;
    border-radius: 0 8px 8px 0;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.recommendation-item.high-priority {
    border-left-color: #FF9800;
}

.recommendation-item.critical {
    border-left-color: #F44336;
}

@media (max-width: 768px) {
    .filters-container > div {
        grid-template-columns: 1fr !important;
    }
    
    .round-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
    }
    
    .round-actions {
        justify-content: flex-start;
        width: 100%;
    }
    
    .heat-map-grid {
        grid-template-columns: 1fr;
    }
}

        /* =============================================== */
        /* ğŸ”§ ESTILOS PARA PANEL DE DEBUG VISUAL */
        /* =============================================== */
        
        .debug-panel {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 350px;
            max-height: 70vh;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 9999;
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .debug-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .debug-header h4 {
            margin: 0;
            font-size: 1rem;
            color: white;
        }
        
        .debug-controls {
            display: flex;
            gap: 5px;
        }
        
        .debug-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 5px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.3s ease;
        }
        
        .debug-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .debug-section {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .debug-section:last-child {
            border-bottom: none;
        }
        
        .debug-section h5 {
            margin: 0 0 10px 0;
            font-size: 0.9rem;
            color: #4facfe;
        }
        
        .debug-status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 0.8rem;
        }
        
        .status-label {
            color: #ccc;
        }
        
        .status-value {
            font-weight: bold;
        }
        
        .debug-stats {
            font-size: 0.8rem;
            line-height: 1.4;
        }
        
        .debug-stats div {
            padding: 2px 0;
            color: #e0e0e0;
        }
        
        .debug-log {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 8px;
        }
        
        .log-entry {
            font-size: 0.7rem;
            margin: 2px 0;
            padding: 3px 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        
        .log-entry.info {
            background: rgba(52, 152, 219, 0.2);
            color: #74b9ff;
        }
        
        .log-entry.success {
            background: rgba(46, 204, 113, 0.2);
            color: #00b894;
        }
        
        .log-entry.warning {
            background: rgba(241, 196, 15, 0.2);
            color: #fdcb6e;
        }
        
        .log-entry.error {
            background: rgba(231, 76, 60, 0.2);
            color: #e17055;
        }
        
        .debug-test-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .debug-test-btn {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            border: none;
            padding: 8px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
            transition: transform 0.2s ease;
        }
        
        .debug-test-btn:hover {
            transform: translateY(-1px);
        }
        
        .debug-toggle-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
            z-index: 9998;
            transition: all 0.3s ease;
        }
        
        .debug-toggle-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.6);
        }
        
        /* Responsive para mÃ³viles */
        @media (max-width: 768px) {
            .debug-panel {
                width: calc(100vw - 40px);
                right: 20px;
                left: 20px;
                bottom: 80px;
                max-height: 60vh;
            }
            
            .debug-status-grid {
                grid-template-columns: 1fr;
            }
            
            .debug-test-buttons {
                grid-template-columns: 1fr;
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ­ Control de Rondas Corporativo</h1>
            <p>Sistema Inteligente Multi-Planta</p>
        </div>

        <!-- Estado de ConexiÃ³n Mejorado -->
<div id="connectionStatus" class="connection-status status-active">
    ğŸ”„ Inicializando sistema...
</div>

<!-- NUEVO: Panel de estadÃ­sticas GitHub -->
<div id="githubStats" class="card hidden" style="margin-bottom: 20px;">
    <h3>â˜ï¸ Estado del Backup en la Nube</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center;">
            <div style="font-size: 1.5rem; font-weight: bold; color: #007bff;" id="uploadedCount">0</div>
            <small>Fotos Respaldadas</small>
        </div>
        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center;">
            <div style="font-size: 1.5rem; font-weight: bold; color: #28a745;" id="storageUsed">0 MB</div>
            <small>Almacenamiento Usado</small>
        </div>
    </div>
    <div style="margin-top: 10px; font-size: 0.9rem; color: #666;">
        ğŸ“… Ãšltima sincronizaciÃ³n: <span id="lastSyncTime">Nunca</span>
    </div>
</div>

        <!-- Pantalla Principal: Selector de Rol -->
        <div id="roleScreen" class="card">
            <h2 style="text-align: center; margin-bottom: 30px;">Selecciona tu Rol</h2>
            <div class="role-selector">
                <button class="role-button" onclick="selectRole('guard')">
                    ğŸ‘·â€â™‚ï¸<br><strong>GUARDIA</strong><br>
                    <small>Realizar recorridos</small>
                </button>
                <button class="role-button supervisor" onclick="selectRole('supervisor')">
                    ğŸ‘”<br><strong>SUPERVISIÃ“N</strong><br>
                    <small>Dashboard y reportes</small>
                </button>
            </div>
        </div>

        <!-- Pantalla: ContraseÃ±a SupervisiÃ³n -->
        <div id="passwordScreen" class="card hidden">
            <button class="btn btn-secondary back-button" onclick="goBack()">â† Regresar</button>
            <h2 style="text-align: center; margin-bottom: 30px;">ğŸ”’ Acceso de SupervisiÃ³n</h2>
            <div class="password-container">
                <input type="password" id="passwordInput" class="password-input" 
                       placeholder="Ingresa la contraseÃ±a" onkeypress="checkPassword(event)">
                <button class="btn" onclick="verifyPassword()">ğŸ”‘ Ingresar</button>
                <div id="passwordError" style="color: red; text-align: center; margin-top: 10px; display: none;">
                    âŒ ContraseÃ±a incorrecta
                </div>
            </div>
        </div>

        <!-- Pantalla: Selector de Planta (Guardias) -->
        <div id="plantScreen" class="card hidden">
            <button class="btn btn-secondary back-button" onclick="goBack()">â† Regresar</button>
            <h2 style="text-align: center; margin-bottom: 20px;">ğŸ­ Selecciona la Planta</h2>
            
            <!-- InformaciÃ³n de Turno AutomÃ¡tico -->
            <div id="turnInfo" class="turn-info turn-auto">
                <strong>ğŸ¤– DetecciÃ³n AutomÃ¡tica de Turno</strong><br>
                <span id="currentTurn">ğŸŒ… Turno Diurno (07:30 - 19:30)</span><br>
                <small>Hora actual: <span id="currentTime"></span></small>
            </div>

            <div class="plant-selector">
                <button class="plant-button" onclick="selectPlant('matriz')">
                    ğŸ¢<br><strong>MATRIZ</strong><br>
                    <small>Planta Principal</small>
                </button>
                <button class="plant-button" onclick="selectPlant('ekzotikart')">
                    ğŸ­<br><strong>EKZOTIKART</strong><br>
                    <small>Planta Secundaria</small>
                </button>
            </div>
        </div>

        <!-- Pantalla: Sistema de Recorridos -->
        <div id="roundsScreen" class="card hidden">
            <button class="btn btn-secondary back-button" onclick="goBackToPlant()">â† Cambiar Planta</button>
            
            <div style="text-align: center; margin-bottom: 20px;">
                <h2 id="plantTitle">ğŸ¢ MATRIZ</h2>
                <p id="turnDisplay">ğŸŒ… Turno Diurno</p>
            </div>

            <!-- Progreso del Recorrido -->
            <div id="progressContainer" class="progress-container hidden">
                <h3>ğŸ“Š Progreso del Recorrido</h3>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                </div>
                <p><span id="completedLocations">0</span> de <span id="totalLocations">10</span> ubicaciones completadas</p>
                <p>â±ï¸ Tiempo transcurrido: <span id="elapsedTime">00:00</span></p>
            </div>

            <!-- Botones de AcciÃ³n Principal -->
            <div style="text-align: center; margin-bottom: 20px;">
                <button id="startRoundBtn" class="btn btn-success" onclick="startRound()">
                    ğŸš€ Iniciar Recorrido
                </button>
            </div>

            <!-- CORREGIDO: Scanner QR con validaciÃ³n de jsQR -->
            <div id="qrScannerSection" class="qr-scanner hidden">
                <div class="camera-loading" id="cameraLoading">
                    <div class="loading-spinner"></div>
                    <p>ğŸ“¡ Verificando compatibilidad...</p>
                </div>
                
                <div id="qrScannerContent" class="hidden">
                    <h3>ğŸ“± Scanner de CÃ³digos QR</h3>
                    <p><strong>ğŸ¯ Apunta la cÃ¡mara al cÃ³digo QR de la ubicaciÃ³n</strong></p>
                    
                    <div class="qr-video-container" id="qrVideoContainer">
                        <video id="qrVideo" autoplay playsinline muted></video>
                        <div class="qr-overlay"></div>
                    </div>
                    
                    <div id="scanStatus" class="scan-status scanning">
                        ğŸ” Iniciando scanner...
                    </div>
                    
                    <!-- NUEVO: Debug info -->
                    <div id="debugInfo" style="font-size: 0.8rem; color: #666; margin-top: 10px; display: none;">
                        Video: <span id="videoStatus">-</span> | 
                        jsQR: <span id="jsqrStatus">-</span> | 
                        Frames: <span id="frameCount">0</span>
                    </div>
                </div>
                
                <div class="qr-controls">
                    <button class="btn btn-danger" onclick="cancelQRScan()">âŒ Cancelar Scanner</button>
                    <button class="btn btn-secondary" onclick="toggleDebugInfo()">ğŸ”§ Debug</button>
                </div>
            </div>

            <!-- Botones de Control del Recorrido -->
            <div style="text-align: center; margin-bottom: 20px;">
                <button id="scanQRBtn" class="btn hidden" onclick="showQRScanner()">
                    ğŸ“± Escanear QR
                </button>
                <button id="finishRoundBtn" class="btn btn-warning hidden" onclick="finishRound()">
                    âœ… Finalizar Recorrido
                </button>
            </div>

            <!-- Ubicaciones (SIN cÃ³digos QR visibles) -->
            <div id="locationsGrid" class="locations-grid"></div>

            <!-- Historial de Recorridos -->
            <div style="margin-top: 30px;">
                <h3>ğŸ“‹ Historial de Recorridos</h3>
                <div id="roundsHistory"></div>
            </div>
        </div>

        <!-- Dashboard de SupervisiÃ³n -->
<div id="supervisorDashboard" class="card hidden">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 10px;">
        <h2>ğŸ“Š Dashboard de SupervisiÃ³n</h2>
        <div style="display: flex; gap: 10px; align-items: center;">
            <button onclick="syncAllDataForSupervisor()" class="btn" style="background: linear-gradient(135deg, #00b894 0%, #00cec9 100%); padding: 8px 12px; font-size: 0.9rem;">
                ğŸ”„ Actualizar Todo
            </button>
            <button class="btn btn-secondary" onclick="logout()">ğŸšª Salir</button>
        </div>
    </div>

    <!-- InformaciÃ³n de SincronizaciÃ³n -->
    <div id="syncInfoPanel" style="background: #e3f2fd; border: 1px solid #bbdefb; border-radius: 10px; padding: 15px; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
        <div>
            <strong>ğŸ“Š Datos Globales</strong><br>
            <small>Ãšltima actualizaciÃ³n: <span id="lastSyncDisplay">Cargando...</span></small>
        </div>
        <div style="display: flex; gap: 8px;">
            <span id="dataSourceIndicator" style="padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold;">
                ğŸ”„ Sincronizando...
            </span>
            <span id="connectionIndicator" style="padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold;">
                ğŸ“¡ Verificando...
            </span>
        </div>
    </div>

    <!-- Estado de Notificaciones -->
    <div id="notificationStatus" class="connection-status" style="margin-bottom: 20px;">
        <button class="btn" onclick="enableNotifications()" id="enableNotifBtn">ğŸ”” Activar Notificaciones</button>
        <button class="btn" onclick="configureReminders()" id="configRemindersBtn" style="margin-left: 10px;">â° Configurar Recordatorios</button>
    </div>

    <!-- PestaÃ±as del Dashboard Mejorado -->
    <div class="dashboard-tabs">
        <button class="dashboard-tab active" onclick="showDashboardTab('resumen', event)">ğŸ“… Resumen</button>
        <button class="dashboard-tab" onclick="showDashboardTab('mapaCalor', event)">ğŸ”¥ Mapa de Calor</button>
        <button class="dashboard-tab" onclick="showDashboardTab('incidenciasUrgentes', event)">ğŸš¨ Incidencias Urgentes</button>
        <button class="dashboard-tab" onclick="showDashboardTab('analytics', event)">ğŸ“Š Analytics Avanzado</button>
    </div>

    <!-- PESTAÃ‘A 1: RESUMEN CON CALENDARIO -->
    <div id="resumenTab" class="dashboard-content">
        <!-- Controles de Filtrado -->
        <div class="filters-container" style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 15px; align-items: end;">
                <div>
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ğŸ“… Fecha:</label>
                    <input type="date" id="dateFilter" style="padding: 10px; border: 2px solid #ddd; border-radius: 8px; width: 100%;">
                </div>
                <div>
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">â° Turno:</label>
                    <select id="turnFilter" style="padding: 10px; border: 2px solid #ddd; border-radius: 8px; width: 100%;">
                        <option value="todos">Todos los turnos</option>
                        <option value="diurno">ğŸŒ… Diurno (07:30-19:30)</option>
                        <option value="nocturno">ğŸŒ™ Nocturno (19:30-07:30)</option>
                    </select>
                </div>
                <div>
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ğŸ­ Planta:</label>
                    <select id="plantFilter" style="padding: 10px; border: 2px solid #ddd; border-radius: 8px; width: 100%;">
                        <option value="todas">Todas las plantas</option>
                        <option value="matriz">ğŸ¢ MATRIZ</option>
                        <option value="ekzotikart">ğŸ­ EKZOTIKART</option>
                    </select>
                </div>
                <div>
                    <button onclick="applyFilters()" class="btn btn-success" style="padding: 10px 20px;">ğŸ” Filtrar</button>
                </div>
            </div>
        </div>

        <!-- Resumen de EstadÃ­sticas del DÃ­a -->
        <div id="dayStats" class="stats-grid" style="margin-bottom: 20px;">
            <div class="stat-card">
                <div class="stat-value" id="dayRounds">0</div>
                <div class="stat-label">Recorridos del DÃ­a</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="dayIncidents">0</div>
                <div class="stat-label">Incidencias Reportadas</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="dayPhotos">0</div>
                <div class="stat-label">Fotos Capturadas</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="coveragePercent">0%</div>
                <div class="stat-label">Cobertura Promedio</div>
            </div>
        </div>

        <!-- Lista de Recorridos Filtrados -->
        <div id="filteredRounds" class="rounds-timeline">
            <div style="text-align: center; padding: 40px; color: #666;">
                ğŸ“… Selecciona una fecha para ver los recorridos
            </div>
        </div>
    </div>

    <!-- PESTAÃ‘A 2: MAPA DE CALOR -->
    <div id="mapaCalorTab" class="dashboard-content hidden">
        <!-- Selector de Planta para Mapa -->
        <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
            <div style="display: flex; gap: 15px; align-items: center; justify-content: center;">
                <button onclick="loadHeatMap('matriz')" class="btn" style="background: #667eea;">
                    ğŸ¢ Ver Mapa MATRIZ
                </button>
                <button onclick="loadHeatMap('ekzotikart')" class="btn" style="background: #764ba2;">
                    ğŸ­ Ver Mapa EKZOTIKART
                </button>
                <div style="margin-left: 20px;">
                    <label>ğŸ“… PerÃ­odo:</label>
                    <select id="heatMapPeriod" style="margin-left: 10px; padding: 5px;">
                        <option value="7">Ãšltimos 7 dÃ­as</option>
                        <option value="30">Ãšltimos 30 dÃ­as</option>
                        <option value="90">Ãšltimos 90 dÃ­as</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- VisualizaciÃ³n del Mapa de Calor -->
        <div id="heatMapContainer" style="background: white; border-radius: 10px; padding: 20px; min-height: 400px;">
            <div style="text-align: center; padding: 50px; color: #666;">
                ğŸ”¥ Selecciona una planta para generar el mapa de calor
            </div>
        </div>

        <!-- Leyenda del Mapa -->
        <div id="heatMapLegend" class="hidden" style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin-top: 20px;">
            <h4>ğŸ“‹ Leyenda del Mapa de Calor:</h4>
            <div style="display: flex; gap: 20px; margin-top: 10px;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #4CAF50; border-radius: 3px;"></div>
                    <span>Sin incidencias (0)</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #FFC107; border-radius: 3px;"></div>
                    <span>Pocas incidencias (1-2)</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #FF9800; border-radius: 3px;"></div>
                    <span>Incidencias moderadas (3-5)</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #F44336; border-radius: 3px;"></div>
                    <span>Muchas incidencias (6+)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- PESTAÃ‘A 3: INCIDENCIAS URGENTES -->
    <div id="incidenciasUrgentesTab" class="dashboard-content hidden">
        <!-- Contador de Urgentes -->
        <div style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%); color: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
            <h3 style="margin: 0;">ğŸš¨ INCIDENCIAS URGENTES ACTIVAS</h3>
            <div style="font-size: 2rem; font-weight: bold; margin: 10px 0;" id="urgentCount">0</div>
            <div>Requieren atenciÃ³n inmediata</div>
        </div>

        <!-- Filtros para Urgentes -->
        <div style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin-bottom: 20px;">
            <div style="display: flex; gap: 15px; align-items: center;">
                <div>
                    <label>ğŸ­ Planta:</label>
                    <select id="urgentPlantFilter" style="margin-left: 10px; padding: 5px;">
                        <option value="todas">Todas</option>
                        <option value="matriz">MATRIZ</option>
                        <option value="ekzotikart">EKZOTIKART</option>
                    </select>
                </div>
                <div>
                    <label>ğŸ·ï¸ Tipo:</label>
                    <select id="urgentTypeFilter" style="margin-left: 10px; padding: 5px;">
                        <option value="todos">Todos</option>
                        <option value="seguridad">ğŸ”’ Seguridad</option>
                        <option value="mantenimiento">ğŸ”§ Mantenimiento</option>
                        <option value="personas">ğŸ‘¥ Personas</option>
                        <option value="materiales">ğŸ“¦ Materiales</option>
                    </select>
                </div>
                <button onclick="filterUrgentIncidents()" class="btn btn-warning">ğŸ” Filtrar</button>
                <button onclick="markAllAsResolved()" class="btn btn-success">âœ… Marcar Todas como Resueltas</button>
            </div>
        </div>

        <!-- Lista de Incidencias Urgentes -->
        <div id="urgentIncidentsList" style="max-height: 600px; overflow-y: auto;">
            <div style="text-align: center; padding: 40px; color: #666;">
                âœ… No hay incidencias urgentes en este momento
            </div>
        </div>
    </div>

    <!-- PESTAÃ‘A 4: ANALYTICS AVANZADO -->
    <div id="analyticsTab" class="dashboard-content hidden">
        <!-- Lista de Incidencias para Analytics -->
<div style="background: white; padding: 20px; border-radius: 10px; margin-top: 20px;">
    <h4>ğŸš¨ Ãšltimas Incidencias</h4>
    <div id="incidentsList" style="max-height: 300px; overflow-y: auto;">
        <div style="text-align: center; padding: 20px; color: #666;">
            ğŸ“‹ Cargando incidencias...
        </div>
    </div>
</div>
        <!-- AnÃ¡lisis Predictivo -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
            <h3 style="margin: 0;">ğŸ”® AnÃ¡lisis Predictivo e Inteligencia</h3>
            <p style="margin: 5px 0 0 0;">Insights automÃ¡ticos basados en patrones de datos</p>
        </div>

        <!-- MÃ©tricas Avanzadas -->
        <div class="stats-grid" style="margin-bottom: 20px;">
            <div class="stat-card" style="border-left-color: #3498db;">
                <div class="stat-value" id="avgResponseTime">0h</div>
                <div class="stat-label">Tiempo Promedio de Respuesta</div>
            </div>
            <div class="stat-card" style="border-left-color: #e74c3c;">
                <div class="stat-value" id="riskScore">0%</div>
                <div class="stat-label">Ãndice de Riesgo General</div>
            </div>
            <div class="stat-card" style="border-left-color: #2ecc71;">
                <div class="stat-value" id="efficiencyScore">0%</div>
                <div class="stat-label">Eficiencia de Recorridos</div>
            </div>
            <div class="stat-card" style="border-left-color: #f39c12;">
                <div class="stat-value" id="trendDirection">â†—ï¸</div>
                <div class="stat-label">Tendencia Mensual</div>
            </div>
        </div>

        <!-- AnÃ¡lisis de Patrones -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
            <div style="background: white; padding: 20px; border-radius: 10px;">
                <h4>ğŸ• AnÃ¡lisis Temporal</h4>
                <div id="timePatterns">Cargando patrones...</div>
            </div>
            <div style="background: white; padding: 20px; border-radius: 10px;">
                <h4>ğŸ“ Ubicaciones CrÃ­ticas</h4>
                <div id="criticalLocations">Cargando anÃ¡lisis...</div>
            </div>
        </div>

        <!-- Recomendaciones AutomÃ¡ticas -->
        <div style="background: #e8f5e8; border: 2px solid #4CAF50; border-radius: 10px; padding: 20px;">
            <h4 style="color: #2e7d32;">ğŸ’¡ Recomendaciones AutomÃ¡ticas</h4>
            <div id="autoRecommendations">
                <div>ğŸ”„ Analizando patrones para generar recomendaciones...</div>
            </div>
        </div>
    </div>

    <!-- Recordatorios Activos -->
    <div id="remindersSection" class="card" style="margin-top: 20px; display: none;">
        <h3>â° Recordatorios Aleatorios</h3>
        <div id="remindersInfo"></div>
        <button class="btn btn-danger" onclick="stopReminders()">ğŸ›‘ Detener Recordatorios</button>
    </div>
</div>

        <!-- Modal de ConfiguraciÃ³n de Recordatorios -->
        <div id="remindersModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>â° Configurar Recordatorios Aleatorios</h3>
                    <button class="close-modal" onclick="closeRemindersModal()">&times;</button>
                </div>

                <div class="form-group">
                    <label for="reminderFrequency">ğŸ• Frecuencia Base (horas):</label>
                    <select id="reminderFrequency">
                        <option value="1">Cada ~1 hora (Â±15 min)</option>
                        <option value="2" selected>Cada ~2 horas (Â±30 min)</option>
                        <option value="3">Cada ~3 horas (Â±45 min)</option>
                        <option value="4">Cada ~4 horas (Â±60 min)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="reminderPlant">ğŸ­ Planta Objetivo:</label>
                    <select id="reminderPlant">
                        <option value="both">Ambas Plantas (Aleatorio)</option>
                        <option value="matriz">Solo MATRIZ</option>
                        <option value="ekzotikart">Solo EKZOTIKART</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>
                        <input type="checkbox" id="soundAlerts" checked> ğŸ”Š Sonido en Alertas
                    </label>
                </div>

                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="closeRemindersModal()">âŒ Cancelar</button>
                    <button class="btn btn-success" onclick="startReminders()">âœ… Activar Recordatorios</button>
                </div>
            </div>
        </div>

        

        <!-- Modal de Observaciones/Incidencias -->
        <div id="observationModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="modalTitle">ğŸ“ Observaciones</h3>
                    <button class="close-modal" onclick="closeModal()">&times;</button>
                </div>

                <div class="form-group">
                    <label for="observationLocation">ğŸ“ UbicaciÃ³n:</label>
                    <select id="observationLocation">
                        <option value="">Seleccionar ubicaciÃ³n...</option>
                    </select>
                </div>

                <div id="incidentTypeGroup" class="form-group hidden">
                    <label for="incidentType">ğŸ·ï¸ Tipo de Incidencia:</label>
                    <select id="incidentType">
                        <option value="">Seleccionar tipo...</option>
                        <option value="personas">ğŸ‘¥ Personas</option>
                        <option value="seguridad">ğŸ”’ Seguridad</option>
                        <option value="mantenimiento">ğŸ”§ Mantenimiento</option>
                        <option value="materiales">ğŸ“¦ Materiales</option>
                    </select>
                </div>

                <div id="priorityGroup" class="form-group hidden">
    <label for="incidentPriority">âš¡ Nivel de Urgencia:</label>
    <select id="incidentPriority" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem;">
        <option value="normal">ğŸ”µ Normal</option>
        <option value="high">ğŸŸ¡ Alta</option>
        <option value="urgent">ğŸ”´ URGENTE - Requiere atenciÃ³n inmediata</option>
    </select>
    <small style="color: #666; margin-top: 5px; display: block;">
        âš ï¸ Las incidencias URGENTES envÃ­an notificaciones inmediatas al equipo de supervisiÃ³n
    </small>
</div>

                <div class="form-group">
                    <label for="observationText">ğŸ“ DescripciÃ³n (Opcional):</label>
                    <textarea id="observationText" placeholder="Describe la observaciÃ³n o incidencia (opcional)..."></textarea>
                </div>

                <div class="camera-container">
                    <h4>ğŸ“¸ Evidencia FotogrÃ¡fica (Opcional)</h4>
                    <p><small>ğŸ’¡ Solo toma foto si es necesaria para documentar</small></p>
                    <video id="cameraPreview" class="camera-preview" style="display: none;" autoplay></video>
                    <canvas id="photoCanvas" style="display: none;"></canvas>
                    <img id="capturedPhoto" class="camera-preview" style="display: none;">
                    
                    <div id="cameraButtons">
                        <button class="btn" onclick="startCamera()">ğŸ“· Activar CÃ¡mara</button>
                        <button id="captureBtn" class="btn btn-success hidden" onclick="capturePhotoImproved()">ğŸ“¸ Tomar Foto</button>
                        <button id="retakeBtn" class="btn btn-warning hidden" onclick="retakePhotoImproved()">ğŸ”„ Tomar de Nuevo</button>
                    </div>
                </div>

                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="closeModal()">âŒ Cancelar</button>
                    <button class="btn btn-success" onclick="saveObservationImproved()">âœ… Guardar</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Modal Visor de Fotos -->
        <div id="photoViewerModal" class="modal">
            <div class="modal-content" style="max-width: 90vw; max-height: 90vh; padding: 20px;">
                <div class="modal-header">
                    <h3 id="photoViewerTitle">ğŸ“¸ Visor de Fotos</h3>
                    <button class="close-modal" onclick="closePhotoViewer()">&times;</button>
                </div>
                
                <div id="photoViewerContent" style="text-align: center;">
                    <!-- InformaciÃ³n de la foto -->
                    <div id="photoInfo" style="background: #f8f9fa; padding: 10px; border-radius: 8px; margin-bottom: 15px; display: none;">
                        <small>
                            ğŸ“… <span id="photoDate">-</span> | 
                            ğŸ“ <span id="photoSize">-</span> | 
                            ğŸ­ <span id="photoPlant">-</span> | 
                            ğŸ“ <span id="photoLocation">-</span>
                        </small>
                    </div>
                    
                    <!-- Imagen principal -->
                    <div id="photoContainer" style="position: relative; display: inline-block; max-width: 100%; max-height: 70vh; overflow: hidden; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.3);">
                        <img id="photoViewerImage" style="max-width: 100%; max-height: 70vh; object-fit: contain; cursor: zoom-in;" onclick="togglePhotoZoom()">
                        
                        <!-- Indicador de carga -->
                        <div id="photoLoader" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none;">
                            <div class="loading-spinner"></div>
                            <p>ğŸ“¸ Cargando foto...</p>
                        </div>
                        
                        <!-- Controles de zoom -->
                        <div id="zoomControls" style="position: absolute; bottom: 10px; right: 10px; display: none;">
                            <button onclick="zoomPhoto(0.8)" style="background: rgba(0,0,0,0.7); color: white; border: none; padding: 5px 8px; margin: 2px; border-radius: 3px; cursor: pointer;">ğŸ”-</button>
                            <button onclick="zoomPhoto(1.25)" style="background: rgba(0,0,0,0.7); color: white; border: none; padding: 5px 8px; margin: 2px; border-radius: 3px; cursor: pointer;">ğŸ”+</button>
                            <button onclick="resetPhotoZoom()" style="background: rgba(0,0,0,0.7); color: white; border: none; padding: 5px 8px; margin: 2px; border-radius: 3px; cursor: pointer;">â†»</button>
                        </div>
                    </div>
                    
                    <!-- NavegaciÃ³n de galerÃ­a -->
                    <div id="galleryNavigation" style="margin-top: 15px; display: none;">
                        <button id="prevPhotoBtn" onclick="navigateGallery(-1)" class="btn btn-secondary" style="margin: 0 5px;">â† Anterior</button>
                        <span id="photoCounter" style="margin: 0 15px; font-weight: bold;">1 / 1</span>
                        <button id="nextPhotoBtn" onclick="navigateGallery(1)" class="btn btn-secondary" style="margin: 0 5px;">Siguiente â†’</button>
                    </div>
                    
                    <!-- Acciones -->
                    <div style="margin-top: 20px;">
                        <button onclick="downloadCurrentPhoto()" class="btn btn-success" style="margin: 5px;">ğŸ’¾ Descargar</button>
                        <button onclick="closePhotoViewer()" class="btn btn-secondary" style="margin: 5px;">âŒ Cerrar</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- GalerÃ­a de Fotos en Observaciones -->
        <div id="observationGallery" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4>ğŸ“¸ Fotos de esta ObservaciÃ³n</h4>
            <div id="galleryThumbnails" style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px;">
                <!-- Miniaturas se generan dinÃ¡micamente -->
            </div>
        </div>  

    <script>
        // ===============================================
        // ğŸ“ VARIABLES GLOBALES
        // ===============================================
        let currentRound = null;
        let currentPlant = '';
        let currentTurn = '';
        let isIncidentMode = false;
        let cameraStream = null;
        let roundStartTime = null;
        let roundTimer = null;
        let capturedPhotoUrl = null;
        
        // NUEVO: Variables para QR Scanner mejorado
        let qrVideo = null;
        let qrStream = null;
        let scanningActive = false;
        let qrDetectionLoop = null;
        
        // Variables para funcionalidades avanzadas
        let notificationsEnabled = false;
        let reminderInterval = null;
        let reminderConfig = {
            frequency: 2,
            plant: 'both',
            soundEnabled: true
        };

        // ===============================================
// ğŸ§  GESTOR DE MEMORIA AUTOMÃTICO
// ===============================================

class MemoryManager {
    constructor() {
        this.objectUrls = new Set();
        this.cleanupInterval = null;
        this.init();
    }
    
    init() {
        // Limpiar cada 5 minutos
        this.cleanupInterval = setInterval(() => {
            this.cleanup();
        }, 300000);
        
        // Limpiar al cerrar la pÃ¡gina
        window.addEventListener('beforeunload', () => {
            this.cleanup();
        });
    }
    
    createObjectURL(blob) {
    try {
        const url = URL.createObjectURL(blob);
        this.objectUrls.add(url);
        console.log(`ğŸ”— URL creada: ${this.objectUrls.size} URLs activas`);
        return url;
    } catch (error) {
        console.error('âŒ Error creando URL:', error);
        return null;
    }
}
    
    revokeObjectURL(url) {
    if (!url || typeof url !== 'string') {
        return;
    }
    
    try {
        if (this.objectUrls.has(url)) {
            URL.revokeObjectURL(url);
            this.objectUrls.delete(url);
            console.log(`ğŸ—‘ï¸ URL liberada: ${this.objectUrls.size} URLs restantes`);
        }
    } catch (error) {
        console.warn('âš ï¸ Error liberando URL (puede estar corrupta):', error.message);
        // Forzar eliminaciÃ³n del set aunque haya error
        this.objectUrls.delete(url);
    }
}
    
    cleanup() {
    console.log(`ğŸ§¹ Limpiando ${this.objectUrls.size} URLs...`);
    
    // Crear array para evitar modificar Set durante iteraciÃ³n
    const urlsToClean = Array.from(this.objectUrls);
    let cleanedCount = 0;
    let errorCount = 0;
    
    urlsToClean.forEach(url => {
        try {
            URL.revokeObjectURL(url);
            this.objectUrls.delete(url);
            cleanedCount++;
        } catch (error) {
            // Silenciar errores de URLs ya liberadas
            this.objectUrls.delete(url);
            errorCount++;
        }
    });
    
    console.log(`âœ… Limpieza completada: ${cleanedCount} URLs liberadas, ${errorCount} errores silenciados`);
    
    // Forzar garbage collection si estÃ¡ disponible
    if (window.gc) {
        try {
            window.gc();
            console.log('ğŸ—‘ï¸ Garbage collection ejecutado');
        } catch (gcError) {
            // Silenciar errores de GC
        }
    }
}
    
    getStats() {
        return {
            activeUrls: this.objectUrls.size,
            memoryUsage: performance.memory ? {
                used: Math.round(performance.memory.usedJSHeapSize / 1048576),
                total: Math.round(performance.memory.totalJSHeapSize / 1048576),
                limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576)
            } : null
        };
    }
}

// Instancia global del gestor de memoria
const memoryManager = new MemoryManager();

        // ===============================================
// ğŸ” CONFIGURACIÃ“N GITHUB STORAGE (SEGURA)
// ===============================================

// ConfiguraciÃ³n del repositorio GitHub (SIN TOKEN HARDCODEADO)
const GITHUB_CONFIG = {
    username: 'jorgeluisgm',
    repository: 'industrial-data-storage',
    token: '', // ğŸ” Se configurarÃ¡ dinÃ¡micamente de forma segura
    baseUrl: 'https://api.github.com/repos/jorgeluisgm/industrial-data-storage',
    rawUrl: 'https://raw.githubusercontent.com/jorgeluisgm/industrial-data-storage/main',
    branch: 'main'
};

// Estado de configuraciÃ³n del token
let tokenConfigured = false;
let tokenPromptShown = false;

/**
 * Inicializar token de GitHub de forma segura
 */
function initializeGitHubToken() {
    try {
        console.log('ğŸ” Inicializando configuraciÃ³n segura de GitHub token...');
        
        // Intentar cargar token desde localStorage
        const savedToken = localStorage.getItem('github_token_secure');
        
        if (savedToken && savedToken.startsWith('ghp_')) {
            GITHUB_CONFIG.token = savedToken;
            tokenConfigured = true;
            console.log('âœ… Token cargado desde almacenamiento local seguro');
            addDebugLog('âœ… Token GitHub cargado automÃ¡ticamente', 'success');
            return true;
        } else {
            console.log('âš ï¸ No hay token configurado o token invÃ¡lido');
            addDebugLog('âš ï¸ Token GitHub no configurado', 'warning');
            return false;
        }
        
    } catch (error) {
        console.error('âŒ Error inicializando token:', error);
        addDebugLog(`âŒ Error cargando token: ${error.message}`, 'error');
        return false;
    }
}

/**
 * Solicitar configuraciÃ³n de token al usuario
 */
async function promptForGitHubToken() {
    if (tokenPromptShown || tokenConfigured) {
        return tokenConfigured;
    }
    
    tokenPromptShown = true;
    
    try {
        // Mostrar modal personalizado en lugar de prompt bÃ¡sico
        const token = await showTokenConfigModal();
        
        if (token && token.startsWith('ghp_') && token.length > 20) {
            // Validar token antes de guardarlo
            const isValid = await validateGitHubToken(token);
            
            if (isValid) {
                GITHUB_CONFIG.token = token;
                localStorage.setItem('github_token_secure', token);
                tokenConfigured = true;
                
                console.log('âœ… Token configurado y validado exitosamente');
                addDebugLog('âœ… Token GitHub configurado correctamente', 'success');
                
                // Mostrar notificaciÃ³n de Ã©xito
                showTokenSuccessMessage();
                
                return true;
            } else {
                addDebugLog('âŒ Token invÃ¡lido o sin permisos', 'error');
                showAlert('âŒ Token InvÃ¡lido', 'El token ingresado no es vÃ¡lido o no tiene los permisos necesarios.');
                return false;
            }
        } else if (token === null) {
            // Usuario cancelÃ³
            console.log('â„¹ï¸ Usuario cancelÃ³ configuraciÃ³n de token');
            addDebugLog('â„¹ï¸ ConfiguraciÃ³n de token cancelada - Sistema funcionarÃ¡ solo local', 'info');
            return false;
        } else {
            // Token invÃ¡lido por formato
            addDebugLog('âŒ Formato de token incorrecto', 'error');
            showAlert('âŒ Formato Incorrecto', 'El token debe empezar con "ghp_" y tener mÃ¡s de 20 caracteres.');
            return false;
        }
        
    } catch (error) {
        console.error('âŒ Error solicitando token:', error);
        addDebugLog(`âŒ Error configurando token: ${error.message}`, 'error');
        return false;
    }
}

/**
 * Mostrar modal personalizado para configuraciÃ³n de token
 */
function showTokenConfigModal() {
    return new Promise((resolve) => {
        // Crear modal dinÃ¡mico
        const modalHTML = `
            <div id="tokenConfigModal" class="modal" style="display: block;">
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h3>ğŸ” ConfiguraciÃ³n de Backup en la Nube</h3>
                    </div>
                    <div style="padding: 20px;">
                        <p><strong>Para habilitar el backup automÃ¡tico de fotos en GitHub:</strong></p>
                        <ol style="margin: 15px 0; padding-left: 20px;">
                            <li>Ve a: <a href="https://github.com/settings/tokens" target="_blank">github.com/settings/tokens</a></li>
                            <li>Crea un "Personal access token (classic)"</li>
                            <li>Marca solo el permiso <strong>"repo"</strong></li>
                            <li>Copia el token y pÃ©galo aquÃ­:</li>
                        </ol>
                        
                        <input type="password" id="tokenInput" placeholder="ghp_..." 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; margin: 10px 0; font-family: monospace;">
                        
                        <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <strong>ğŸ”’ Seguridad:</strong><br>
                            â€¢ El token se guarda solo en tu dispositivo<br>
                            â€¢ Nunca se envÃ­a a terceros<br>
                            â€¢ Puedes reconfigurar en cualquier momento
                        </div>
                        
                        <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <strong>â„¹ï¸ Opcional:</strong><br>
                            Si cancelas, el sistema funcionarÃ¡ solo localmente sin backup en la nube.
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; padding: 20px; justify-content: flex-end;">
                        <button onclick="closeTokenModal(null)" class="btn btn-secondary">
                            âŒ Cancelar (Solo Local)
                        </button>
                        <button onclick="submitToken()" class="btn btn-success">
                            âœ… Configurar Backup
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // Remover modal anterior si existe
        const existingModal = document.getElementById('tokenConfigModal');
        if (existingModal) existingModal.remove();
        
        // Agregar nuevo modal
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        // Funciones del modal
        window.closeTokenModal = (token) => {
            const modal = document.getElementById('tokenConfigModal');
            if (modal) modal.remove();
            resolve(token);
        };
        
        window.submitToken = () => {
            const token = document.getElementById('tokenInput').value.trim();
            closeTokenModal(token);
        };
        
        // Focus en input
        setTimeout(() => {
            const input = document.getElementById('tokenInput');
            if (input) {
                input.focus();
                input.onkeypress = (e) => {
                    if (e.key === 'Enter') submitToken();
                };
            }
        }, 100);
    });
}

/**
 * Validar token de GitHub
 */
async function validateGitHubToken(token) {
    try {
        console.log('ğŸ” Validando token de GitHub...');
        
        const response = await fetch(`${GITHUB_CONFIG.baseUrl}`, {
            method: 'GET',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'ControlRondas/1.0'
            }
        });
        
        if (response.ok) {
            console.log('âœ… Token validado exitosamente');
            return true;
        } else {
            console.error(`âŒ Token invÃ¡lido: ${response.status}`);
            return false;
        }
        
    } catch (error) {
        console.error('âŒ Error validando token:', error);
        return false;
    }
}

/**
 * Mostrar mensaje de Ã©xito de configuraciÃ³n
 */
function showTokenSuccessMessage() {
    // Crear notificaciÃ³n temporal
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
        color: white;
        padding: 15px 20px;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0,184,148,0.4);
        z-index: 10000;
        font-weight: bold;
        animation: slideIn 0.5s ease;
    `;
    notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
            <span style="font-size: 1.2rem;">âœ…</span>
            <div>
                <div>Â¡Backup en la nube configurado!</div>
                <small style="opacity: 0.9;">Las fotos se respaldarÃ¡n automÃ¡ticamente</small>
            </div>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Remover despuÃ©s de 4 segundos
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.5s ease forwards';
        setTimeout(() => notification.remove(), 500);
    }, 4000);
}

/**
 * Reconfigurar token (para panel de debug)
 */
async function reconfigureGitHubToken() {
    console.log('ğŸ”„ Reconfigurando token de GitHub...');
    addDebugLog('ğŸ”„ Iniciando reconfiguraciÃ³n de token', 'info');
    
    // Limpiar configuraciÃ³n actual
    localStorage.removeItem('github_token_secure');
    GITHUB_CONFIG.token = '';
    tokenConfigured = false;
    tokenPromptShown = false;
    githubStorage.connected = false;
    
    // Solicitar nueva configuraciÃ³n
    const configured = await promptForGitHubToken();
    
    if (configured) {
        // Reconectar GitHub
        const connected = await checkGitHubConnectivity();
        if (connected) {
            addDebugLog('âœ… Token reconfigurado exitosamente', 'success');
        }
    }
    
    updateDebugSystemStatus();
}

/**
 * Limpiar configuraciÃ³n de token
 */
function clearGitHubToken() {
    console.log('ğŸ—‘ï¸ Limpiando configuraciÃ³n de token...');
    
    localStorage.removeItem('github_token_secure');
    GITHUB_CONFIG.token = '';
    tokenConfigured = false;
    tokenPromptShown = false;
    githubStorage.connected = false;
    
    addDebugLog('ğŸ—‘ï¸ ConfiguraciÃ³n de token limpiada', 'info');
    updateDebugSystemStatus();
    
    showAlert('ğŸ—‘ï¸ Token Limpiado', 'La configuraciÃ³n de GitHub ha sido eliminada. El sistema funcionarÃ¡ solo localmente.');
}

// Variables globales para GitHub Storage
let githubStorage = {
    connected: false,
    uploadQueue: [],
    downloadCache: new Map(),
    statistics: {
        totalUploaded: 0,
        totalSize: 0,
        lastSync: null,
        errors: 0
    },
    // NUEVO: ConfiguraciÃ³n de proxy para CORS
    proxy: {
        enabled: true,
        urls: [
            'https://api.allorigins.win/raw?url=',
            'https://cors-anywhere.herokuapp.com/',
            'https://corsproxy.io/?'
        ],
        currentIndex: 0
    }
};

// Sistema de encriptaciÃ³n para nombres de archivos
class FileEncryption {
    constructor() {
        this.seed = 'control-rondas-2025'; // Semilla fija para consistencia
    }
    
    // Generar hash simple pero efectivo
    simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convertir a 32bit
        }
        return Math.abs(hash).toString(36);
    }
    
    // Generar nombre de archivo encriptado
    encryptFileName(originalData) {
        const timestamp = Date.now().toString();
        const random = Math.random().toString(36).substr(2, 8);
        const combined = this.seed + originalData.plant + timestamp + random;
        return this.simpleHash(combined) + '.jpg';
    }
    
    // Generar nombre de carpeta por mes y planta
    generateFolderName(plant, date) {
        const monthYear = new Date(date).toISOString().substr(0, 7); // 2025-01
        const combined = this.seed + plant + monthYear;
        return this.simpleHash(combined);
    }
    
    // Crear estructura de ruta completa
    createStoragePath(photoData) {
        const folderName = this.generateFolderName(photoData.plant, photoData.timestamp);
        const fileName = this.encryptFileName(photoData);
        return `data/${folderName}/${fileName}`;
    }
}

// Instancia global del encriptador
const fileEncryption = new FileEncryption();

        // ===============================================
        // ğŸ­ UBICACIONES POR PLANTA (SIN CÃ“DIGOS QR VISIBLES)
        // ===============================================
        const plantLocations = {
            matriz: [
                { id: 'MTZ_ENTRADA_001', name: 'Entrada Principal', description: 'Control de acceso principal' },
                { id: 'MTZ_PASILLO_A_002', name: 'Pasillo A', description: 'Calzado Dama' },
                { id: 'MTZ_PASILLO_B_003', name: 'Pasillo B', description: 'Calzado Caballero' },
                { id: 'MTZ_ALMACEN_1_004', name: 'AlmacÃ©n 1', description: 'SecciÃ³n Principal' },
                { id: 'MTZ_ALMACEN_2_005', name: 'AlmacÃ©n 2', description: 'SecciÃ³n Secundaria' },
                { id: 'MTZ_OFICINA_006', name: 'Ãrea Oficinas', description: 'Zona administrativa' },
                { id: 'MTZ_SALIDA_EMERG_007', name: 'Salida Emergencia', description: 'Salida de emergencia' },
                { id: 'MTZ_PATIO_008', name: 'Patio Maniobras', description: 'Ãrea de carga y descarga' },
                { id: 'MTZ_VIGILANCIA_009', name: 'Puesto Vigilancia', description: 'Caseta de vigilancia' },
                { id: 'MTZ_SALIDA_010', name: 'Salida Principal', description: 'Control de salida' }
            ],
            ekzotikart: [
                { id: 'EKZ_ENTRADA_001', name: 'Entrada Principal', description: 'Control de acceso principal' },
                { id: 'EKZ_PASILLO_A_002', name: 'Pasillo A', description: 'Ãrea de producciÃ³n A' },
                { id: 'EKZ_PASILLO_B_003', name: 'Pasillo B', description: 'Ãrea de producciÃ³n B' },
                { id: 'EKZ_ALMACEN_1_004', name: 'AlmacÃ©n 1', description: 'SecciÃ³n Principal' },
                { id: 'EKZ_ALMACEN_2_005', name: 'AlmacÃ©n 2', description: 'SecciÃ³n Secundaria' },
                { id: 'EKZ_OFICINA_006', name: 'Ãrea Oficinas', description: 'Zona administrativa' },
                { id: 'EKZ_SALIDA_EMERG_007', name: 'Salida Emergencia', description: 'Salida de emergencia' },
                { id: 'EKZ_PATIO_008', name: 'Patio Maniobras', description: 'Ãrea de carga y descarga' },
                { id: 'EKZ_VIGILANCIA_009', name: 'Puesto Vigilancia', description: 'Caseta de vigilancia' },
                { id: 'EKZ_SALIDA_010', name: 'Salida Principal', description: 'Control de salida' }
            ]
        };
        // ===============================================
        // â° FUNCIONES DE TIEMPO Y TURNO
        // ===============================================
        function detectCurrentTurn() {
    const now = new Date();
    const hour = now.getHours();
    const minute = now.getMinutes();
    const currentTime = hour + (minute / 60);

    // Cache del resultado por minuto para optimizar
    const cacheKey = `turn_${hour}_${minute}`;
    const cached = sessionStorage.getItem(cacheKey);
    
    if (cached) {
        return JSON.parse(cached);
    }

    let result;
    if (currentTime >= 7.5 && currentTime < 19.5) {
        result = {
            name: 'diurno',
            display: 'ğŸŒ… Turno Diurno (07:30 - 19:30)',
            icon: 'ğŸŒ…',
            timeRange: '07:30-19:30'
        };
    } else {
        result = {
            name: 'nocturno',
            display: 'ğŸŒ™ Turno Nocturno (19:30 - 07:30)',
            icon: 'ğŸŒ™',
            timeRange: '19:30-07:30'
        };
    }
    
    // Cache por 1 minuto
    sessionStorage.setItem(cacheKey, JSON.stringify(result));
    setTimeout(() => sessionStorage.removeItem(cacheKey), 60000);
    
    return result;
}

        function updateCurrentTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('es-ES', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            const currentTimeEl = document.getElementById('currentTime');
            if (currentTimeEl) {
                currentTimeEl.textContent = timeString;
            }

            const turn = detectCurrentTurn();
            const currentTurnEl = document.getElementById('currentTurn');
            if (currentTurnEl) {
                currentTurnEl.textContent = turn.display;
            }

            return turn;
        }

        // ===============================================
        // ğŸšª FUNCIONES DE NAVEGACIÃ“N
        // ===============================================
        function selectRole(role) {
            if (role === 'guard') {
                document.getElementById('roleScreen').classList.add('hidden');
                document.getElementById('plantScreen').classList.remove('hidden');
                updateCurrentTime();
                setInterval(updateCurrentTime, 60000);
            } else if (role === 'supervisor') {
                document.getElementById('roleScreen').classList.add('hidden');
                document.getElementById('passwordScreen').classList.remove('hidden');
            }
        }

        function verifyPassword() {
            const password = document.getElementById('passwordInput').value;
            const correctPassword = 'salomec4';
            
            if (password === correctPassword) {
                document.getElementById('passwordScreen').classList.add('hidden');
                document.getElementById('supervisorDashboard').classList.remove('hidden');
                
                setTimeout(async () => {
    console.log('ğŸ‘” Cargando dashboard supervisor con datos globales...');
    
    // Auto-sincronizaciÃ³n al abrir dashboard
    if (githubStorage.connected) {
        try {
            addDebugLog('ğŸ‘” Auto-sincronizaciÃ³n al abrir dashboard', 'info');
            await syncAllDataForSupervisor();
        } catch (error) {
            console.error('âŒ Error en auto-sincronizaciÃ³n:', error);
            // Cargar datos locales como fallback
            await loadDashboardDataWithPhotos();
        }
    } else {
        console.log('âš ï¸ Sin conexiÃ³n GitHub, cargando datos locales');
        await loadDashboardDataWithPhotos();
        
        // Mostrar sugerencia de configurar token
        setTimeout(() => {
            if (!tokenConfigured) {
                showAlert('ğŸ’¡ Sugerencia', 'Configura el token de GitHub para ver datos de todos los dispositivos');
            }
        }, 2000);
    }
}, 100);
            } else {
                document.getElementById('passwordError').style.display = 'block';
                document.getElementById('passwordInput').value = '';
            }
        }

        function checkPassword(event) {
            if (event.key === 'Enter') {
                verifyPassword();
            }
        }

        function selectPlant(plant) {
            currentPlant = plant;
            const turn = updateCurrentTime();
            currentTurn = turn.name;
            
            document.getElementById('plantScreen').classList.add('hidden');
            document.getElementById('roundsScreen').classList.remove('hidden');
            
            const plantTitle = document.getElementById('plantTitle');
            const turnDisplay = document.getElementById('turnDisplay');
            
            if (plant === 'matriz') {
                plantTitle.textContent = 'ğŸ¢ MATRIZ';
            } else {
                plantTitle.textContent = 'ğŸ­ EKZOTIKART';
            }
            
            turnDisplay.textContent = turn.display;
            
            loadPlantLocations();
            loadRoundsHistory();
        }

        function goBack() {
            // NUEVO: Limpiar scanner al regresar
            if (scanningActive) {
                cancelQRScan();
            }
            
            document.querySelectorAll('.card, .dashboard').forEach(el => {
                el.classList.add('hidden');
            });
            
            document.getElementById('roleScreen').classList.remove('hidden');
            
            document.getElementById('passwordInput').value = '';
            document.getElementById('passwordError').style.display = 'none';
        }

        function goBackToPlant() {
            document.getElementById('roundsScreen').classList.add('hidden');
            document.getElementById('plantScreen').classList.remove('hidden');
            
            // NUEVO: Limpiar scanner
            if (scanningActive) {
                cancelQRScan();
            }
            
            if (currentRound) {
                finishRound();
            }
        }

        function logout() {
            goBack();
        }

        // ===============================================
        // ğŸ“ FUNCIONES DE UBICACIONES (SIN CÃ“DIGOS QR VISIBLES)
        // ===============================================
        function loadPlantLocations() {
    const locations = plantLocations[currentPlant];
    const grid = document.getElementById('locationsGrid');
    
    if (!grid) {
        console.error('âŒ Element locationsGrid not found');
        return;
    }
    
    if (!locations) {
        console.error('âŒ No locations found for plant:', currentPlant);
        return;
    }
    
    grid.innerHTML = locations.map(location => `
                <div class="location-card" id="card-${location.id}">
                    <h4>${location.name}</h4>
                    <p><small>${location.description}</small></p>
                    <div style="margin-top: 10px;">
                        <span class="status" id="status-${location.id}">â³ Pendiente</span>
                    </div>
                </div>
            `).join('');

            const locationSelect = document.getElementById('observationLocation');
            locationSelect.innerHTML = '<option value="">Seleccionar ubicaciÃ³n...</option>' +
                locations.map(loc => `<option value="${loc.id}">${loc.name}</option>`).join('');
        }

        // ===============================================
        // ğŸš€ FUNCIONES DE RECORRIDO
        // ===============================================
        function startRound() {
            currentRound = {
                id: Date.now().toString(),
                plant: currentPlant,
                turn: currentTurn,
                startTime: new Date(),
                locations: {},
                incidents: [],
                completed: false
            };

            roundStartTime = Date.now();
            
            document.getElementById('startRoundBtn').classList.add('hidden');
            document.getElementById('scanQRBtn').classList.remove('hidden');
            document.getElementById('finishRoundBtn').classList.remove('hidden');
            document.getElementById('progressContainer').classList.remove('hidden');
            showFloatingButton();
            
            startRoundTimer();
            updateProgress();
            
            // NUEVO: VibraciÃ³n de confirmaciÃ³n en mÃ³viles
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100]);
            }
        }

        function startRoundTimer() {
            roundTimer = setInterval(() => {
                const elapsed = Date.now() - roundStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('elapsedTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // ===============================================
        // ğŸ“± SCANNER QR COMPLETAMENTE CORREGIDO Y FUNCIONAL
        // ===============================================
        let debugMode = false;
        let frameCount = 0;

        function toggleDebugInfo() {
            debugMode = !debugMode;
            const debugInfo = document.getElementById('debugInfo');
            debugInfo.style.display = debugMode ? 'block' : 'none';
        }

        function showQRScanner() {
    console.log('ğŸš€ Iniciando QR Scanner...');
    
    document.getElementById('qrScannerSection').classList.remove('hidden');
    document.getElementById('scanQRBtn').classList.add('hidden');
    document.getElementById('finishRoundBtn').classList.add('hidden');
    
    initQRScanner();
}

        // ===============================================
// ğŸ“± SISTEMA QR SIMPLIFICADO Y ROBUSTO
// ===============================================

async function initQRScanner() {
    try {
        console.log('ğŸš€ Iniciando scanner QR simplificado...');
        
        // Mostrar carga
        document.getElementById('cameraLoading').classList.remove('hidden');
        document.getElementById('qrScannerContent').classList.add('hidden');
        
        // Cargar jsQR si no estÃ¡ disponible
        if (typeof jsQR === 'undefined') {
            await loadJsQRLibrary();
        }
        
        // Inicializar video
        await initQRVideo();
        
        console.log('âœ… Scanner QR listo');
        
    } catch (error) {
        console.error('âŒ Error inicializando scanner:', error);
        showQRError('No se pudo inicializar el scanner QR');
    }
}

async function loadJsQRLibrary() {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/jsqr@1.4.0/dist/jsQR.js';
        script.onload = () => {
            console.log('ğŸ“¦ jsQR cargado exitosamente');
            resolve();
        };
        script.onerror = () => {
            reject(new Error('Error cargando librerÃ­a jsQR'));
        };
        document.head.appendChild(script);
    });
}

function showQRError(message) {
    document.getElementById('cameraLoading').classList.add('hidden');
    document.getElementById('qrScannerContent').classList.remove('hidden');
    
    const container = document.getElementById('qrVideoContainer');
    container.innerHTML = `
        <div style="padding: 40px; text-align: center; background: #ffebee; border-radius: 15px;">
            <h4 style="color: #c62828; margin-bottom: 15px;">âŒ Error</h4>
            <p style="color: #666;">${message}</p>
            <button class="btn btn-warning" onclick="initQRScanner()" style="margin-top: 15px;">
                ğŸ”„ Reintentar
            </button>
        </div>
    `;
}

        function updateLoadingMessage(message) {
            const loadingEl = document.querySelector('#cameraLoading p');
            if (loadingEl) {
                loadingEl.textContent = message;
            }
            console.log('ğŸ“ Loading:', message);
        }

        function updateDebugStatus(elementId, status) {
            if (debugMode) {
                const el = document.getElementById(elementId);
                if (el) el.textContent = status;
            }
        }

        // NUEVA: FunciÃ³n para verificar estado de jsQR (debug)
        function debugJsQR() {
            console.log('ğŸ”§ DEBUG jsQR:');
            console.log('- typeof jsQR:', typeof jsQR);
            console.log('- window.jsQR:', typeof window.jsQR);
            console.log('- Scripts cargados:', document.querySelectorAll('script[src*="jsQR"]'));
            
            // Intentar llamar jsQR si existe
            if (typeof jsQR === 'function') {
                console.log('- jsQR es funciÃ³n: âœ…');
                try {
                    // Crear datos de prueba
                    const testData = new Uint8ClampedArray(4);
                    const result = jsQR(testData, 1, 1);
                    console.log('- jsQR funciona: âœ…', result);
                } catch (e) {
                    console.log('- Error ejecutando jsQR:', e);
                }
            } else {
                console.log('- jsQR NO es funciÃ³n: âŒ');
            }
        }
        function initQRVideo() {
    updateLoadingMessage('ğŸ“· Iniciando cÃ¡mara...');
    
    qrVideo = document.getElementById('qrVideo');
    
    if (!qrVideo) {
        console.error('âŒ Video element not found');
        
        // Intentar recrear el elemento video
        const container = document.getElementById('qrVideoContainer');
        if (container) {
            container.innerHTML = `
                <video id="qrVideo" autoplay playsinline muted></video>
                <div class="qr-overlay"></div>
            `;
            qrVideo = document.getElementById('qrVideo');
        }
        
        if (!qrVideo) {
            showQRError('Elemento de video no encontrado');
            return;
        }
    }
            
            // CORREGIDO: Constraints mÃ¡s compatibles
            const constraints = {
                video: {
                    facingMode: 'environment',
                    width: { ideal: 640, min: 320 },
                    height: { ideal: 480, min: 240 }
                }
            };
            
            console.log('ğŸ“· Solicitando acceso a cÃ¡mara...');
            updateLoadingMessage('ğŸ“· Solicitando permisos de cÃ¡mara...');
            
            navigator.mediaDevices.getUserMedia(constraints)
                .then(stream => {
                    console.log('âœ… CÃ¡mara obtenida exitosamente');
                    
                    qrStream = stream;
                    qrVideo.srcObject = stream;
                    
                    updateDebugStatus('videoStatus', 'âœ… OK');
                    updateLoadingMessage('ğŸ“¹ Configurando video...');
                    
                    // CORREGIDO: Mejor manejo de eventos de video
                    qrVideo.addEventListener('loadedmetadata', () => {
                        console.log('ğŸ“¹ Video metadata cargada');
                        console.log(`Video size: ${qrVideo.videoWidth}x${qrVideo.videoHeight}`);
                        
                        qrVideo.play().then(() => {
                            console.log('â–¶ï¸ Video iniciado');
                            updateLoadingMessage('âœ… Video iniciado, preparando scanner...');
                            
                            // Esperar un poco mÃ¡s para asegurar que el video estÃ© estable
                            setTimeout(() => {
                                document.getElementById('cameraLoading').classList.add('hidden');
                                document.getElementById('qrScannerContent').classList.remove('hidden');
                                
                                startQRDetection();
                            }, 1500);
                            
                        }).catch(err => {
                            console.error('âŒ Error al reproducir video:', err);
                            showQRError('Error al iniciar video');
                        });
                    });
                    
                    qrVideo.addEventListener('error', (err) => {
                        console.error('âŒ Error en video element:', err);
                        showQRError('Error en elemento de video');
                    });
                    
                })
                .catch(error => {
                    console.error('âŒ Error de cÃ¡mara:', error);
                    let errorMsg = 'Error desconocido de cÃ¡mara';
                    
                    if (error.name === 'NotAllowedError') {
                        errorMsg = 'Permisos de cÃ¡mara denegados';
                    } else if (error.name === 'NotFoundError') {
                        errorMsg = 'No se encontrÃ³ cÃ¡mara disponible';
                    } else if (error.name === 'NotReadableError') {
                        errorMsg = 'CÃ¡mara en uso por otra aplicaciÃ³n';
                    } else if (error.name === 'OverconstrainedError') {
                        errorMsg = 'ConfiguraciÃ³n de cÃ¡mara no soportada';
                    }
                    // Sugerir soluciones especÃ­ficas
    if (error.name === 'NotReadableError') {
        errorMsg += '\n\nğŸ’¡ Soluciones:\nâ€¢ Cierra otras aplicaciones que usen la cÃ¡mara\nâ€¢ Reinicia el navegador\nâ€¢ Verifica que no estÃ© bloqueada fÃ­sicamente';
    }
                    
                    updateDebugStatus('videoStatus', 'âŒ Error');
                    showQRError(errorMsg);
                });
        }

        function startQRDetection() {
            // CORREGIDO: VerificaciÃ³n doble de jsQR
            if (typeof jsQR === 'undefined') {
                console.error('âŒ jsQR no disponible para detecciÃ³n');
                showQRError('LibrerÃ­a QR no disponible');
                return;
            }
            
            scanningActive = true;
            frameCount = 0;
            
            console.log('ğŸ” Iniciando detecciÃ³n QR...');
            updateScanStatus('ğŸ” Buscando cÃ³digo QR...', 'scanning');
            
            // CORREGIDO: Canvas fuera del loop para mejor rendimiento
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            function detectQR() {
                if (!scanningActive || !qrVideo) {
                    console.log('ğŸ›‘ DetecciÃ³n QR detenida');
                    return;
                }
                
                frameCount++;
                updateDebugStatus('frameCount', frameCount);
                
                try {
                    // CORREGIDO: Verificaciones mÃ¡s robustas
                    if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA && 
                        qrVideo.videoWidth > 0 && 
                        qrVideo.videoHeight > 0) {
                        
                        // Configurar canvas solo si cambiÃ³ el tamaÃ±o
                        if (canvas.width !== qrVideo.videoWidth || canvas.height !== qrVideo.videoHeight) {
                            canvas.width = qrVideo.videoWidth;
                            canvas.height = qrVideo.videoHeight;
                            console.log(`ğŸ“ Canvas redimensionado: ${canvas.width}x${canvas.height}`);
                        }
                        
                        // Capturar frame actual
                        context.drawImage(qrVideo, 0, 0, canvas.width, canvas.height);
                        
                        // Obtener datos de imagen
                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        
                        // CORREGIDO: DetecciÃ³n QR con opciones optimizadas
                        try {
                            const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                                inversionAttempts: "dontInvert"
                            });
                            
                            if (qrCode && qrCode.data && scanningActive) {
                                console.log('ğŸ¯ QR Code detectado:', qrCode.data);
                                processDetectedQR(qrCode.data);
                                return; // Salir del loop
                            }
                        } catch (jsqrError) {
                            console.error('âŒ Error en jsQR:', jsqrError);
                            // Continuar sin detener el scanner
                        }
                    }
                    
                    // Continuar detecciÃ³n si estÃ¡ activa
                    if (scanningActive) {
                        qrDetectionLoop = requestAnimationFrame(detectQR);
                    }
                    
                } catch (error) {
                    console.error('âŒ Error en loop de detecciÃ³n:', error);
                    // Continuar a pesar del error
                    if (scanningActive) {
                        qrDetectionLoop = requestAnimationFrame(detectQR);
                    }
                }
            }
            
            // Iniciar loop de detecciÃ³n
            qrDetectionLoop = requestAnimationFrame(detectQR);
            console.log('ğŸ”„ Loop de detecciÃ³n iniciado');
        }

        function processDetectedQR(qrData) {
            if (!scanningActive) return;
            
            console.log('ğŸ”„ Procesando QR:', qrData);
            
            // Detener scanning inmediatamente
            scanningActive = false;
            if (qrDetectionLoop) {
                cancelAnimationFrame(qrDetectionLoop);
                qrDetectionLoop = null;
            }
            
            // Limpiar y validar cÃ³digo QR
            const cleanQR = qrData.trim().toUpperCase();
            
            // Validar formato
            if (!validateQRFormat(cleanQR)) {
                return;
            }
            
            // Validar planta
            if (!validateQRPlant(cleanQR)) {
                return;
            }
            
            // Validar ubicaciÃ³n existente
            if (!validateQRLocation(cleanQR)) {
                return;
            }
            
            // Validar que no estÃ© ya visitada
            if (!validateQRNotVisited(cleanQR)) {
                return;
            }
            
            // âœ… TODO VÃLIDO - Procesar ubicaciÃ³n
            processValidQR(cleanQR);
        }

        function validateQRFormat(qrCode) {
            if (!qrCode.match(/^(MTZ|EKZ)_[A-Z_]+_\d{3}$/)) {
                updateScanStatus('âŒ Formato de QR invÃ¡lido', 'error');
                setTimeout(() => {
                    showAlert('âŒ CÃ³digo QR No VÃ¡lido', 'Formato esperado: MTZ_UBICACION_001 o EKZ_UBICACION_001');
                    restartQRScan();
                }, 1500);
                return false;
            }
            return true;
        }

        function validateQRPlant(qrCode) {
            const plantPrefix = currentPlant === 'matriz' ? 'MTZ' : 'EKZ';
            if (!qrCode.startsWith(plantPrefix)) {
                updateScanStatus('âŒ QR de planta incorrecta', 'error');
                setTimeout(() => {
                    showAlert('âŒ Planta Incorrecta', `Esperaba: ${plantPrefix}_...\nDetectado: ${qrCode}\n\nVerifica que estÃ©s en la planta correcta.`);
                    restartQRScan();
                }, 1500);
                return false;
            }
            return true;
        }

        function validateQRLocation(qrCode) {
            const locations = plantLocations[currentPlant];
            const location = locations.find(loc => loc.id === qrCode);
            
            if (!location) {
                updateScanStatus('âŒ UbicaciÃ³n no registrada', 'error');
                setTimeout(() => {
                    showAlert('âŒ UbicaciÃ³n No Encontrada', 'Esta ubicaciÃ³n no estÃ¡ registrada en el sistema.\n\nContacta al administrador.');
                    restartQRScan();
                }, 1500);
                return false;
            }
            return true;
        }

        function validateQRNotVisited(qrCode) {
            if (currentRound.locations[qrCode]) {
                updateScanStatus('âš ï¸ UbicaciÃ³n ya visitada', 'error');
                setTimeout(() => {
                    showAlert('âš ï¸ Ya Visitada', 'Esta ubicaciÃ³n ya fue registrada en este recorrido.');
                    restartQRScan();
                }, 1500);
                return false;
            }
            return true;
        }

        function processValidQR(qrCode) {
            console.log('âœ… QR vÃ¡lido, procesando ubicaciÃ³n:', qrCode);
            
            updateScanStatus('âœ… Â¡UbicaciÃ³n registrada!', 'success');
            
            // NUEVO: Efectos de Ã©xito
            if (navigator.vibrate) {
                navigator.vibrate([200, 100, 200]); // VibraciÃ³n de Ã©xito
            }
            
            // Efecto visual de Ã©xito
            const scannerSection = document.getElementById('qrScannerSection');
            scannerSection.classList.add('qr-success');
            
            setTimeout(() => {
                scannerSection.classList.remove('qr-success');
                processQRScan(qrCode);
                cancelQRScan();
            }, 2000);
        }

        function processQRScan(locationId) {
            console.log('ğŸ“ Registrando ubicaciÃ³n:', locationId);
            
            currentRound.locations[locationId] = {
                timestamp: new Date(),
                observations: [],
                photos: []
            };
            
            // Actualizar tarjeta visual
            const card = document.getElementById(`card-${locationId}`);
            const status = document.getElementById(`status-${locationId}`);
            
            if (card && status) {
                card.classList.add('completed');
                status.textContent = 'âœ… Completado';
                status.style.color = '#28a745';
            }
            
            // Actualizar progreso
            updateProgress();
            
            // Sonido de Ã©xito
            playQRSuccessSound();
            
            console.log('âœ… UbicaciÃ³n registrada exitosamente');
        }

        function restartQRScan() {
            if (!scanningActive) {
                console.log('ğŸ”„ Reiniciando scanner...');
                scanningActive = true;
                updateScanStatus('ğŸ” Buscando cÃ³digo QR...', 'scanning');
                startQRDetection();
            }
        }

        function cancelQRScan() {
            console.log('ğŸ›‘ Cancelando QR Scanner...');
            
            // Detener scanning
            scanningActive = false;
            if (qrDetectionLoop) {
                cancelAnimationFrame(qrDetectionLoop);
                qrDetectionLoop = null;
            }
            
            // Detener cÃ¡mara
            if (qrStream) {
                qrStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('ğŸ”’ Track de cÃ¡mara detenido:', track.kind);
                });
                qrStream = null;
            }
            
            // Limpiar video
            if (qrVideo) {
                qrVideo.srcObject = null;
            }
            
            // Ocultar scanner y restaurar botones
            document.getElementById('qrScannerSection').classList.add('hidden');
            document.getElementById('scanQRBtn').classList.remove('hidden');
            document.getElementById('finishRoundBtn').classList.remove('hidden');
            
            // Reset debug
            frameCount = 0;
            updateDebugStatus('frameCount', '0');
            updateDebugStatus('videoStatus', '-');
            updateDebugStatus('jsqrStatus', '-');
            
            console.log('âœ… QR Scanner cancelado completamente');
        }

        function updateScanStatus(message, type) {
            const statusEl = document.getElementById('scanStatus');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = `scan-status ${type}`;
            }
        }

        function showQRError(message) {
            document.getElementById('cameraLoading').classList.add('hidden');
            document.getElementById('qrScannerContent').classList.remove('hidden');
            
            const container = document.getElementById('qrVideoContainer');
            container.innerHTML = `
                <div style="padding: 40px; text-align: center; background: #ffebee; border-radius: 15px;">
                    <h4 style="color: #c62828; margin-bottom: 15px;">âŒ Error de CÃ¡mara</h4>
                    <p style="color: #666;">${message}</p>
                    <button class="btn btn-warning" onclick="retryQRCamera()" style="margin-top: 15px;">
                        ğŸ”„ Reintentar
                    </button>
                </div>
            `;
            
            updateScanStatus('âŒ Error de cÃ¡mara', 'error');
            updateDebugStatus('videoStatus', 'âŒ Error');
        }

        function retryQRCamera() {
            document.getElementById('cameraLoading').classList.remove('hidden');
            document.getElementById('qrScannerContent').classList.add('hidden');
            
            // Recrear elemento de video
            const container = document.getElementById('qrVideoContainer');
            container.innerHTML = `
                <video id="qrVideo" autoplay playsinline muted></video>
                <div class="qr-overlay"></div>
            `;
            
            setTimeout(() => {
                initQRVideo();
            }, 1000);
        }

        function updateProgress() {
    const total = plantLocations[currentPlant].length;
    const completed = Object.keys(currentRound.locations).length;
    const percentage = (completed / total) * 100;
    
    document.getElementById('progressFill').style.width = `${percentage}%`;
    document.getElementById('completedLocations').textContent = completed;
    document.getElementById('totalLocations').textContent = total;
    
    // NUEVO: Indicador siempre flexible
    const progressContainer = document.getElementById('progressContainer');
    const existingIndicator = progressContainer.querySelector('.round-type-indicator');
    if (existingIndicator) {
        existingIndicator.remove();
    }
    
    const indicator = document.createElement('p');
    indicator.className = 'round-type-indicator';
    indicator.style.cssText = 'font-size: 0.9rem; color: #1976d2; margin-top: 10px;';
    indicator.innerHTML = 'ğŸ”„ <strong>Recorrido Flexible</strong> - Sin restricciones, escanea las ubicaciones necesarias';
    
    progressContainer.appendChild(indicator);
}

        function finishRound() {
    if (!currentRound) return;
    
    // Limpiar scanner si estÃ¡ activo
    if (scanningActive) {
        cancelQRScan();
    }
    
    const completedLocations = Object.keys(currentRound.locations).length;
    const totalLocations = plantLocations[currentPlant].length;
    
    // CORREGIDO: Sin restricciones - Cualquier cantidad de ubicaciones es vÃ¡lida
    currentRound.endTime = new Date();
    currentRound.completed = true;
    currentRound.completionPercentage = Math.round((completedLocations / totalLocations) * 100);
    
    if (roundTimer) {
        clearInterval(roundTimer);
        roundTimer = null;
    }
    
    const rounds = JSON.parse(localStorage.getItem('rounds') || '[]');
    rounds.push(currentRound);
    localStorage.setItem('rounds', JSON.stringify(rounds));
    
    const allIncidents = JSON.parse(localStorage.getItem('incidents') || '[]');
    if (currentRound.incidents && currentRound.incidents.length > 0) {
        allIncidents.push(...currentRound.incidents);
        localStorage.setItem('incidents', JSON.stringify(allIncidents));
    }
    
    document.getElementById('startRoundBtn').classList.remove('hidden');
    document.getElementById('scanQRBtn').classList.add('hidden');
    document.getElementById('finishRoundBtn').classList.add('hidden');
    document.getElementById('progressContainer').classList.add('hidden');
    hideFloatingButton();
    
    currentRound = null;
    loadRoundsHistory();
    
    // Efectos de finalizaciÃ³n
    if (navigator.vibrate) {
        navigator.vibrate([300, 200, 300, 200, 300]);
    }
    
    // NUEVO: Mensaje personalizado segÃºn ubicaciones visitadas
    const percentage = Math.round((completedLocations / totalLocations) * 100);
    let message = `Recorrido guardado exitosamente.\n\nğŸ“ Ubicaciones visitadas: ${completedLocations}/${totalLocations} (${percentage}%)`;
    
    if (completedLocations === 0) {
        message = 'Recorrido guardado sin ubicaciones visitadas.';
    } else if (percentage === 100) {
        message += '\n\nğŸ‰ Â¡Recorrido completo!';
    }
    
    showAlert('âœ… Recorrido Finalizado', message);
}
        // ===============================================
        // ğŸ”Š FUNCIONES DE SONIDO Y EFECTOS
        // ===============================================
        function playQRSuccessSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Sonido de Ã©xito mÃ¡s elaborado
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator1.frequency.setValueAtTime(600, audioContext.currentTime);
                oscillator1.frequency.setValueAtTime(800, audioContext.currentTime + 0.1);
                
                oscillator2.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator2.frequency.setValueAtTime(1000, audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator1.start(audioContext.currentTime);
                oscillator1.stop(audioContext.currentTime + 0.3);
                oscillator2.start(audioContext.currentTime);
                oscillator2.stop(audioContext.currentTime + 0.3);
                
            } catch (e) {
                console.log('ğŸ”‡ Audio no disponible');
            }
        }

        function showAlert(title, message) {
            // VersiÃ³n mejorada de alert
            if (typeof title === 'string' && typeof message === 'string') {
                alert(title + '\n\n' + message);
            } else {
                alert(title);
            }
        }

        // ===============================================
        // ğŸ’¬ FUNCIONES DE MODAL Y OBSERVACIONES
        // ===============================================
        /**
/**
 * Abrir modal de observaciones/incidencias dinÃ¡mico
 */
function openObservationModal(locationId = null) {
    try {
        console.log('ğŸ“ Abriendo modal dinÃ¡mico de observaciones...');
        addDebugLog('ğŸ“ Modal de observaciones abierto', 'info');
        
        // Eliminar modal existente si hay uno
        const existingModal = document.getElementById('observationModal');
        if (existingModal) {
            existingModal.remove();
        }
        
        isIncidentMode = locationId === null;
        
        // Crear modal dinÃ¡mico
        const modalHTML = `
        <div id="observationModal" style="
            display: block !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            background: rgba(0,0,0,0.8) !important;
            z-index: 999999 !important;
            overflow-y: auto !important;
        ">
            <div class="modal-content-dynamic" style="
                background: white !important;
                margin: 5% auto !important;
                padding: 30px !important;
                border-radius: 15px !important;
                max-width: 600px !important;
                width: 90% !important;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5) !important;
                position: relative !important;
            ">
                <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #eee;">
                    <h3 id="modalTitle">${isIncidentMode ? 'ğŸš¨ Reportar Incidencia' : 'ğŸ“ Observaciones de UbicaciÃ³n'}</h3>
                    <button onclick="closeDynamicModal()" style="background: none; border: none; font-size: 2rem; cursor: pointer; color: #999;">&times;</button>
                </div>
                
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">ğŸ“ UbicaciÃ³n:</label>
                    <select id="observationLocation" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem;">
                        <option value="">Seleccionar ubicaciÃ³n...</option>
                    </select>
                </div>
                
                <div id="incidentTypeGroup" class="form-group" style="margin-bottom: 20px; ${!isIncidentMode ? 'display: none;' : ''}">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">ğŸ·ï¸ Tipo de Incidencia:</label>
                    <select id="incidentType" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem;">
                        <option value="">Seleccionar tipo...</option>
                        <option value="personas">ğŸ‘¥ Personas</option>
                        <option value="seguridad">ğŸ”’ Seguridad</option>
                        <option value="mantenimiento">ğŸ”§ Mantenimiento</option>
                        <option value="materiales">ğŸ“¦ Materiales</option>
                    </select>
                </div>
                
                <div id="priorityGroup" class="form-group" style="margin-bottom: 20px; ${!isIncidentMode ? 'display: none;' : ''}">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">âš¡ Nivel de Urgencia:</label>
                    <select id="incidentPriority" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem;">
                        <option value="normal">ğŸ”µ Normal</option>
                        <option value="high">ğŸŸ¡ Alta</option>
                        <option value="urgent">ğŸ”´ URGENTE - Requiere atenciÃ³n inmediata</option>
                    </select>
                    <small style="color: #666; margin-top: 5px; display: block;">
                        âš ï¸ Las incidencias URGENTES envÃ­an notificaciones inmediatas al equipo de supervisiÃ³n
                    </small>
                </div>
                
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">ğŸ“ DescripciÃ³n (Opcional):</label>
                    <textarea id="observationText" placeholder="Describe la ${isIncidentMode ? 'incidencia' : 'observaciÃ³n'}..." style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem; resize: vertical; min-height: 100px;"></textarea>
                </div>
                
                <div class="camera-container" style="text-align: center; margin: 20px 0;">
                    <h4>ğŸ“¸ Evidencia FotogrÃ¡fica (Opcional)</h4>
                    <p style="font-size: 0.9rem; color: #666;">ğŸ’¡ Solo toma foto si es necesaria para documentar</p>
                    <video id="cameraPreview" class="camera-preview" style="display: none; width: 100%; max-width: 400px; border-radius: 10px; margin-bottom: 15px;" autoplay></video>
                    <canvas id="photoCanvas" style="display: none;"></canvas>
                    <img id="capturedPhoto" class="camera-preview" style="display: none; width: 100%; max-width: 400px; border-radius: 10px; margin-bottom: 15px;">
                    
                    <div id="cameraButtons">
                        <button class="btn" onclick="startCamera()" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin: 5px;">ğŸ“· Activar CÃ¡mara</button>
                        <button id="captureBtn" class="btn btn-success hidden" onclick="capturePhotoImproved()" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin: 5px;">ğŸ“¸ Tomar Foto</button>
                        <button id="retakeBtn" class="btn btn-warning hidden" onclick="retakePhotoImproved()" style="background: #ffc107; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin: 5px;">ğŸ”„ Tomar de Nuevo</button>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="closeDynamicModal()" style="background: #6c757d; color: white; border: none; padding: 15px 30px; border-radius: 8px; cursor: pointer; flex: 1;">âŒ Cancelar</button>
                    <button class="btn btn-success" onclick="saveDynamicObservation()" style="background: #28a745; color: white; border: none; padding: 15px 30px; border-radius: 8px; cursor: pointer; flex: 1;">âœ… Guardar</button>
                </div>
            </div>
        </div>
        `;
        
        // Agregar modal al body
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        // Poblar ubicaciones
        populateLocationSelect(locationId);
        
        console.log('âœ… Modal dinÃ¡mico creado exitosamente');
        
    } catch (error) {
        console.error('âŒ Error abriendo modal dinÃ¡mico:', error);
        addDebugLog(`âŒ Error modal: ${error.message}`, 'error');
        showAlert('âŒ Error', 'Error abriendo modal de observaciones');
    }
}

/**
 * Poblar select de ubicaciones
 */
function populateLocationSelect(selectedLocationId = null) {
    const locationSelect = document.getElementById('observationLocation');
    if (locationSelect && currentPlant) {
        const locations = plantLocations[currentPlant];
        if (locations) {
            // Limpiar opciones existentes excepto la primera
            locationSelect.innerHTML = '<option value="">Seleccionar ubicaciÃ³n...</option>';
            
            // Agregar ubicaciones
            locations.forEach(loc => {
                const option = document.createElement('option');
                option.value = loc.id;
                option.textContent = loc.name;
                locationSelect.appendChild(option);
            });
            
            // Seleccionar ubicaciÃ³n si se especificÃ³
            if (selectedLocationId) {
                locationSelect.value = selectedLocationId;
            }
        }
    }
}

/**
 * Cerrar modal dinÃ¡mico
 */
function closeDynamicModal() {
    const modal = document.getElementById('observationModal');
    if (modal) {
        modal.remove();
        console.log('ğŸ”’ Modal dinÃ¡mico cerrado');
    }
    
    // Limpiar datos de foto actual
    window.currentPhotoData = null;
    
    // Detener cÃ¡mara si estÃ¡ activa
    if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
    }
}

/**
 * Guardar observaciÃ³n desde modal dinÃ¡mico
 */
function saveDynamicObservation() {
    try {
        console.log('ğŸ’¾ Guardando observaciÃ³n desde modal dinÃ¡mico...');
        
        const locationId = document.getElementById('observationLocation').value;
        const text = document.getElementById('observationText').value.trim();
        const incidentType = document.getElementById('incidentType').value;
        const incidentPriority = document.getElementById('incidentPriority').value;
        
        // Validaciones
        if (!locationId) {
            showAlert('âš ï¸ UbicaciÃ³n requerida', 'Selecciona una ubicaciÃ³n para continuar');
            return;
        }
        
        if (isIncidentMode && !incidentType) {
            showAlert('âš ï¸ Tipo requerido', 'Selecciona el tipo de incidencia');
            return;
        }
        
        // Crear objeto de observaciÃ³n
        const observation = {
            id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
            locationId,
            text: text || 'Sin observaciones adicionales',
            timestamp: new Date().toISOString(),
            type: isIncidentMode ? 'incident' : 'observation',
            incidentType: incidentType || null,
            priority: incidentPriority || 'normal',
            plant: currentPlant,
            turn: currentTurn,
            photoData: window.currentPhotoData || null,
            hasPhoto: !!(window.currentPhotoData)
        };
        
        // Agregar informaciÃ³n de backup si hay foto
        if (window.currentPhotoData && window.currentPhotoData.backedUp) {
            observation.photoData.cloudBackup = {
                backedUp: true,
                githubPath: window.currentPhotoData.githubPath,
                downloadUrl: window.currentPhotoData.downloadUrl
            };
            console.log('â˜ï¸ ObservaciÃ³n incluye foto respaldada en la nube');
        } else if (window.currentPhotoData) {
            observation.photoData.cloudBackup = {
                backedUp: false,
                pending: true
            };
            console.log('ğŸ“‹ ObservaciÃ³n incluye foto pendiente de respaldo');
        }
        
        // Guardar segÃºn el tipo de observaciÃ³n
        if (isIncidentMode) {
            // Guardar incidencia
            const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
            incidents.push(observation);
            localStorage.setItem('incidents', JSON.stringify(incidents));
            
            // Agregar al recorrido actual
            if (currentRound) {
                if (!currentRound.incidents) currentRound.incidents = [];
                currentRound.incidents.push(observation);
            }
            
            // Verificar incidencias crÃ­ticas
            checkCriticalIncident(observation);
            
            console.log('ğŸš¨ Incidencia guardada exitosamente');
            addDebugLog('ğŸš¨ Incidencia registrada correctamente', 'success');
            showAlert('âœ… Incidencia registrada', 'Incidencia reportada correctamente' + (observation.hasPhoto ? ' con evidencia fotogrÃ¡fica' : ''));
            
        } else {
            // Guardar observaciÃ³n en recorrido
            if (currentRound && currentRound.locations[observation.locationId]) {
                if (!currentRound.locations[observation.locationId].observations) {
                    currentRound.locations[observation.locationId].observations = [];
                }
                currentRound.locations[observation.locationId].observations.push(observation);
                
                console.log('ğŸ“ ObservaciÃ³n guardada en recorrido');
            }
            
            addDebugLog('ğŸ“ ObservaciÃ³n registrada correctamente', 'success');
            showAlert('âœ… ObservaciÃ³n guardada', 'ObservaciÃ³n registrada exitosamente' + (observation.hasPhoto ? ' con evidencia fotogrÃ¡fica' : ''));
        }
        
        // Cerrar modal
        closeDynamicModal();
        
        console.log('âœ… ObservaciÃ³n/incidencia guardada:', observation);
        
    } catch (error) {
        console.error('âŒ Error guardando observaciÃ³n:', error);
        addDebugLog(`âŒ Error guardando: ${error.message}`, 'error');
        showAlert('âŒ Error', 'Error guardando la observaciÃ³n. Intenta de nuevo.');
    }
}

        /**
 * Abrir modal de incidencias desde botÃ³n flotante
 */
function openIncidentModal() {
    console.log('ğŸš¨ Abriendo modal de incidencias...');
    addDebugLog('ğŸš¨ Modal de incidencias abierto', 'info');
    
    // Verificar que hay un recorrido activo
    if (!currentRound) {
        showAlert('âš ï¸ Sin recorrido activo', 'Inicia un recorrido antes de reportar incidencias');
        addDebugLog('âš ï¸ Intento de reportar sin recorrido activo', 'warning');
        return;
    }
    
    // Abrir modal en modo incidencia
    openObservationModal(null); // null significa modo incidencia
}


        function saveObservation() {
            const locationId = document.getElementById('observationLocation').value;
            const text = document.getElementById('observationText').value.trim();
            const incidentType = document.getElementById('incidentType').value;
            
            if (!locationId) {
                showAlert('âš ï¸ UbicaciÃ³n requerida', 'Selecciona una ubicaciÃ³n para continuar');
                return;
            }
            
            if (isIncidentMode && !incidentType) {
                showAlert('âš ï¸ Tipo requerido', 'Selecciona el tipo de incidencia');
                return;
            }
            
            const observation = {
                locationId,
                text: text || 'Sin observaciones adicionales',
                timestamp: new Date(),
                type: isIncidentMode ? 'incident' : 'observation',
                incidentType: incidentType || null,
                priority: incidentPriority || 'normal',
                plant: currentPlant,
                turn: currentTurn,
                photoUrl: capturedPhotoUrl || null,
                hasPhoto: !!capturedPhotoUrl
            };
            
            if (isIncidentMode) {
                const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
                incidents.push(observation);
                localStorage.setItem('incidents', JSON.stringify(incidents));
                
                checkCriticalIncident(observation);
                
                if (currentRound) {
                    if (!currentRound.incidents) currentRound.incidents = [];
                    currentRound.incidents.push(observation);
                }
                
                showAlert('âœ… Incidencia registrada', 'Incidencia reportada correctamente en el sistema');
            } else {
                if (currentRound && currentRound.locations[locationId]) {
                    currentRound.locations[locationId].observations.push(observation);
                    if (capturedPhotoUrl) {
                        currentRound.locations[locationId].photos.push(capturedPhotoUrl);
                    }
                }
                
                showAlert('âœ… ObservaciÃ³n guardada', 'ObservaciÃ³n registrada exitosamente');
            }
            
            closeModal();
        }
        // ===============================================
        // ğŸ“· FUNCIONES DE CÃMARA PARA EVIDENCIAS
        // ===============================================
        function startCamera() {
            navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment' } 
            }).then(stream => {
                cameraStream = stream;
                const video = document.getElementById('cameraPreview');
                video.srcObject = stream;
                video.style.display = 'block';
                
                document.getElementById('captureBtn').classList.remove('hidden');
            }).catch(error => {
                showAlert('âŒ Error de cÃ¡mara', 'No se pudo acceder a la cÃ¡mara para evidencias');
            });
        }


        function retakePhoto() {
            resetCamera();
            startCamera();
        }

        function resetCamera() {
            const video = document.getElementById('cameraPreview');
            const img = document.getElementById('capturedPhoto');
            
            video.style.display = 'none';
            img.style.display = 'none';
            
            document.getElementById('captureBtn').classList.add('hidden');
            document.getElementById('retakeBtn').classList.add('hidden');
            
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            
            capturedPhotoUrl = null;
        }

        // ===============================================
// ğŸ“ HISTORIAL DE RECORRIDOS CON FOTOS
// ===============================================
async function loadRoundsHistory() {
    try {
        console.log('ğŸ“‹ Cargando historial de recorridos con fotos...');
        
        // Obtener recorridos desde IndexedDB o localStorage
        let rounds = [];
        if (isIndexedDBAvailable() && roundsDB) {
            rounds = await roundsDB.getRounds(currentPlant);
        } else {
            const allRounds = JSON.parse(localStorage.getItem('rounds') || '[]');
            rounds = allRounds.filter(round => round.plant === currentPlant);
        }
        
        const historyEl = document.getElementById('roundsHistory');
        
        if (rounds.length === 0) {
            historyEl.innerHTML = '<p>ğŸ“‹ No hay recorridos registrados para esta planta</p>';
            return;
        }
        
        // Mostrar Ãºltimos 5 recorridos con informaciÃ³n de fotos
        const recentRounds = rounds.slice(-5).reverse();
        
        let historyHTML = '';
        
        for (const round of recentRounds) {
            const completedLocations = Object.keys(round.locations || {}).length;
            const totalLocations = plantLocations[round.plant].length;
            const percentage = Math.round((completedLocations / totalLocations) * 100);
            const incidentsCount = round.incidents ? round.incidents.length : 0;
            
            // Contar fotos en el recorrido
            const photoCount = await countPhotosInRound(round);
            
            historyHTML += `
                <div class="round-history-item" style="background: #f8f9fa; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #007bff;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <div>
                            <strong>${round.turn === 'diurno' ? 'ğŸŒ…' : 'ğŸŒ™'} ${new Date(round.startTime).toLocaleString('es-ES')}</strong>
                            <div style="margin-top: 5px;">
                                <small style="display: block;">
                                    ğŸ“ ${completedLocations}/${totalLocations} ubicaciones (${percentage}%)<br>
                                    ğŸš¨ ${incidentsCount} incidencias reportadas<br>
                                    ğŸ“¸ ${photoCount} fotos capturadas<br>
                                    â±ï¸ ${round.completed ? 'Completado' : 'En progreso'}
                                </small>
                            </div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 5px;">
                            ${photoCount > 0 ? `<button onclick="viewRoundPhotos('${round.id}')" class="btn" style="padding: 5px 10px; font-size: 0.8rem;">ğŸ“¸ Ver Fotos</button>` : ''}
                            <button onclick="viewRoundDetails('${round.id}')" class="btn btn-secondary" style="padding: 5px 10px; font-size: 0.8rem;">ğŸ“‹ Detalles</button>
                        </div>
                    </div>
                    ${await createRoundPhotoPreview(round)}
                </div>
            `;
        }
        
        historyEl.innerHTML = historyHTML;
        console.log('âœ… Historial de recorridos cargado con fotos');
        
    } catch (error) {
        console.error('âŒ Error cargando historial:', error);
        const historyEl = document.getElementById('roundsHistory');
        historyEl.innerHTML = '<p>âŒ Error cargando historial de recorridos</p>';
    }
}

/**
 * Contar fotos en un recorrido
 */
async function countPhotosInRound(round) {
    try {
        let photoCount = 0;
        
        // Contar fotos en ubicaciones
        if (round.locations) {
            for (const locationId in round.locations) {
                const location = round.locations[locationId];
                if (location.observations) {
                    photoCount += location.observations.filter(obs => obs.hasPhoto).length;
                }
            }
        }
        
        // Contar fotos en incidencias
        if (round.incidents) {
            photoCount += round.incidents.filter(inc => inc.hasPhoto).length;
        }
        
        return photoCount;
        
    } catch (error) {
        console.error('âŒ Error contando fotos:', error);
        return 0;
    }
}

/**
 * Crear preview de fotos del recorrido
 */
async function createRoundPhotoPreview(round) {
    try {
        const photos = await getRoundPhotos(round);
        
        if (photos.length === 0) {
            return '';
        }
        
        const maxPreviews = 3;
        const photosToShow = photos.slice(0, maxPreviews);
        const remainingCount = Math.max(0, photos.length - maxPreviews);
        
        let previewHTML = '<div style="display: flex; gap: 5px; margin-top: 10px; flex-wrap: wrap;">';
        
        for (let i = 0; i < photosToShow.length; i++) {
            const photo = photosToShow[i];
            previewHTML += `
                <div onclick="openPhotoViewer(await getRoundPhotos('${round.id}'), ${i})" 
                     style="width: 40px; height: 40px; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; cursor: pointer; background: #f5f5f5; display: flex; align-items: center; justify-content: center;">
                    <div id="preview_${round.id}_${i}" style="width: 100%; height: 100%; background: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"%23999\"><path d=\"M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z\"/></svg>') center/cover;">ğŸ“·</div>
                </div>
            `;
        }
        
        if (remainingCount > 0) {
            previewHTML += `
                <div onclick="viewRoundPhotos('${round.id}')"
                     style="width: 40px; height: 40px; border: 1px solid #007bff; border-radius: 4px; background: #e3f2fd; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 0.7rem; color: #1976d2; font-weight: bold;">
                    +${remainingCount}
                </div>
            `;
        }
        
        previewHTML += '</div>';
        
        return previewHTML;
        
    } catch (error) {
        console.error('âŒ Error creando preview de fotos:', error);
        return '';
    }
}

/**
 * Obtener todas las fotos de un recorrido
 */
async function getRoundPhotos(roundIdOrData) {
    try {
        let round;
        
        if (typeof roundIdOrData === 'string') {
            // Buscar recorrido por ID
            if (isIndexedDBAvailable() && roundsDB) {
                const rounds = await roundsDB.getRounds();
                round = rounds.find(r => r.id === roundIdOrData);
            } else {
                const allRounds = JSON.parse(localStorage.getItem('rounds') || '[]');
                round = allRounds.find(r => r.id === roundIdOrData);
            }
        } else {
            round = roundIdOrData;
        }
        
        if (!round) {
            console.error('âŒ Recorrido no encontrado');
            return [];
        }
        
        const photos = [];
        
        // Recopilar fotos de ubicaciones
        if (round.locations) {
            for (const locationId in round.locations) {
                const location = round.locations[locationId];
                if (location.observations) {
                    for (const obs of location.observations) {
                        if (obs.hasPhoto && obs.photoData) {
                            photos.push({
                                ...obs.photoData,
                                locationId: locationId,
                                observationType: 'location',
                                observationText: obs.text,
                                timestamp: obs.timestamp
                            });
                        }
                    }
                }
            }
        }
        
        // Recopilar fotos de incidencias
        if (round.incidents) {
            for (const incident of round.incidents) {
                if (incident.hasPhoto && incident.photoData) {
                    photos.push({
                        ...incident.photoData,
                        locationId: incident.locationId,
                        observationType: 'incident',
                        incidentType: incident.incidentType,
                        observationText: incident.text,
                        timestamp: incident.timestamp
                    });
                }
            }
        }
        
        // Ordenar por timestamp
        photos.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        console.log(`ğŸ“¸ ${photos.length} fotos encontradas en recorrido`);
        return photos;
        
    } catch (error) {
        console.error('âŒ Error obteniendo fotos del recorrido:', error);
        return [];
    }
}

/**
 * Ver todas las fotos de un recorrido
 */
async function viewRoundPhotos(roundId) {
    try {
        console.log('ğŸ“¸ Viendo fotos del recorrido:', roundId);
        
        const photos = await getRoundPhotos(roundId);
        
        if (photos.length === 0) {
            showAlert('ğŸ“¸ Sin fotos', 'Este recorrido no tiene fotos registradas');
            return;
        }
        
        // Abrir galerÃ­a con todas las fotos
        await openPhotoViewer(photos, 0);
        
    } catch (error) {
        console.error('âŒ Error viendo fotos del recorrido:', error);
        showAlert('âŒ Error', 'Error al cargar las fotos del recorrido');
    }
}

/**
 * Ver detalles completos de un recorrido
 */
async function viewRoundDetails(roundId) {
    try {
        console.log('ğŸ“‹ Viendo detalles del recorrido:', roundId);
        
        // Buscar recorrido
        let round;
        if (isIndexedDBAvailable() && roundsDB) {
            const rounds = await roundsDB.getRounds();
            round = rounds.find(r => r.id === roundId);
        } else {
            const allRounds = JSON.parse(localStorage.getItem('rounds') || '[]');
            round = allRounds.find(r => r.id === roundId);
        }
        
        if (!round) {
            showAlert('âŒ Error', 'Recorrido no encontrado');
            return;
        }
        
        // Crear contenido detallado
        let detailsHTML = `
            <h3>ğŸ“‹ Detalles del Recorrido</h3>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 10px 0;">
                <p><strong>ğŸ­ Planta:</strong> ${round.plant.toUpperCase()}</p>
                <p><strong>â° Turno:</strong> ${round.turn === 'diurno' ? 'ğŸŒ… Diurno' : 'ğŸŒ™ Nocturno'}</p>
                <p><strong>ğŸ“… Inicio:</strong> ${new Date(round.startTime).toLocaleString('es-ES')}</p>
                ${round.endTime ? `<p><strong>ğŸ Fin:</strong> ${new Date(round.endTime).toLocaleString('es-ES')}</p>` : ''}
                <p><strong>ğŸ“ Ubicaciones:</strong> ${Object.keys(round.locations || {}).length}</p>
                <p><strong>ğŸš¨ Incidencias:</strong> ${round.incidents ? round.incidents.length : 0}</p>
            </div>
        `;
        
        // Agregar ubicaciones visitadas
        if (round.locations && Object.keys(round.locations).length > 0) {
            detailsHTML += '<h4>ğŸ“ Ubicaciones Visitadas</h4>';
            for (const locationId in round.locations) {
                const location = round.locations[locationId];
                const locationName = plantLocations[round.plant]?.find(loc => loc.id === locationId)?.name || locationId;
                const obsCount = location.observations ? location.observations.length : 0;
                const photoCount = location.observations ? location.observations.filter(obs => obs.hasPhoto).length : 0;
                
                detailsHTML += `
                    <div style="background: white; padding: 10px; margin: 5px 0; border-radius: 5px; border-left: 3px solid #28a745;">
                        <p><strong>${locationName}</strong></p>
                        <small>ğŸ“ ${obsCount} observaciones | ğŸ“¸ ${photoCount} fotos</small>
                    </div>
                `;
            }
        }
        
        // Agregar incidencias
        if (round.incidents && round.incidents.length > 0) {
            detailsHTML += '<h4>ğŸš¨ Incidencias Reportadas</h4>';
            for (const incident of round.incidents) {
                const locationName = plantLocations[round.plant]?.find(loc => loc.id === incident.locationId)?.name || incident.locationId;
                
                detailsHTML += `
                    <div style="background: white; padding: 10px; margin: 5px 0; border-radius: 5px; border-left: 3px solid #dc3545;">
                        <p><strong>${incident.incidentType?.toUpperCase() || 'GENERAL'}</strong> - ${locationName}</p>
                        <p>${incident.text}</p>
                        <small>ğŸ“… ${new Date(incident.timestamp).toLocaleString('es-ES')} ${incident.hasPhoto ? '| ğŸ“¸ Con foto' : ''}</small>
                    </div>
                `;
            }
        }
        
        // Mostrar en modal personalizado
        showCustomModal('ğŸ“‹ Detalles del Recorrido', detailsHTML);
        
    } catch (error) {
        console.error('âŒ Error viendo detalles del recorrido:', error);
        showAlert('âŒ Error', 'Error al cargar los detalles del recorrido');
    }
}
        // ===============================================
        // ğŸ“Š DASHBOARD DE SUPERVISIÃ“N
        // ===============================================
        
        function loadIncidentsList(incidents) {
    const incidentsList = document.getElementById('incidentsList');
    
    if (!incidentsList) {
        console.error('âŒ Element incidentsList not found');
        return;
    }
    
    if (incidents.length === 0) {
        incidentsList.innerHTML = '<p>ğŸš¨ No hay incidencias reportadas</p>';
        return;
    }
    
    const incidentsHTML = incidents.slice(-10).reverse().map(incident => {
        const typeClass = `type-${incident.incidentType || 'general'}`;
        const plantName = incident.plant === 'matriz' ? 'MATRIZ' : 'EKZOTIKART';
        const turnIcon = incident.turn === 'diurno' ? 'ğŸŒ…' : 'ğŸŒ™';
        const location = plantLocations[incident.plant]?.find(loc => loc.id === incident.locationId);
        const locationName = location ? location.name : incident.locationId;
        
        return `
            <div class="incident-item">
                <div class="incident-header">
                    <span class="incident-type ${typeClass}">
                        ${incident.incidentType?.toUpperCase() || 'OBSERVACIÃ“N'}
                    </span>
                    <small>${turnIcon} ${plantName}</small>
                </div>
                <p><strong>ğŸ“ ${locationName}</strong></p>
                <p>${incident.text}</p>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                    <small>ğŸ• ${new Date(incident.timestamp).toLocaleString('es-ES')}</small>
                    ${incident.hasPhoto ? `
                        <button onclick="viewIncidentPhoto('${incident.id || Date.now()}')" 
                                class="btn" 
                                style="padding: 3px 8px; font-size: 0.8rem; background: #007bff; color: white;">
                            ğŸ“¸ Ver Foto
                        </button>
                    ` : ''}
                </div>
            </div>
        `;
    }).join('');
    
    incidentsList.innerHTML = incidentsHTML;
    console.log('ğŸ“Š Lista de incidencias cargada correctamente');
}


/**
 * Crear preview de foto para incidencia con soporte remoto
 */
async function createIncidentPhotoPreview(incident) {
    try {
        if (!incident.hasPhoto || !incident.photoData) {
            return '';
        }
        
        const previewId = `incident_preview_${incident.id || Date.now()}`;
        
        // Crear preview bÃ¡sico primero
        let previewHTML = `
            <div onclick="viewIncidentPhotoRemote('${incident.id || Date.now()}')" 
                 style="margin-top: 8px; cursor: pointer;">
                <div id="${previewId}" style="width: 60px; height: 60px; border: 2px solid #007bff; border-radius: 6px; background: #f0f8ff; display: flex; align-items: center; justify-content: center; transition: transform 0.2s ease; position: relative;">
                    <span style="font-size: 1.2rem;">ğŸ“·</span>
                    <div style="position: absolute; bottom: 2px; right: 2px; background: rgba(0,0,0,0.7); color: white; font-size: 0.6rem; padding: 1px 3px; border-radius: 2px;">
                        ${incident.photoData.stored === 'indexeddb' ? 'ğŸ’¾' : 'â˜ï¸'}
                    </div>
                </div>
                <small style="color: #007bff; font-weight: bold;">Click para ver</small>
            </div>
        `;
        
        // Intentar cargar preview real en background
        setTimeout(async () => {
            try {
                const photoUrl = await getPhotoUrl(incident.photoData);
                if (photoUrl) {
                    const previewElement = document.getElementById(previewId);
                    if (previewElement) {
                        previewElement.innerHTML = `
                            <img src="${photoUrl}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px;">
                            <div style="position: absolute; bottom: 2px; right: 2px; background: rgba(0,0,0,0.7); color: white; font-size: 0.6rem; padding: 1px 3px; border-radius: 2px;">
                                ${incident.photoData.stored === 'indexeddb' ? 'ğŸ’¾' : 'â˜ï¸'}
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('âŒ Error cargando preview real:', error);
            }
        }, 100);
        
        return previewHTML;
        
    } catch (error) {
        console.error('âŒ Error creando preview de incidencia:', error);
        return '';
    }
}

/**
 * Ver foto de incidencia con soporte remoto
 */
async function viewIncidentPhotoRemote(incidentId) {
    try {
        console.log('ğŸ“¸ Viendo foto de incidencia con soporte remoto:', incidentId);
        
        // Buscar incidencia
        let incident;
        if (isIndexedDBAvailable() && roundsDB) {
            const incidents = await roundsDB.getIncidents();
            incident = incidents.find(inc => inc.id === incidentId);
        } else {
            const allIncidents = JSON.parse(localStorage.getItem('incidents') || '[]');
            incident = allIncidents.find(inc => inc.id === incidentId);
        }
        
        // TambiÃ©n buscar en metadata cacheada
        if (!incident || !incident.photoData) {
            const cachedMetadata = getCachedPhotoMetadata(incidentId);
            if (cachedMetadata) {
                incident = {
                    id: incidentId,
                    hasPhoto: true,
                    photoData: cachedMetadata
                };
            }
        }
        
        if (!incident || !incident.hasPhoto || !incident.photoData) {
            showAlert('ğŸ“¸ Sin foto', 'Esta incidencia no tiene foto asociada o no se pudo cargar');
            return;
        }
        
        // Abrir visor con la foto de la incidencia
        await openPhotoViewer([incident.photoData], 0);
        
    } catch (error) {
        console.error('âŒ Error viendo foto de incidencia remota:', error);
        showAlert('âŒ Error', 'Error al cargar la foto de la incidencia');
    }
}

/**
 * Ver foto de una incidencia especÃ­fica
 */
async function viewIncidentPhoto(incidentId) {
    try {
        console.log('ğŸ“¸ Viendo foto de incidencia:', incidentId);
        
        // Buscar incidencia
        let incident;
        if (isIndexedDBAvailable() && roundsDB) {
            const incidents = await roundsDB.getIncidents();
            incident = incidents.find(inc => inc.id === incidentId);
        } else {
            const allIncidents = JSON.parse(localStorage.getItem('incidents') || '[]');
            incident = allIncidents.find(inc => inc.id === incidentId);
        }
        
        if (!incident || !incident.hasPhoto || !incident.photoData) {
            showAlert('ğŸ“¸ Sin foto', 'Esta incidencia no tiene foto asociada');
            return;
        }
        
        // Abrir visor con la foto de la incidencia
        await openPhotoViewer([incident.photoData], 0);
        
    } catch (error) {
        console.error('âŒ Error viendo foto de incidencia:', error);
        showAlert('âŒ Error', 'Error al cargar la foto de la incidencia');
    }
}

        function showDashboardTab(tab, event) {
    // Ocultar todas las pestaÃ±as
    document.querySelectorAll('.dashboard-content').forEach(el => {
        el.classList.add('hidden');
    });
    
    // Remover active de todos los botones
    document.querySelectorAll('.dashboard-tab').forEach(el => {
        el.classList.remove('active');
    });
    
    // Mostrar pestaÃ±a seleccionada
    const tabElement = document.getElementById(`${tab}Tab`);
    if (tabElement) {
        tabElement.classList.remove('hidden');
    } else {
        console.error(`âŒ Tab not found: ${tab}Tab`);
    }
    
    // Activar botÃ³n
    if (event && event.target) {
        event.target.classList.add('active');
    }
    
    // Cargar contenido especÃ­fico
    switch(tab) {
        case 'resumen':
            initResumenTab();
            break;
        case 'mapaCalor':
            initMapaCalorTab();
            break;
        case 'incidenciasUrgentes':
            initIncidenciasUrgentesTab();
            break;
        case 'analytics':
            initAnalyticsTab();
            break;
    }
}

        // ===============================================
        // ğŸ”” SISTEMA DE NOTIFICACIONES
        // ===============================================
        function enableNotifications() {
            if ('Notification' in window) {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        notificationsEnabled = true;
                        document.getElementById('notificationStatus').innerHTML = 
                            'ğŸ”” <span style="color: green;">Notificaciones Activas</span>';
                        showNotification('ğŸ‰ Sistema de Notificaciones', 'Notificaciones activadas correctamente');
                    } else {
                        showAlert('âŒ Permisos denegados', 'Los permisos de notificaciÃ³n fueron denegados');
                    }
                });
            } else {
                showAlert('âŒ No compatible', 'Tu navegador no soporta notificaciones');
            }
        }

        function showNotification(title, message) {
            if (!notificationsEnabled) return;

            const notification = new Notification(title, {
                body: message,
                icon: 'ğŸš¨'
            });

            if (reminderConfig.soundEnabled) {
                playSuccessSound();
            }

            setTimeout(() => notification.close(), 5000);
        }

        function configureReminders() {
            document.getElementById('remindersModal').style.display = 'block';
        }

        function closeRemindersModal() {
            document.getElementById('remindersModal').style.display = 'none';
        }

        function startReminders() {
            const frequency = parseInt(document.getElementById('reminderFrequency').value);
            const plant = document.getElementById('reminderPlant').value;
            const soundEnabled = document.getElementById('soundAlerts').checked;

            reminderConfig = { frequency, plant, soundEnabled };

            const baseMs = frequency * 60 * 60 * 1000;
            const variation = baseMs * 0.25;
            const randomMs = baseMs + (Math.random() - 0.5) * 2 * variation;

            reminderInterval = setTimeout(() => {
                sendRandomReminder();
                startReminders();
            }, randomMs);

            const nextTime = new Date(Date.now() + randomMs).toLocaleTimeString('es-ES');
            document.getElementById('remindersSection').style.display = 'block';
            document.getElementById('remindersInfo').innerHTML = `
                <p><strong>â° ConfiguraciÃ³n:</strong> Cada ~${frequency} hora(s)</p>
                <p><strong>ğŸ­ Planta:</strong> ${plant === 'both' ? 'Ambas (Aleatorio)' : plant.toUpperCase()}</p>
                <p><strong>ğŸ”” PrÃ³ximo:</strong> ~${nextTime} (Â±variaciÃ³n)</p>
            `;

            closeRemindersModal();
            showNotification('âœ… Recordatorios Activados', `Configurados cada ~${frequency} hora(s)`);
        }

        function sendRandomReminder() {
            const messages = [
                'ğŸ•µï¸ InspecciÃ³n Aleatoria',
                'âš¡ Ronda Flash', 
                'ğŸ” VerificaciÃ³n Inesperada',
                'ğŸ² Recorrido Sorpresa',
                'ğŸ‘ï¸ Control de Vigilancia',
                'ğŸš¨ RevisiÃ³n Urgente'
            ];

            const plants = reminderConfig.plant === 'both' ? ['matriz', 'ekzotikart'] : [reminderConfig.plant];
            const selectedPlant = plants[Math.floor(Math.random() * plants.length)];
            const message = messages[Math.floor(Math.random() * messages.length)];
            
            showNotification(
                `${message} - ${selectedPlant.toUpperCase()}`,
                'Realizar recorrido inmediato en esta planta'
            );
        }

        function stopReminders() {
            if (reminderInterval) {
                clearTimeout(reminderInterval);
                reminderInterval = null;
            }
            document.getElementById('remindersSection').style.display = 'none';
            showNotification('ğŸ›‘ Recordatorios Desactivados', 'Sistema de recordatorios detenido');
        }

        // ===============================================
        // ğŸ“Š ANÃLISIS SIMPLIFICADOS
        // ===============================================
        function createSimpleAnalytics() {
            createTextTrends();
            createTextComparison();
            createSimpleHeatMap();
        }

        function createTextTrends() {
    const trendsContainer = document.getElementById('trendsChart');
    
    // Si no existe el contenedor, crearlo o usar uno alternativo
    if (!trendsContainer) {
        const timePatterns = document.getElementById('timePatterns');
        if (timePatterns) {
            // Usar el contenedor de patrones temporales
            renderTrendsInTimePatterns();
            return;
        } else {
            console.log('âš ï¸ No hay contenedor para trends chart');
            return;
        }
    }
    
    // Resto del cÃ³digo original...
            
            const last7Days = [];
            const incidentCounts = [];
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                const dateStr = date.toISOString().split('T')[0];
                last7Days.push(date.toLocaleDateString('es-ES', { weekday: 'short', day: 'numeric' }));
                
                const dayIncidents = incidents.filter(inc => 
                    new Date(inc.timestamp).toISOString().split('T')[0] === dateStr
                ).length;
                
                incidentCounts.push(dayIncidents);
            }

            let chartHTML = '<div style="background: white; padding: 20px; border-radius: 10px;">';
            chartHTML += '<h4>ğŸ“ˆ Incidencias por DÃ­a (Ãšltima Semana)</h4>';
            
            for (let i = 0; i < last7Days.length; i++) {
                const width = incidentCounts[i] > 0 ? (incidentCounts[i] * 20) + 'px' : '5px';
                chartHTML += `
                    <div style="display: flex; align-items: center; margin: 5px 0;">
                        <span style="width: 60px; font-size: 0.9rem;">${last7Days[i]}</span>
                        <div style="background: #ff6384; height: 25px; width: ${width}; margin: 0 10px; border-radius: 3px;"></div>
                        <span>${incidentCounts[i]}</span>
                    </div>
                `;
            }
            chartHTML += '</div>';
            trendsContainer.innerHTML = chartHTML;
        }


        function renderTrendsInTimePatterns() {
    const container = document.getElementById('timePatterns');
    if (!container) return;
    
    const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
    const last7Days = [];
    const incidentCounts = [];
    
    for (let i = 6; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        last7Days.push(date.toLocaleDateString('es-ES', { weekday: 'short', day: 'numeric' }));
        
        const dayIncidents = incidents.filter(inc => 
            new Date(inc.timestamp).toISOString().split('T')[0] === dateStr
        ).length;
        
        incidentCounts.push(dayIncidents);
    }

    let chartHTML = '<div style="font-size: 0.9rem;">';
    chartHTML += '<strong>ğŸ“ˆ Incidencias por DÃ­a (Ãšltima Semana)</strong><br><br>';
    
    for (let i = 0; i < last7Days.length; i++) {
        const width = incidentCounts[i] > 0 ? (incidentCounts[i] * 15) + 'px' : '3px';
        chartHTML += `
            <div style="display: flex; align-items: center; margin: 8px 0; font-size: 0.8rem;">
                <span style="width: 45px;">${last7Days[i]}</span>
                <div style="background: #4facfe; height: 15px; width: ${width}; margin: 0 8px; border-radius: 2px;"></div>
                <span>${incidentCounts[i]}</span>
            </div>
        `;
    }
    chartHTML += '</div>';
    container.innerHTML = chartHTML;
}


        function createTextComparison() {
    const rounds = JSON.parse(localStorage.getItem('rounds') || '[]');
    const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
    
    // Buscar contenedor alternativo si no existe plantsChart
    let plantsContainer = document.getElementById('plantsChart');
    if (!plantsContainer) {
        plantsContainer = document.getElementById('criticalLocations');
        if (!plantsContainer) {
            console.log('âš ï¸ No hay contenedor para comparativo de plantas');
            return;
        }
    }
    
    const matrizRounds = rounds.filter(r => r.plant === 'matriz').length;
    const ekzotikRounds = rounds.filter(r => r.plant === 'ekzotikart').length;
    const matrizIncidents = incidents.filter(i => i.plant === 'matriz').length;
    const ekzotikIncidents = incidents.filter(i => i.plant === 'ekzotikart').length;

    const maxValue = Math.max(matrizRounds, ekzotikRounds, matrizIncidents, ekzotikIncidents, 1);

    let chartHTML = '<div style="font-size: 0.9rem;">';
    chartHTML += '<strong>ğŸ­ Comparativo entre Plantas</strong><br><br>';
    
    chartHTML += '<div style="margin: 15px 0;"><strong>ğŸ¢ MATRIZ</strong></div>';
    chartHTML += `
        <div style="display: flex; align-items: center; margin: 5px 0; font-size: 0.8rem;">
            <span style="width: 70px;">Recorridos:</span>
            <div style="background: #36a2eb; height: 15px; width: ${(matrizRounds / maxValue * 100)}px; margin: 0 8px; border-radius: 2px; min-width: 3px;"></div>
            <span>${matrizRounds}</span>
        </div>
        <div style="display: flex; align-items: center; margin: 5px 0; font-size: 0.8rem;">
            <span style="width: 70px;">Incidencias:</span>
            <div style="background: #ffce56; height: 15px; width: ${(matrizIncidents / maxValue * 100)}px; margin: 0 8px; border-radius: 2px; min-width: 3px;"></div>
            <span>${matrizIncidents}</span>
        </div>
    `;
    
    chartHTML += '<div style="margin: 15px 0;"><strong>ğŸ­ EKZOTIKART</strong></div>';
    chartHTML += `
        <div style="display: flex; align-items: center; margin: 5px 0; font-size: 0.8rem;">
            <span style="width: 70px;">Recorridos:</span>
            <div style="background: #36a2eb; height: 15px; width: ${(ekzotikRounds / maxValue * 100)}px; margin: 0 8px; border-radius: 2px; min-width: 3px;"></div>
            <span>${ekzotikRounds}</span>
        </div>
        <div style="display: flex; align-items: center; margin: 5px 0; font-size: 0.8rem;">
            <span style="width: 70px;">Incidencias:</span>
            <div style="background: #ffce56; height: 15px; width: ${(ekzotikIncidents / maxValue * 100)}px; margin: 0 8px; border-radius: 2px; min-width: 3px;"></div>
            <span>${ekzotikIncidents}</span>
        </div>
    `;
    
    chartHTML += '</div>';
    plantsContainer.innerHTML = chartHTML;
}

        function createSimpleHeatMap() {
    const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
    let heatMapEl = document.getElementById('heatMap');
    
    // Si no existe, usar contenedor alternativo
    if (!heatMapEl) {
        heatMapEl = document.getElementById('autoRecommendations');
        if (!heatMapEl) {
            console.log('âš ï¸ No hay contenedor para heat map');
            return;
        }
    }
    
    const locationCounts = {};
    const allLocations = [...plantLocations.matriz, ...plantLocations.ekzotikart];
    
    allLocations.forEach(loc => {
        locationCounts[loc.id] = incidents.filter(inc => inc.locationId === loc.id).length;
    });

    const maxCount = Math.max(...Object.values(locationCounts), 1);
    
    let heatHTML = '<div style="font-size: 0.9rem;"><strong>ğŸ”¥ Ubicaciones con mÃ¡s incidencias</strong><br><br>';
    
    const sortedLocations = Object.entries(locationCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5); // Solo top 5
    
    sortedLocations.forEach(([locationId, count]) => {
        const location = allLocations.find(loc => loc.id === locationId);
        const intensity = count / maxCount;
        const bgColor = count > 2 ? '#ff4444' : count > 0 ? '#ffaa44' : '#44ff44';
        
        heatHTML += `
            <div style="
                background: ${bgColor};
                color: white;
                border-radius: 5px;
                padding: 8px;
                margin: 5px 0;
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-size: 0.8rem;
            ">
                <span><strong>${location ? location.name : locationId}</strong></span>
                <span style="
                    background: rgba(255,255,255,0.3);
                    padding: 2px 6px;
                    border-radius: 10px;
                ">${count}</span>
            </div>
        `;
    });
    
    heatHTML += '</div>';
    heatMapEl.innerHTML = heatHTML;
}

        // ===============================================
        // ğŸ”Š SONIDOS
        // ===============================================
        function playSuccessSound() {
            if (!reminderConfig.soundEnabled) return;
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                // Silenciar errores de audio
            }
        }
        // ===============================================
        // ğŸ“¤ FUNCIONES DE EXPORTACIÃ“N
        // ===============================================
        function exportData() {
            const rounds = JSON.parse(localStorage.getItem('rounds') || '[]');
            const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
            
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Tipo,Fecha,Hora,Planta,Turno,Ubicacion,Descripcion,Observaciones\n";
            
            rounds.forEach(round => {
                Object.keys(round.locations).forEach(locationId => {
                    const location = round.locations[locationId];
                    const fecha = new Date(round.startTime).toLocaleDateString('es-ES');
                    const hora = new Date(round.startTime).toLocaleTimeString('es-ES');
                    const observaciones = location.observations.map(obs => obs.text).join('; ') || 'Sin observaciones';
                    
                    csvContent += `Recorrido,"${fecha}","${hora}","${round.plant}","${round.turn}","${locationId}","Ubicacion visitada","${observaciones}"\n`;
                });
            });
            
            incidents.forEach(incident => {
                const fecha = new Date(incident.timestamp).toLocaleDateString('es-ES');
                const hora = new Date(incident.timestamp).toLocaleTimeString('es-ES');
                
                csvContent += `Incidencia,"${fecha}","${hora}","${incident.plant}","${incident.turn}","${incident.locationId}","${incident.incidentType || 'general'}","${incident.text}"\n`;
            });
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `control_rondas_${new Date().toISOString().split('T')[0]}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showAlert('âœ… ExportaciÃ³n completa', 'Reporte exportado exitosamente');
        }

        function exportIncidents() {
            const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
            
            if (incidents.length === 0) {
                showAlert('âš ï¸ Sin datos', 'No hay incidencias para exportar');
                return;
            }
            
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Fecha,Hora,Planta,Turno,Ubicacion,Tipo,Descripcion,Foto\n";
            
            incidents.forEach(incident => {
                const fecha = new Date(incident.timestamp).toLocaleDateString('es-ES');
                const hora = new Date(incident.timestamp).toLocaleTimeString('es-ES');
                
                csvContent += `"${fecha}","${hora}","${incident.plant}","${incident.turn}","${incident.locationId}","${incident.incidentType || 'general'}","${incident.text}","${incident.hasPhoto ? 'SÃ­' : 'No'}"\n`;
            });
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `incidencias_${new Date().toISOString().split('T')[0]}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showAlert('âœ… Incidencias exportadas', 'Incidencias exportadas exitosamente');
        }

        function exportAnalytics() {
            const rounds = JSON.parse(localStorage.getItem('rounds') || '[]');
            const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
            
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Tipo_Analisis,Planta,Ubicacion,Fecha,Cantidad,Descripcion\n";
            
            const allLocations = [...plantLocations.matriz, ...plantLocations.ekzotikart];
            allLocations.forEach(location => {
                const locationIncidents = incidents.filter(inc => inc.locationId === location.id);
                const locationRounds = rounds.filter(round => 
                    round.locations && round.locations[location.id]
                );
                
                csvContent += `Ubicacion_Incidencias,"${location.id.includes('MTZ') ? 'matriz' : 'ekzotikart'}","${location.name}","${new Date().toLocaleDateString('es-ES')}","${locationIncidents.length}","Incidencias en ubicacion"\n`;
                csvContent += `Ubicacion_Visitas,"${location.id.includes('MTZ') ? 'matriz' : 'ekzotikart'}","${location.name}","${new Date().toLocaleDateString('es-ES')}","${locationRounds.length}","Visitas a ubicacion"\n`;
            });
            
            const incidentTypes = ['personas', 'seguridad', 'mantenimiento', 'materiales'];
            incidentTypes.forEach(type => {
                const typeIncidents = incidents.filter(inc => inc.incidentType === type);
                csvContent += `Tipo_Incidencia,"Ambas","${type}","${new Date().toLocaleDateString('es-ES')}","${typeIncidents.length}","Incidencias tipo ${type}"\n`;
            });
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `analisis_rondas_${new Date().toISOString().split('T')[0]}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showAlert('âœ… AnÃ¡lisis exportado', 'AnÃ¡lisis exportado exitosamente');
        }

        // ===============================================
        // ğŸš¨ DETECCIÃ“N DE INCIDENCIAS CRÃTICAS
        // ===============================================
        function checkCriticalIncident(incident) {
            if (!notificationsEnabled) return;
            
            const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
            
            if (incident.incidentType === 'seguridad') {
                showNotification(
                    'ğŸš¨ INCIDENCIA CRÃTICA DE SEGURIDAD',
                    `UbicaciÃ³n: ${incident.locationId} - ${incident.text}`
                );
            }
            
            const sameLocationIncidents = incidents.filter(inc => 
                inc.locationId === incident.locationId
            ).length;
            
            if (sameLocationIncidents >= 3) {
                showNotification(
                    'âš ï¸ PATRÃ“N DE RIESGO DETECTADO',
                    `${sameLocationIncidents} incidencias en ${incident.locationId}`
                );
            }
        }

        // ===============================================
        // ğŸ”„ FUNCIONES ADICIONALES DE MEJORA
        // ===============================================
        
        // NUEVO: ValidaciÃ³n de conectividad
        function checkConnectivity() {
            if (navigator.onLine) {
                document.getElementById('connectionStatus').innerHTML = 'ğŸ”¥ Sistema completo activo';
                document.getElementById('connectionStatus').className = 'connection-status status-active';
            } else {
                document.getElementById('connectionStatus').innerHTML = 'âš ï¸ Modo offline - Datos se sincronizarÃ¡n al conectarse';
                document.getElementById('connectionStatus').className = 'connection-status status-offline';
            }
        }

        // NUEVO: FunciÃ³n de respaldo automÃ¡tico
        function autoBackup() {
            const data = {
                rounds: JSON.parse(localStorage.getItem('rounds') || '[]'),
                incidents: JSON.parse(localStorage.getItem('incidents') || '[]'),
                timestamp: new Date().toISOString(),
                version: '2.0'
            };
            
            const backup = JSON.stringify(data);
            localStorage.setItem('backup_' + Date.now(), backup);
            
            console.log('ğŸ’¾ Respaldo automÃ¡tico creado');
        }

        // NUEVO: ValidaciÃ³n de integridad de datos
        function validateDataIntegrity() {
            try {
                const rounds = JSON.parse(localStorage.getItem('rounds') || '[]');
                const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
                
                let isValid = true;
                let errors = [];
                
                // Validar estructura de recorridos
                rounds.forEach((round, index) => {
                    if (!round.id || !round.plant || !round.startTime) {
                        isValid = false;
                        errors.push(`Recorrido ${index}: Datos incompletos`);
                    }
                });
                
                // Validar estructura de incidencias
                incidents.forEach((incident, index) => {
                    if (!incident.locationId || !incident.timestamp) {
                        isValid = false;
                        errors.push(`Incidencia ${index}: Datos incompletos`);
                    }
                });
                
                if (!isValid) {
                    console.warn('âš ï¸ Problemas de integridad detectados:', errors);
                    return false;
                }
                
                console.log('âœ… Integridad de datos verificada');
                return true;
                
            } catch (error) {
                console.error('âŒ Error validando integridad:', error);
                return false;
            }
        }

        // NUEVO: Limpieza de datos antiguos
        function cleanOldData() {
            const MAX_ROUNDS = 100;
            const MAX_INCIDENTS = 200;
            
            try {
                let rounds = JSON.parse(localStorage.getItem('rounds') || '[]');
                let incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
                
                if (rounds.length > MAX_ROUNDS) {
                    rounds = rounds.slice(-MAX_ROUNDS);
                    localStorage.setItem('rounds', JSON.stringify(rounds));
                    console.log(`ğŸ§¹ Limpieza: Mantenidos Ãºltimos ${MAX_ROUNDS} recorridos`);
                }
                
                if (incidents.length > MAX_INCIDENTS) {
                    incidents = incidents.slice(-MAX_INCIDENTS);
                    localStorage.setItem('incidents', JSON.stringify(incidents));
                    console.log(`ğŸ§¹ Limpieza: Mantenidas Ãºltimas ${MAX_INCIDENTS} incidencias`);
                }
                
            } catch (error) {
                console.error('âŒ Error en limpieza de datos:', error);
            }
        }

        // NUEVO: Sistema de logs
        function logAction(action, details = '') {
            const logEntry = {
                timestamp: new Date().toISOString(),
                action: action,
                details: details,
                plant: currentPlant || 'unknown',
                turn: currentTurn || 'unknown'
            };
            
            const logs = JSON.parse(localStorage.getItem('system_logs') || '[]');
            logs.push(logEntry);
            
            // Mantener solo Ãºltimos 50 logs
            if (logs.length > 50) {
                logs.splice(0, logs.length - 50);
            }
            
            localStorage.setItem('system_logs', JSON.stringify(logs));
        }

        // ===============================================
// ğŸ–¼ï¸ SISTEMA DE VISUALIZACIÃ“N Y GALERÃA DE FOTOS
// ===============================================

// Variables globales para el visor
let currentPhotoViewer = {
    photos: [],
    currentIndex: 0,
    zoomLevel: 1,
    isZoomed: false
};

/**
 * Verificar e inicializar elementos del visor de fotos - NUEVA FUNCIÃ“N
 * Agregar esta funciÃ³n ANTES de openPhotoViewer
 */
function initPhotoViewerElements() {
    try {
        console.log('ğŸ” Verificando elementos del visor de fotos...');
        
        // Lista de elementos crÃ­ticos
        const criticalElements = [
            'photoViewerModal',
            'photoContainer', 
            'photoViewerImage',
            'photoLoader',
            'photoInfo',
            'galleryNavigation',
            'prevPhotoBtn',
            'nextPhotoBtn',
            'photoCounter'
        ];
        
        const missingElements = [];
        const foundElements = {};
        
        // Verificar cada elemento
        criticalElements.forEach(elementId => {
            const element = document.getElementById(elementId);
            if (element) {
                foundElements[elementId] = element;
                console.log(`âœ… Elemento encontrado: ${elementId}`);
            } else {
                missingElements.push(elementId);
                console.warn(`âš ï¸ Elemento faltante: ${elementId}`);
            }
        });
        
        // Crear elementos faltantes si es necesario
        if (missingElements.length > 0) {
            console.log(`ğŸ”§ Creando ${missingElements.length} elementos faltantes...`);
            createMissingViewerElements(missingElements);
        }
        
        console.log('âœ… InicializaciÃ³n de elementos del visor completada');
        return {
            success: true,
            foundElements: Object.keys(foundElements).length,
            createdElements: missingElements.length
        };
        
    } catch (error) {
        console.error('âŒ Error inicializando elementos del visor:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Crear elementos faltantes del visor - FUNCIÃ“N AUXILIAR
 * Agregar esta funciÃ³n DESPUÃ‰S de initPhotoViewerElements
 */
function createMissingViewerElements(missingElements) {
    try {
        // Solo crear si el modal principal existe
        const modal = document.getElementById('photoViewerModal');
        if (!modal) {
            console.error('âŒ Modal principal no existe, no se pueden crear elementos');
            return;
        }
        
        // Verificar contenedor principal
        let container = document.getElementById('photoViewerContent');
        if (!container) {
            container = modal.querySelector('.modal-content');
        }
        
        if (!container) {
            console.error('âŒ No se encontrÃ³ contenedor para crear elementos');
            return;
        }
        
        missingElements.forEach(elementId => {
            switch(elementId) {
                case 'photoContainer':
                    const photoContainer = document.createElement('div');
                    photoContainer.id = 'photoContainer';
                    photoContainer.style.cssText = 'position: relative; display: inline-block; max-width: 100%; max-height: 70vh; overflow: hidden; border-radius: 10px;';
                    photoContainer.innerHTML = `
                        <img id="photoViewerImage" style="max-width: 100%; max-height: 70vh; object-fit: contain; cursor: zoom-in;">
                        <div id="photoLoader" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none;">
                            <div class="loading-spinner"></div>
                            <p>ğŸ“¸ Cargando foto...</p>
                        </div>
                    `;
                    container.appendChild(photoContainer);
                    console.log('âœ… photoContainer creado');
                    break;
                    
                case 'photoInfo':
                    const photoInfo = document.createElement('div');
                    photoInfo.id = 'photoInfo';
                    photoInfo.style.cssText = 'background: #f8f9fa; padding: 10px; border-radius: 5px; margin: 10px 0; display: none;';
                    photoInfo.innerHTML = `
                        <small>
                            ğŸ“… <span id="photoDate">-</span> | 
                            ğŸ“ <span id="photoSize">-</span> | 
                            ğŸ­ <span id="photoPlant">-</span> | 
                            ğŸ“ <span id="photoLocation">-</span>
                        </small>
                    `;
                    container.appendChild(photoInfo);
                    console.log('âœ… photoInfo creado');
                    break;
                    
                case 'galleryNavigation':
                    const galleryNav = document.createElement('div');
                    galleryNav.id = 'galleryNavigation';
                    galleryNav.style.cssText = 'margin-top: 15px; display: none; text-align: center;';
                    galleryNav.innerHTML = `
                        <button id="prevPhotoBtn" onclick="navigateGallery(-1)" class="btn btn-secondary" style="margin: 0 5px;">â† Anterior</button>
                        <span id="photoCounter" style="margin: 0 15px; font-weight: bold;">1 / 1</span>
                        <button id="nextPhotoBtn" onclick="navigateGallery(1)" class="btn btn-secondary" style="margin: 0 5px;">Siguiente â†’</button>
                    `;
                    container.appendChild(galleryNav);
                    console.log('âœ… galleryNavigation creado');
                    break;
            }
        });
        
    } catch (error) {
        console.error('âŒ Error creando elementos faltantes:', error);
    }
}

/**
 * Abrir visor de fotos con soporte remoto - VERSIÃ“N MEJORADA
 * REEMPLAZAR la funciÃ³n openPhotoViewer existente CON ESTA
 */
async function openPhotoViewer(photoData, startIndex = 0) {
    try {
        console.log('ğŸ–¼ï¸ Abriendo visor de fotos optimizado...');
        addDebugLog('ğŸ–¼ï¸ Visor de fotos iniciado', 'info');
        
        // Validar datos de entrada con optimizaciÃ³n
        if (!photoData) {
            throw new Error('No se proporcionaron datos de fotos');
        }
        
        // Normalizar datos: convertir objeto Ãºnico a array (OPTIMIZADO)
        let photosArray = [];
        if (Array.isArray(photoData)) {
            // Filtrar elementos nulos y duplicados por ID
            const seenIds = new Set();
            photosArray = photoData.filter(photo => {
                if (!photo || !photo.id) return false;
                if (seenIds.has(photo.id)) return false;
                seenIds.add(photo.id);
                return true;
            });
        } else {
            photosArray = [photoData];
        }
        
        if (photosArray.length === 0) {
            throw new Error('No hay fotos vÃ¡lidas para mostrar');
        }
        
        console.log(`ğŸ“Š Preparando visor con ${photosArray.length} foto(s)`);
        
        // Inicializar elementos del visor
        const elementsInit = initPhotoViewerElements();
        if (!elementsInit.success) {
            throw new Error(`Error inicializando elementos: ${elementsInit.error}`);
        }
        
        console.log(`ğŸ”§ Elementos del visor: ${elementsInit.foundElements} encontrados, ${elementsInit.createdElements} creados`);
        
        // Configurar datos del visor
        currentPhotoViewer.photos = photosArray;
        currentPhotoViewer.currentIndex = Math.max(0, Math.min(startIndex, photosArray.length - 1));
        currentPhotoViewer.zoomLevel = 1;
        currentPhotoViewer.isZoomed = false;
        
        console.log(`ğŸ“‹ Configurado visor: Ã­ndice ${currentPhotoViewer.currentIndex}/${photosArray.length - 1}`);
        
        // Mostrar modal
        const modal = document.getElementById('photoViewerModal');
        if (!modal) {
            throw new Error('Modal del visor no encontrado');
        }
        
        modal.style.display = 'block';
        console.log('ğŸ“± Modal del visor mostrado');
        
        // Configurar navegaciÃ³n
        const navDiv = document.getElementById('galleryNavigation');
        if (navDiv) {
            if (currentPhotoViewer.photos.length > 1) {
                navDiv.style.display = 'block';
                updateGalleryNavigation();
                console.log('ğŸ§­ NavegaciÃ³n de galerÃ­a activada');
            } else {
                navDiv.style.display = 'none';
                console.log('ğŸ§­ NavegaciÃ³n de galerÃ­a ocultada (solo 1 foto)');
            }
        }
        
        // Reset zoom
        resetPhotoZoom();
        
        // Cargar foto actual
        console.log('ğŸ”„ Iniciando carga de foto actual...');
        await loadCurrentPhotoWithRemoteSupport();
        
        console.log('âœ… Visor de fotos abierto exitosamente');
        addDebugLog(`âœ… Visor abierto: ${photosArray.length} fotos`, 'success');
        
    } catch (error) {
        console.error('âŒ Error abriendo visor de fotos:', error);
        addDebugLog(`âŒ Error visor: ${error.message}`, 'error');
        
        // Intentar cerrar modal si hay error
        const modal = document.getElementById('photoViewerModal');
        if (modal) {
            modal.style.display = 'none';
        }
        
        // Mostrar error al usuario
        showAlert('âŒ Error del Visor', `No se pudo abrir el visor de fotos:\n\n${error.message}\n\nVerifica tu conexiÃ³n y vuelve a intentar.`);
        
        throw error;
    }
}

/**
 * Actualizar navegaciÃ³n de galerÃ­a - FUNCIÃ“N MEJORADA
 * REEMPLAZAR la funciÃ³n updateGalleryNavigation existente CON ESTA
 */
function updateGalleryNavigation() {
    try {
        const prevBtn = document.getElementById('prevPhotoBtn');
        const nextBtn = document.getElementById('nextPhotoBtn');
        const counter = document.getElementById('photoCounter');
        
        if (!prevBtn || !nextBtn || !counter) {
            console.warn('âš ï¸ Elementos de navegaciÃ³n no encontrados');
            return;
        }
        
        const current = currentPhotoViewer.currentIndex + 1;
        const total = currentPhotoViewer.photos.length;
        
        // Actualizar estado de botones
        const isFirst = currentPhotoViewer.currentIndex === 0;
        const isLast = currentPhotoViewer.currentIndex === total - 1;
        
        prevBtn.disabled = isFirst;
        nextBtn.disabled = isLast;
        
        // Actualizar estilos visuales
        prevBtn.style.opacity = isFirst ? '0.5' : '1';
        nextBtn.style.opacity = isLast ? '0.5' : '1';
        prevBtn.style.cursor = isFirst ? 'not-allowed' : 'pointer';
        nextBtn.style.cursor = isLast ? 'not-allowed' : 'pointer';
        
        // Actualizar contador
        counter.textContent = `${current} / ${total}`;
        
        console.log(`ğŸ§­ NavegaciÃ³n actualizada: ${current}/${total}`);
        
    } catch (error) {
        console.error('âŒ Error actualizando navegaciÃ³n:', error);
    }
}

/**
 * Cargar foto actual con soporte remoto - VERSIÃ“N CORREGIDA
 * REEMPLAZAR la funciÃ³n loadCurrentPhotoWithRemoteSupport existente CON ESTA
 */
async function loadCurrentPhotoWithRemoteSupport() {
    try {
        const photoData = currentPhotoViewer.photos[currentPhotoViewer.currentIndex];
        if (!photoData) {
            throw new Error('No hay datos de foto para mostrar');
        }
        
        console.log('ğŸ“¸ Cargando foto con soporte remoto:', photoData.id || 'sin ID');
        
        // Mostrar indicador de carga
        showPhotoLoader(true);
        
        // Verificar que el elemento de imagen existe
        const img = document.getElementById('photoViewerImage');
        if (!img) {
            console.error('âŒ Elemento photoViewerImage no encontrado');
            throw new Error('Elemento de imagen no encontrado en el DOM');
        }
        
        // Obtener URL de la foto (usando la funciÃ³n mejorada)
        let photoUrl = null;
        
        try {
            photoUrl = await getPhotoUrl(photoData);
        } catch (urlError) {
            console.error('âŒ Error obteniendo URL:', urlError);
            throw new Error(`Error obteniendo URL de foto: ${urlError.message}`);
        }
        
        if (!photoUrl) {
            throw new Error('No se pudo obtener la URL de la foto');
        }
        
        console.log('ğŸ“‹ URL obtenida para carga:', photoUrl.substring(0, 50) + '...');
        
        // Configurar eventos de carga de imagen
        return new Promise((resolve, reject) => {
            // Timeout para evitar cuelgues
            const timeoutId = setTimeout(() => {
                console.error('âŒ Timeout cargando imagen');
                img.onload = null;
                img.onerror = null;
                reject(new Error('Timeout cargando imagen (30 segundos)'));
            }, 30000); // 30 segundos
            
            img.onload = () => {
                clearTimeout(timeoutId);
                img.onload = null;
                img.onerror = null;
                
                console.log('âœ… Imagen cargada exitosamente');
                
                // Ocultar indicador de carga
                showPhotoLoader(false);
                
                // Actualizar informaciÃ³n de la foto
                updatePhotoInfo(photoData);
                
                // Mostrar controles de zoom
                showZoomControls(true);
                
                console.log('âœ… Foto cargada exitosamente (local/remota)');
                addDebugLog('âœ… Foto cargada en visor', 'success');
                
                resolve();
            };
            
            img.onerror = (errorEvent) => {
                clearTimeout(timeoutId);
                img.onload = null;
                img.onerror = null;
                
                console.error('âŒ Error cargando imagen:', errorEvent);
                
                // Intentar limpiar URL si es blob
                if (photoUrl && photoUrl.startsWith('blob:')) {
                    console.log('ğŸ—‘ï¸ Limpiando URL blob problemÃ¡tica');
                    memoryManager.revokeObjectURL(photoUrl);
                    
                    // Limpiar referencia en photoData
                    if (photoData.url === photoUrl) {
                        photoData.url = null;
                    }
                }
                
                reject(new Error('Error cargando imagen en el navegador'));
            };
            
            // Intentar cargar la imagen
            try {
                img.src = photoUrl;
                console.log('ğŸ”„ Iniciando carga de imagen...');
            } catch (srcError) {
                clearTimeout(timeoutId);
                console.error('âŒ Error asignando src:', srcError);
                reject(new Error(`Error asignando URL a imagen: ${srcError.message}`));
            }
        });
        
    } catch (error) {
        console.error('âŒ Error cargando foto con soporte remoto:', error);
        addDebugLog(`âŒ Error cargando foto: ${error.message}`, 'error');
        
        // Ocultar indicador de carga
        showPhotoLoader(false);
        
        // Mostrar error en la UI
        showPhotoError(error.message);
        
        throw error;
    }
}

/**
 * Mostrar error de foto con opciones de recuperaciÃ³n - FUNCIÃ“N MEJORADA
 * REEMPLAZAR la funciÃ³n showPhotoError existente CON ESTA
 */
function showPhotoError(errorMessage = 'La foto no se pudo cargar') {
    const container = document.getElementById('photoContainer');
    if (!container) {
        console.error('âŒ Container photoContainer no encontrado');
        return;
    }
    
    // Crear mensaje de error mÃ¡s informativo
    const photoData = currentPhotoViewer.photos[currentPhotoViewer.currentIndex];
    const photoId = photoData?.id || 'desconocido';
    
    container.innerHTML = `
        <div style="padding: 40px; text-align: center; background: #ffebee; border-radius: 10px; border: 2px solid #f44336;">
            <div style="font-size: 3rem; margin-bottom: 20px;">ğŸ“¸</div>
            <h4 style="color: #c62828; margin-bottom: 15px;">âŒ Error cargando foto</h4>
            <p style="color: #666; margin-bottom: 20px;">${errorMessage}</p>
            
            <div style="background: white; padding: 15px; border-radius: 8px; margin: 15px 0; text-align: left;">
                <strong>ğŸ“‹ InformaciÃ³n de debug:</strong><br>
                <small style="color: #666;">
                    â€¢ ID de foto: ${photoId}<br>
                    â€¢ Conectividad GitHub: ${githubStorage.connected ? 'âœ… Conectado' : 'âŒ Desconectado'}<br>
                    â€¢ IndexedDB: ${isIndexedDBAvailable() ? 'âœ… Disponible' : 'âŒ No disponible'}
                </small>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button onclick="retryLoadPhoto()" class="btn btn-warning" style="margin: 5px;">
                    ğŸ”„ Reintentar Carga
                </button>
                <button onclick="forceDownloadPhoto()" class="btn btn-primary" style="margin: 5px;">
                    â˜ï¸ Forzar Descarga
                </button>
                <button onclick="closePhotoViewer()" class="btn btn-secondary" style="margin: 5px;">
                    âŒ Cerrar Visor
                </button>
            </div>
        </div>
    `;
    
    // Log del error para debug
    addDebugLog(`âŒ Error visor: ${errorMessage} (ID: ${photoId})`, 'error');
}

/**
 * Forzar descarga de foto desde GitHub - NUEVA FUNCIÃ“N
 * Agregar esta funciÃ³n DESPUÃ‰S de showPhotoError
 */
async function forceDownloadPhoto() {
    try {
        console.log('ğŸ”„ Forzando descarga desde GitHub...');
        addDebugLog('ğŸ”„ Forzando descarga de foto', 'info');
        
        const photoData = currentPhotoViewer.photos[currentPhotoViewer.currentIndex];
        if (!photoData) {
            throw new Error('No hay datos de foto disponibles');
        }
        
        // Mostrar indicador de carga
        showPhotoLoader(true);
        
        // Limpiar cache existente
        const cacheKey = `photo_cache_${photoData.id}`;
        if (githubStorage.downloadCache.has(cacheKey)) {
            const oldUrl = githubStorage.downloadCache.get(cacheKey);
            memoryManager.revokeObjectURL(oldUrl);
            githubStorage.downloadCache.delete(cacheKey);
            console.log('ğŸ—‘ï¸ Cache anterior limpiado');
        }
        
        // Limpiar URL existente
        if (photoData.url) {
            memoryManager.revokeObjectURL(photoData.url);
            photoData.url = null;
        }
        
        // Verificar conectividad GitHub
        if (!githubStorage.connected) {
            throw new Error('No hay conexiÃ³n con GitHub. Verifica tu conectividad.');
        }
        
        // Buscar metadata si no estÃ¡ disponible
        if (!photoData.githubPath && !photoData.downloadUrl) {
            console.log('ğŸ“‹ Buscando metadata de foto...');
            const cachedMetadata = getCachedPhotoMetadata(photoData.id);
            if (cachedMetadata) {
                photoData.githubPath = cachedMetadata.githubPath;
                photoData.downloadUrl = cachedMetadata.downloadUrl;
                console.log('âœ… Metadata encontrada en cache');
            } else {
                throw new Error('No se encontrÃ³ informaciÃ³n de ubicaciÃ³n en GitHub');
            }
        }
        
        // Intentar descarga forzada
        const newUrl = await downloadAndCachePhoto(photoData);
        if (!newUrl) {
            throw new Error('La descarga desde GitHub fallÃ³');
        }
        
        // Intentar cargar de nuevo
        await loadCurrentPhotoWithRemoteSupport();
        
        console.log('âœ… Descarga forzada exitosa');
        addDebugLog('âœ… Descarga forzada exitosa', 'success');
        
    } catch (error) {
        console.error('âŒ Error en descarga forzada:', error);
        addDebugLog(`âŒ Error descarga forzada: ${error.message}`, 'error');
        showPhotoError(`Error en descarga forzada: ${error.message}`);
    }
}

/**
 * Cargar foto actual en el visor
 */
async function loadCurrentPhoto() {
    try {
        const photoData = currentPhotoViewer.photos[currentPhotoViewer.currentIndex];
        if (!photoData) {
            throw new Error('No hay datos de foto para mostrar');
        }
        
        console.log('ğŸ“¸ Cargando foto:', photoData.id);
        
        // Mostrar indicador de carga
        showPhotoLoader(true);
        
        // Obtener URL de la foto
        let photoUrl = null;
        
        if (photoData.url) {
            // Usar URL existente
            photoUrl = photoData.url;
        } else if (photoData.id && isIndexedDBAvailable() && roundsDB) {
            // Recuperar desde IndexedDB
            photoUrl = await getPhotoUrlFromDB(photoData.id);
        } else if (photoData.id && window.tempPhotos && window.tempPhotos.has(photoData.id)) {
            // Recuperar desde almacenamiento temporal
            const tempData = window.tempPhotos.get(photoData.id);
            photoUrl = tempData.url;
        }
        
        if (!photoUrl) {
            throw new Error('No se pudo obtener la URL de la foto');
        }
        
        // Cargar imagen
        const img = document.getElementById('photoViewerImage');
        
        // Configurar evento de carga
        img.onload = () => {
            showPhotoLoader(false);
            updatePhotoInfo(photoData);
            showZoomControls(true);
            console.log('âœ… Foto cargada exitosamente');
        };
        
        img.onerror = () => {
            showPhotoLoader(false);
            showPhotoError();
            console.error('âŒ Error cargando imagen');
        };
        
        // Establecer fuente de imagen
        img.src = photoUrl;
        
    } catch (error) {
        console.error('âŒ Error cargando foto actual:', error);
        showPhotoLoader(false);
        showPhotoError();
    }
}

/**
 * Obtener URL de foto desde IndexedDB
 */
async function getPhotoUrlFromDB(photoId) {
    try {
        const photoRecord = await roundsDB.getPhoto(photoId);
        if (photoRecord && photoRecord.blob) {
            return URL.createObjectURL(photoRecord.blob);
        }
        return null;
    } catch (error) {
        console.error('âŒ Error obteniendo foto de DB:', error);
        return null;
    }
}

/**
 * Mostrar/ocultar indicador de carga - VERSIÃ“N MEJORADA
 * REEMPLAZAR la funciÃ³n showPhotoLoader existente CON ESTA
 */
function showPhotoLoader(show) {
    try {
        const loader = document.getElementById('photoLoader');
        const img = document.getElementById('photoViewerImage');
        
        if (!loader) {
            console.warn('âš ï¸ Elemento photoLoader no encontrado');
            return;
        }
        
        if (show) {
            // Mostrar loader con informaciÃ³n adicional
            loader.style.display = 'block';
            loader.innerHTML = `
                <div class="loading-spinner" style="
                    width: 40px; 
                    height: 40px; 
                    border: 4px solid #f3f3f3; 
                    border-top: 4px solid #2196f3; 
                    border-radius: 50%; 
                    animation: spin 1s linear infinite;
                    margin: 0 auto 15px auto;
                "></div>
                <div style="color: #666; font-size: 0.9rem; text-align: center;">
                    <div style="font-weight: bold; margin-bottom: 5px;">ğŸ“¸ Cargando foto...</div>
                    <div style="font-size: 0.8rem;">
                        ${githubStorage.connected ? 'â˜ï¸ Descargando desde la nube' : 'ğŸ’¾ Buscando en almacenamiento local'}
                    </div>
                </div>
            `;
            
            // Reducir opacidad de la imagen si existe
            if (img) {
                img.style.opacity = '0.3';
                img.style.filter = 'blur(2px)';
            }
            
            console.log('ğŸ”„ Indicador de carga mostrado');
            
        } else {
            // Ocultar loader
            loader.style.display = 'none';
            
            // Restaurar imagen si existe
            if (img) {
                img.style.opacity = '1';
                img.style.filter = 'none';
            }
            
            console.log('âœ… Indicador de carga ocultado');
        }
        
    } catch (error) {
        console.error('âŒ Error manejando indicador de carga:', error);
    }
}

/**
 * Mostrar error de carga de foto
 */
function showPhotoError() {
    const container = document.getElementById('photoContainer');
    container.innerHTML = `
        <div style="padding: 40px; text-align: center; background: #ffebee; border-radius: 10px;">
            <h4 style="color: #c62828; margin-bottom: 15px;">âŒ Error cargando foto</h4>
            <p style="color: #666;">La foto no se pudo cargar o no estÃ¡ disponible</p>
            <button onclick="retryLoadPhoto()" class="btn btn-warning" style="margin-top: 10px;">
                ğŸ”„ Reintentar
            </button>
        </div>
    `;
}

/**
 * Reintentar carga de foto - VERSIÃ“N COMPLETAMENTE CORREGIDA
 * REEMPLAZAR la funciÃ³n retryLoadPhoto existente CON ESTA
 */
async function retryLoadPhoto() {
    try {
        console.log('ğŸ”„ Reintentando carga de foto...');
        addDebugLog('ğŸ”„ Reintento de carga iniciado', 'info');
        
        // Verificar que tenemos datos vÃ¡lidos
        if (!currentPhotoViewer.photos || currentPhotoViewer.photos.length === 0) {
            throw new Error('No hay fotos disponibles para reintentar');
        }
        
        const photoData = currentPhotoViewer.photos[currentPhotoViewer.currentIndex];
        if (!photoData) {
            throw new Error('Datos de foto no vÃ¡lidos');
        }
        
        console.log(`ğŸ” Reintentando carga para foto: ${photoData.id || 'sin ID'}`);
        
        // Mostrar indicador de carga
        showPhotoLoader(true);
        
        // PASO 1: Limpiar estado anterior
        console.log('ğŸ§¹ Limpiando estado anterior...');
        
        // Limpiar URL existente si es blob
        if (photoData.url && photoData.url.startsWith('blob:')) {
            console.log('ğŸ—‘ï¸ Limpiando URL blob anterior');
            memoryManager.revokeObjectURL(photoData.url);
            photoData.url = null;
        }
        
        // Limpiar cache de descarga
        const cacheKey = `photo_cache_${photoData.id}`;
        if (githubStorage.downloadCache.has(cacheKey)) {
            const oldCacheUrl = githubStorage.downloadCache.get(cacheKey);
            memoryManager.revokeObjectURL(oldCacheUrl);
            githubStorage.downloadCache.delete(cacheKey);
            console.log('ğŸ—‘ï¸ Cache de descarga limpiado');
        }
        
        // PASO 2: Restaurar estructura del container si estÃ¡ corrupta
        console.log('ğŸ”§ Verificando estructura del container...');
        const container = document.getElementById('photoContainer');
        if (!container) {
            throw new Error('Container de foto no encontrado');
        }
        
        // Verificar que la imagen existe
        let img = document.getElementById('photoViewerImage');
        if (!img) {
            console.log('ğŸ”§ Recreando elemento de imagen...');
            container.innerHTML = `
                <img id="photoViewerImage" style="max-width: 100%; max-height: 70vh; object-fit: contain; cursor: zoom-in;">
                <div id="photoLoader" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none;">
                    <div class="loading-spinner"></div>
                    <p>ğŸ“¸ Cargando foto...</p>
                </div>
                <div id="zoomControls" style="position: absolute; bottom: 10px; right: 10px; display: none;">
                    <button onclick="zoomPhoto(0.8)" style="background: rgba(0,0,0,0.7); color: white; border: none; padding: 5px 8px; margin: 2px; border-radius: 3px; cursor: pointer;">ğŸ”-</button>
                    <button onclick="zoomPhoto(1.25)" style="background: rgba(0,0,0,0.7); color: white; border: none; padding: 5px 8px; margin: 2px; border-radius: 3px; cursor: pointer;">ğŸ”+</button>
                    <button onclick="resetPhotoZoom()" style="background: rgba(0,0,0,0.7); color: white; border: none; padding: 5px 8px; margin: 2px; border-radius: 3px; cursor: pointer;">â†»</button>
                </div>
            `;
            img = document.getElementById('photoViewerImage');
        }
        
        // PASO 3: Reset del zoom
        resetPhotoZoom();
        
        // PASO 4: Verificar conectividad si necesitamos descargar
        if (!photoData.url && (photoData.githubPath || photoData.downloadUrl)) {
            if (!githubStorage.connected) {
                console.log('ğŸ”— Verificando conectividad GitHub...');
                const connected = await checkGitHubConnectivity();
                if (!connected) {
                    throw new Error('Sin conexiÃ³n a GitHub. Verifica tu conectividad a internet.');
                }
            }
        }
        
        // PASO 5: Intentar carga con la funciÃ³n mejorada
        console.log('ğŸ“¥ Iniciando nueva carga...');
        await loadCurrentPhotoWithRemoteSupport();
        
        console.log('âœ… Reintento de carga exitoso');
        addDebugLog('âœ… Reintento exitoso', 'success');
        
        // Mostrar mensaje de Ã©xito temporal
        showTemporaryMessage('âœ… Foto cargada exitosamente', 'success');
        
    } catch (error) {
        console.error('âŒ Error en reintento de carga:', error);
        addDebugLog(`âŒ Error reintento: ${error.message}`, 'error');
        
        // Ocultar loader
        showPhotoLoader(false);
        
        // Mostrar error especÃ­fico
        showPhotoError(`Error en reintento: ${error.message}`);
        
        // Mostrar mensaje de error temporal
        showTemporaryMessage('âŒ Error reintentando carga', 'error');
    }
}

/**
 * Mostrar mensaje temporal en el visor - NUEVA FUNCIÃ“N
 * Agregar esta funciÃ³n DESPUÃ‰S de retryLoadPhoto
 */
function showTemporaryMessage(message, type = 'info') {
    try {
        // Buscar container del visor
        const modal = document.getElementById('photoViewerModal');
        if (!modal) return;
        
        // Crear elemento de mensaje
        const messageDiv = document.createElement('div');
        messageDiv.id = 'tempPhotoMessage';
        messageDiv.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10001;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            transition: opacity 0.3s ease;
            ${type === 'success' ? 'background: #d4edda; color: #155724; border: 1px solid #c3e6cb;' : ''}
            ${type === 'error' ? 'background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;' : ''}
            ${type === 'info' ? 'background: #cce7ff; color: #004085; border: 1px solid #b8daff;' : ''}
        `;
        messageDiv.textContent = message;
        
        // Remover mensaje anterior si existe
        const existingMessage = document.getElementById('tempPhotoMessage');
        if (existingMessage) {
            existingMessage.remove();
        }
        
        // Agregar nuevo mensaje
        document.body.appendChild(messageDiv);
        
        // Remover despuÃ©s de 3 segundos
        setTimeout(() => {
            if (messageDiv && messageDiv.parentNode) {
                messageDiv.style.opacity = '0';
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.remove();
                    }
                }, 300);
            }
        }, 3000);
        
    } catch (error) {
        console.error('âŒ Error mostrando mensaje temporal:', error);
    }
}

/**
 * Limpiar todos los recursos de foto - NUEVA FUNCIÃ“N AUXILIAR
 * Agregar esta funciÃ³n DESPUÃ‰S de showTemporaryMessage
 */
function cleanupPhotoResources(photoData) {
    try {
        console.log('ğŸ§¹ Limpiando recursos de foto...');
        
        if (!photoData) return;
        
        // Limpiar URL principal
        if (photoData.url && photoData.url.startsWith('blob:')) {
            memoryManager.revokeObjectURL(photoData.url);
            photoData.url = null;
            console.log('ğŸ—‘ï¸ URL principal limpiada');
        }
        
        // Limpiar cache de descarga
        if (photoData.id) {
            const cacheKey = `photo_cache_${photoData.id}`;
            if (githubStorage.downloadCache.has(cacheKey)) {
                const cacheUrl = githubStorage.downloadCache.get(cacheKey);
                memoryManager.revokeObjectURL(cacheUrl);
                githubStorage.downloadCache.delete(cacheKey);
                console.log('ğŸ—‘ï¸ Cache de descarga limpiado');
            }
        }
        
        // Limpiar almacenamiento temporal
        if (photoData.id && window.tempPhotos && window.tempPhotos.has(photoData.id)) {
            const tempData = window.tempPhotos.get(photoData.id);
            if (tempData && tempData.url && tempData.url.startsWith('blob:')) {
                memoryManager.revokeObjectURL(tempData.url);
            }
            window.tempPhotos.delete(photoData.id);
            console.log('ğŸ—‘ï¸ Almacenamiento temporal limpiado');
        }
        
        console.log('âœ… Recursos de foto limpiados');
        
    } catch (error) {
        console.error('âŒ Error limpiando recursos:', error);
    }
}

/**
 * Actualizar informaciÃ³n de la foto
 */
function updatePhotoInfo(photoData) {
    const infoDiv = document.getElementById('photoInfo');
    const dateSpan = document.getElementById('photoDate');
    const sizeSpan = document.getElementById('photoSize');
    const plantSpan = document.getElementById('photoPlant');
    const locationSpan = document.getElementById('photoLocation');
    
    if (infoDiv && dateSpan && sizeSpan && plantSpan && locationSpan) {
        const date = new Date(photoData.timestamp || photoData.captureTime || Date.now());
        const dateString = date.toLocaleString('es-ES');
        const sizeString = photoData.size ? `${(photoData.size / 1024).toFixed(1)}KB` : 'TamaÃ±o desconocido';
        const plantString = photoData.plant || 'Planta no especificada';
        const locationString = photoData.locationId || 'UbicaciÃ³n no especificada';
        
        dateSpan.textContent = dateString;
        sizeSpan.textContent = sizeString;
        plantSpan.textContent = plantString.toUpperCase();
        locationSpan.textContent = locationString;
        
        infoDiv.style.display = 'block';
    }
}

/**
 * NavegaciÃ³n en galerÃ­a - VERSIÃ“N MEJORADA CON PREVENCIÃ“N DE ERRORES
 * REEMPLAZAR la funciÃ³n navigateGallery existente CON ESTA
 */
function navigateGallery(direction) {
    try {
        console.log(`ğŸ§­ Navegando en galerÃ­a: direcciÃ³n ${direction}`);
        
        // Cache de validaciÃ³n para mejor rendimiento
        const viewer = currentPhotoViewer;
        if (!viewer.photos || viewer.photos.length === 0) {
            console.warn('âš ï¸ No hay fotos en el visor para navegar');
            showTemporaryMessage('âš ï¸ No hay fotos disponibles', 'error');
            return;
        }
        
        if (viewer.photos.length === 1) {
            console.log('â„¹ï¸ Solo hay una foto, navegaciÃ³n no disponible');
            showTemporaryMessage('â„¹ï¸ Solo hay una foto disponible', 'info');
            return;
        }
        
        // Calcular nuevo Ã­ndice con validaciÃ³n optimizada
        const currentIndex = viewer.currentIndex;
        const totalPhotos = viewer.photos.length;
        const newIndex = currentIndex + direction;
        
        console.log(`ğŸ“Š NavegaciÃ³n: ${currentIndex} â†’ ${newIndex} (total: ${totalPhotos})`);
        
        // Validar rango (OPTIMIZADO)
        if (newIndex < 0) {
            console.log('â„¹ï¸ Ya estÃ¡s en la primera foto');
            showTemporaryMessage('â„¹ï¸ Ya estÃ¡s en la primera foto', 'info');
            return;
        }
        if (newIndex >= totalPhotos) {
            console.log('â„¹ï¸ Ya estÃ¡s en la Ãºltima foto');
            showTemporaryMessage('â„¹ï¸ Ya estÃ¡s en la Ãºltima foto', 'info');
            return;
        }
        
        // Limpiar recursos de la foto actual antes de cambiar
        const currentPhotoData = currentPhotoViewer.photos[currentIndex];
        if (currentPhotoData && currentPhotoData.url && currentPhotoData.url.startsWith('blob:')) {
            // No limpiar la URL si otras fotos pueden estar usando la misma referencia
            console.log('ğŸ”„ Manteniendo URL actual para posible reutilizaciÃ³n');
        }
        
        // Actualizar Ã­ndice
        currentPhotoViewer.currentIndex = newIndex;
        
        // Actualizar navegaciÃ³n
        updateGalleryNavigation();
        
        // Reset zoom para la nueva foto
        resetPhotoZoom();
        
        // Mostrar indicador de cambio
        showTemporaryMessage(`ğŸ“¸ Foto ${newIndex + 1} de ${totalPhotos}`, 'info');
        
        // Cargar nueva foto
        loadCurrentPhotoWithRemoteSupport().catch(error => {
            console.error('âŒ Error cargando nueva foto:', error);
            addDebugLog(`âŒ Error navegaciÃ³n: ${error.message}`, 'error');
            showTemporaryMessage('âŒ Error cargando foto', 'error');
        });
        
        console.log(`âœ… NavegaciÃ³n exitosa a Ã­ndice ${newIndex}`);
        addDebugLog(`ğŸ§­ NavegaciÃ³n: foto ${newIndex + 1}/${totalPhotos}`, 'info');
        
    } catch (error) {
        console.error('âŒ Error en navegaciÃ³n de galerÃ­a:', error);
        addDebugLog(`âŒ Error navegaciÃ³n: ${error.message}`, 'error');
        showTemporaryMessage('âŒ Error en navegaciÃ³n', 'error');
    }
}

/**
 * Actualizar controles de navegaciÃ³n
 */
function updateGalleryNavigation() {
    const prevBtn = document.getElementById('prevPhotoBtn');
    const nextBtn = document.getElementById('nextPhotoBtn');
    const counter = document.getElementById('photoCounter');
    
    if (prevBtn && nextBtn && counter) {
        const current = currentPhotoViewer.currentIndex + 1;
        const total = currentPhotoViewer.photos.length;
        
        prevBtn.disabled = currentPhotoViewer.currentIndex === 0;
        nextBtn.disabled = currentPhotoViewer.currentIndex === total - 1;
        counter.textContent = `${current} / ${total}`;
        
        // Actualizar estilo de botones deshabilitados
        prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
        nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';
    }
}

/**
 * Funciones de zoom
 */
function togglePhotoZoom() {
    if (currentPhotoViewer.isZoomed) {
        resetPhotoZoom();
    } else {
        zoomPhoto(2);
    }
}

function zoomPhoto(factor) {
    const img = document.getElementById('photoViewerImage');
    if (img) {
        currentPhotoViewer.zoomLevel *= factor;
        img.style.transform = `scale(${currentPhotoViewer.zoomLevel})`;
        img.style.cursor = currentPhotoViewer.zoomLevel > 1 ? 'zoom-out' : 'zoom-in';
        currentPhotoViewer.isZoomed = currentPhotoViewer.zoomLevel > 1;
    }
}

/**
 * Resetear zoom de foto - VERSIÃ“N MEJORADA
 * REEMPLAZAR la funciÃ³n resetPhotoZoom existente CON ESTA
 */
function resetPhotoZoom() {
    try {
        const img = document.getElementById('photoViewerImage');
        if (!img) {
            console.warn('âš ï¸ Elemento de imagen no encontrado para reset de zoom');
            return;
        }
        
        // Resetear propiedades de zoom
        currentPhotoViewer.zoomLevel = 1;
        currentPhotoViewer.isZoomed = false;
        
        // Resetear estilos de la imagen
        img.style.transform = 'scale(1)';
        img.style.cursor = 'zoom-in';
        img.style.transformOrigin = 'center center';
        
        // Resetear estilos adicionales que pueden afectar la visualizaciÃ³n
        img.style.opacity = '1';
        img.style.filter = 'none';
        
        console.log('ğŸ”„ Zoom reseteado');
        
    } catch (error) {
        console.error('âŒ Error reseteando zoom:', error);
    }
}

/**
 * Funciones de zoom mejoradas - NUEVAS FUNCIONES
 * Agregar estas funciones DESPUÃ‰S de resetPhotoZoom
 */

/**
 * Alternar zoom de foto
 */
function togglePhotoZoom() {
    try {
        if (currentPhotoViewer.isZoomed) {
            resetPhotoZoom();
            showTemporaryMessage('ğŸ” Zoom reducido', 'info');
        } else {
            zoomPhoto(2);
            showTemporaryMessage('ğŸ” Zoom aplicado', 'info');
        }
    } catch (error) {
        console.error('âŒ Error alternando zoom:', error);
    }
}

/**
 * Aplicar zoom con factor especÃ­fico
 */
function zoomPhoto(factor) {
    try {
        const img = document.getElementById('photoViewerImage');
        if (!img) {
            console.warn('âš ï¸ Elemento de imagen no encontrado para zoom');
            return;
        }
        
        // Validar factor de zoom
        const newZoomLevel = currentPhotoViewer.zoomLevel * factor;
        
        // Limitar zoom entre 0.5x y 5x
        if (newZoomLevel < 0.5 || newZoomLevel > 5) {
            console.log(`â„¹ï¸ Zoom limitado: ${newZoomLevel.toFixed(1)}x fuera del rango 0.5x-5x`);
            showTemporaryMessage('ğŸ” LÃ­mite de zoom alcanzado', 'info');
            return;
        }
        
        // Aplicar nuevo zoom
        currentPhotoViewer.zoomLevel = newZoomLevel;
        currentPhotoViewer.isZoomed = newZoomLevel > 1;
        
        img.style.transform = `scale(${currentPhotoViewer.zoomLevel})`;
        img.style.cursor = currentPhotoViewer.isZoomed ? 'zoom-out' : 'zoom-in';
        
        console.log(`ğŸ” Zoom aplicado: ${currentPhotoViewer.zoomLevel.toFixed(1)}x`);
        
    } catch (error) {
        console.error('âŒ Error aplicando zoom:', error);
    }
}

/**
 * Mostrar/ocultar controles de zoom
 */
function showZoomControls(show) {
    try {
        const controls = document.getElementById('zoomControls');
        if (controls) {
            controls.style.display = show ? 'block' : 'none';
            console.log(`ğŸ›ï¸ Controles de zoom ${show ? 'mostrados' : 'ocultados'}`);
        }
    } catch (error) {
        console.error('âŒ Error manejando controles de zoom:', error);
    }
}

/**
 * Descargar foto actual del visor - FUNCIÃ“N MEJORADA
 * REEMPLAZAR la funciÃ³n downloadCurrentPhoto existente CON ESTA (si existe)
 */
function downloadCurrentPhoto() {
    try {
        const photoData = currentPhotoViewer.photos[currentPhotoViewer.currentIndex];
        if (!photoData) {
            showTemporaryMessage('âŒ No hay foto para descargar', 'error');
            return;
        }
        
        const img = document.getElementById('photoViewerImage');
        if (!img || !img.src) {
            showTemporaryMessage('âŒ La foto no estÃ¡ cargada', 'error');
            return;
        }
        
        console.log('ğŸ’¾ Iniciando descarga de foto...');
        
        // Crear enlace de descarga
        const link = document.createElement('a');
        link.href = img.src;
        
        // Generar nombre de archivo descriptivo
        const date = new Date(photoData.timestamp || Date.now()).toISOString().split('T')[0];
        const plantName = photoData.plant || 'ronda';
        const photoId = photoData.id || 'foto';
        link.download = `foto_${plantName}_${date}_${photoId}.jpg`;
        
        // Trigger descarga
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log('ğŸ’¾ Descarga de foto iniciada');
        addDebugLog('ğŸ’¾ Foto descargada', 'success');
        showTemporaryMessage('ğŸ’¾ Descarga iniciada', 'success');
        
    } catch (error) {
        console.error('âŒ Error descargando foto:', error);
        addDebugLog(`âŒ Error descarga: ${error.message}`, 'error');
        showTemporaryMessage('âŒ Error al descargar', 'error');
    }
}

function showZoomControls(show) {
    const controls = document.getElementById('zoomControls');
    if (controls) {
        controls.style.display = show ? 'block' : 'none';
    }
}

/**
 * Descargar foto actual
 */
function downloadCurrentPhoto() {
    try {
        const photoData = currentPhotoViewer.photos[currentPhotoViewer.currentIndex];
        if (!photoData) {
            showAlert('âŒ Error', 'No hay foto para descargar');
            return;
        }
        
        const img = document.getElementById('photoViewerImage');
        if (!img || !img.src) {
            showAlert('âŒ Error', 'La foto no estÃ¡ cargada');
            return;
        }
        
        // Crear enlace de descarga
        const link = document.createElement('a');
        link.href = img.src;
        link.download = `foto_${photoData.plant || 'ronda'}_${new Date(photoData.timestamp || Date.now()).toISOString().split('T')[0]}_${photoData.id}.jpg`;
        
        // Trigger descarga
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log('ğŸ’¾ Descarga de foto iniciada');
        
    } catch (error) {
        console.error('âŒ Error descargando foto:', error);
        showAlert('âŒ Error', 'Error al descargar la foto');
    }
}

/**
 * Cerrar visor de fotos - VERSIÃ“N MEJORADA CON LIMPIEZA COMPLETA
 * REEMPLAZAR la funciÃ³n closePhotoViewer existente CON ESTA
 */
function closePhotoViewer() {
    try {
        console.log('ğŸ”’ Cerrando visor de fotos...');
        addDebugLog('ğŸ”’ Visor de fotos cerrado', 'info');
        
        // PASO 1: Ocultar modal
        const modal = document.getElementById('photoViewerModal');
        if (modal) {
            modal.style.display = 'none';
            console.log('ğŸ“± Modal ocultado');
        }
        
        // PASO 2: Limpiar recursos de todas las fotos del visor
        if (currentPhotoViewer.photos && currentPhotoViewer.photos.length > 0) {
            console.log(`ğŸ§¹ Limpiando recursos de ${currentPhotoViewer.photos.length} fotos...`);
            
            currentPhotoViewer.photos.forEach((photo, index) => {
                if (photo && photo.url && photo.url.startsWith('blob:')) {
                    // Solo limpiar URLs que son especÃ­ficamente de este visor
                    // No limpiar URLs que pueden estar siendo usadas por otros componentes
                    const isCurrentViewerUrl = photo.url.includes('blob:');
                    if (isCurrentViewerUrl) {
                        console.log(`ğŸ—‘ï¸ Limpiando URL de foto ${index + 1}`);
                        // No revocar inmediatamente para evitar problemas con otros usos
                        setTimeout(() => {
                            try {
                                memoryManager.revokeObjectURL(photo.url);
                            } catch (e) {
                                // Silenciar errores de limpieza tardÃ­a
                            }
                        }, 1000);
                    }
                }
            });
        }
        
        // PASO 3: Limpiar datos del visor
        currentPhotoViewer.photos = [];
        currentPhotoViewer.currentIndex = 0;
        currentPhotoViewer.zoomLevel = 1;
        currentPhotoViewer.isZoomed = false;
        
        console.log('ğŸ“Š Datos del visor limpiados');
        
        // PASO 4: Limpiar imagen y resetear elementos
        const img = document.getElementById('photoViewerImage');
        if (img) {
            img.src = '';
            img.style.transform = 'scale(1)';
            img.style.opacity = '1';
            img.style.filter = 'none';
            img.onload = null;
            img.onerror = null;
            console.log('ğŸ–¼ï¸ Elemento de imagen limpiado');
        }
        
        // PASO 5: Ocultar elementos auxiliares
        const loader = document.getElementById('photoLoader');
        if (loader) {
            loader.style.display = 'none';
        }
        
        const zoomControls = document.getElementById('zoomControls');
        if (zoomControls) {
            zoomControls.style.display = 'none';
        }
        
        const photoInfo = document.getElementById('photoInfo');
        if (photoInfo) {
            photoInfo.style.display = 'none';
        }
        
        // PASO 6: Remover mensajes temporales
        const tempMessage = document.getElementById('tempPhotoMessage');
        if (tempMessage) {
            tempMessage.remove();
        }
        
        // PASO 7: Ejecutar limpieza general de memoria
        setTimeout(() => {
            if (window.gc) {
                window.gc(); // Forzar garbage collection si estÃ¡ disponible
            }
        }, 2000);
        
        console.log('âœ… Visor de fotos cerrado completamente');
        
    } catch (error) {
        console.error('âŒ Error cerrando visor:', error);
        addDebugLog(`âŒ Error cerrando visor: ${error.message}`, 'error');
        
        // Forzar cierre del modal aunque haya errores
        const modal = document.getElementById('photoViewerModal');
        if (modal) {
            modal.style.display = 'none';
        }
    }
}

/**
 * Crear galerÃ­a de miniaturas para observaciones
 */
async function createObservationGallery(observations, containerId) {
    try {
        const container = document.getElementById(containerId);
        if (!container || !observations || observations.length === 0) {
            return;
        }
        
        // Filtrar observaciones que tienen fotos
        const observationsWithPhotos = observations.filter(obs => obs.hasPhoto && obs.photoData);
        
        if (observationsWithPhotos.length === 0) {
            container.style.display = 'none';
            return;
        }
        
        container.style.display = 'block';
        
        const gallery = document.getElementById('galleryThumbnails');
        if (!gallery) return;
        
        gallery.innerHTML = ''; // Limpiar galerÃ­a existente
        
        // Crear miniaturas
        for (let i = 0; i < observationsWithPhotos.length; i++) {
            const obs = observationsWithPhotos[i];
            const thumbnail = await createThumbnailElement(obs.photoData, i, observationsWithPhotos);
            gallery.appendChild(thumbnail);
        }
        
        console.log(`ğŸ–¼ï¸ GalerÃ­a creada con ${observationsWithPhotos.length} fotos`);
        
    } catch (error) {
        console.error('âŒ Error creando galerÃ­a:', error);
    }
}

/**
 * Crear elemento de miniatura
 */
async function createThumbnailElement(photoData, index, allPhotos) {
    const thumbDiv = document.createElement('div');
    thumbDiv.style.cssText = `
        width: 80px;
        height: 80px;
        border: 2px solid #ddd;
        border-radius: 8px;
        overflow: hidden;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        background: #f5f5f5;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    thumbDiv.onmouseover = () => thumbDiv.style.borderColor = '#007bff';
    thumbDiv.onmouseout = () => thumbDiv.style.borderColor = '#ddd';
    
    // Crear imagen en miniatura
    const img = document.createElement('img');
    img.style.cssText = `
        width: 100%;
        height: 100%;
        object-fit: cover;
    `;
    
    // Cargar imagen
    try {
        let photoUrl = null;
        
        if (photoData.url) {
            photoUrl = photoData.url;
        } else if (photoData.id && isIndexedDBAvailable() && roundsDB) {
            photoUrl = await getPhotoUrlFromDB(photoData.id);
        } else if (photoData.id && window.tempPhotos && window.tempPhotos.has(photoData.id)) {
            const tempData = window.tempPhotos.get(photoData.id);
            photoUrl = tempData.url;
        }
        
        if (photoUrl) {
            img.src = photoUrl;
            img.onload = () => {
                thumbDiv.innerHTML = '';
                thumbDiv.appendChild(img);
            };
            img.onerror = () => {
                thumbDiv.innerHTML = 'âŒ';
                thumbDiv.style.color = '#999';
            };
        } else {
            thumbDiv.innerHTML = 'ğŸ“·';
            thumbDiv.style.color = '#999';
        }
        
    } catch (error) {
        thumbDiv.innerHTML = 'âŒ';
        thumbDiv.style.color = '#999';
    }
    
    // Evento click para abrir visor
    thumbDiv.onclick = () => openPhotoViewer(allPhotos.map(p => p.photoData), index);
    
    return thumbDiv;
}

// ===============================================
// ğŸŒ SISTEMA DE CONECTIVIDAD GITHUB
// ===============================================

/**
 * Verificar conectividad con GitHub
 */
async function checkGitHubConnectivity() {
    try {
        console.log('ğŸ”— Verificando conectividad con GitHub...');
        
        // Verificar si hay token configurado
        if (!GITHUB_CONFIG.token) {
            console.log('âš ï¸ Token no configurado, intentando cargar...');
            const tokenLoaded = initializeGitHubToken();
            
            if (!tokenLoaded) {
                console.log('â„¹ï¸ Sin token configurado - Sistema funcionarÃ¡ solo local');
                githubStorage.connected = false;
                updateGitHubStatus(false);
                return false;
            }
        }
        
        const response = await fetch(`${GITHUB_CONFIG.baseUrl}`, {
            method: 'GET',
            headers: {
                'Authorization': `token ${GITHUB_CONFIG.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'ControlRondas/1.0'
            }
        });
        
        if (response.ok) {
            githubStorage.connected = true;
            console.log('âœ… Conectividad GitHub establecida');
            updateGitHubStatus(true);
            return true;
        } else {
            throw new Error(`GitHub API respondiÃ³ con status: ${response.status}`);
        }
        
    } catch (error) {
        console.error('âŒ Error conectividad GitHub:', error);
        githubStorage.connected = false;
        updateGitHubStatus(false);
        return false;
    }
}

/**
 * Actualizar indicador de estado GitHub en UI
 */
function updateGitHubStatus(connected) {
    const statusElement = document.getElementById('connectionStatus');
    if (statusElement) {
        if (connected) {
            statusElement.innerHTML = 'ğŸ”¥ Sistema completo activo + Backup en la nube';
            statusElement.className = 'connection-status status-active';
        } else {
            statusElement.innerHTML = 'âš ï¸ Sistema activo - Backup offline (se sincronizarÃ¡ cuando haya internet)';
            statusElement.className = 'connection-status status-offline';
        }
    }
}

/**
 * Subir archivo a GitHub
 */
async function uploadToGitHub(filePath, content, message = 'Upload file') {
    try {
        console.log(`ğŸ“¤ Subiendo archivo a GitHub: ${filePath}`);
        
        // Convertir blob a base64
        let base64Content;
        if (content instanceof Blob) {
            base64Content = await blobToBase64(content);
        } else {
            // CORREGIDO: Manejar caracteres especiales (acentos, Ã±, etc.)
            try {
                // Codificar a UTF-8 primero, luego a base64
                const utf8Bytes = new TextEncoder().encode(content);
                let binary = '';
                utf8Bytes.forEach(byte => {
                    binary += String.fromCharCode(byte);
                });
                base64Content = btoa(binary);
            } catch (error) {
                console.error('âŒ Error codificando contenido:', error);
                // Fallback: limpiar caracteres problemÃ¡ticos
                const cleanContent = content.replace(/[^\x00-\x7F]/g, "");
                base64Content = btoa(cleanContent);
            }
        }
        
        const url = `${GITHUB_CONFIG.baseUrl}/contents/${filePath}`;
        
        // Verificar si el archivo ya existe para obtener SHA
let existingSHA = null;
try {
    const checkResponse = await fetch(url, {
        method: 'GET',
        headers: {
            'Authorization': `token ${GITHUB_CONFIG.token}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'ControlRondas/1.0'
        }
    });
    
    if (checkResponse.ok) {
        const existingFile = await checkResponse.json();
        existingSHA = existingFile.sha;
        console.log(`ğŸ“ Archivo existente encontrado, SHA: ${existingSHA}`);
    }
} catch (e) {
    // Archivo no existe, estÃ¡ bien
    console.log('ğŸ“„ Archivo nuevo, no hay conflicto');
}

const requestBody = {
    message: message,
    content: base64Content,
    branch: GITHUB_CONFIG.branch
};

// Agregar SHA si el archivo existe (para actualizaciones)
if (existingSHA) {
    requestBody.sha = existingSHA;
}
        
        const response = await fetch(url, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${GITHUB_CONFIG.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json',
                'User-Agent': 'ControlRondas/1.0'
            },
            body: JSON.stringify(requestBody)
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log(`âœ… Archivo subido exitosamente: ${filePath}`);
            
            // Actualizar estadÃ­sticas
            githubStorage.statistics.totalUploaded++;
            githubStorage.statistics.totalSize += content.size || content.length;
            githubStorage.statistics.lastSync = new Date().toISOString();
            
            return {
                success: true,
                downloadUrl: result.content.download_url,
                htmlUrl: result.content.html_url,
                path: filePath,
                sha: result.content.sha
            };
        } else {
            const errorData = await response.json();
            throw new Error(`GitHub upload failed: ${errorData.message}`);
        }
        
    } catch (error) {
        console.error('âŒ Error subiendo a GitHub:', error);
        githubStorage.statistics.errors++;
        
        return {
            success: false,
            error: error.message,
            path: filePath
        };
    }
}

/**
 * Convertir Blob a Base64
 */
function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
            const base64 = reader.result.split(',')[1]; // Remover prefijo data:image/...;base64,
            resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

/**
 * Descargar archivo desde GitHub
 */
async function downloadFromGitHub(filePath) {
    try {
        console.log(`ğŸ“¥ Descargando archivo desde GitHub: ${filePath}`);
        
        // Verificar cache primero
        if (githubStorage.downloadCache.has(filePath)) {
            console.log('ğŸ“‹ Archivo encontrado en cache');
            return githubStorage.downloadCache.get(filePath);
        }
        
        const url = `${GITHUB_CONFIG.rawUrl}/${filePath}`;
        
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'User-Agent': 'ControlRondas/1.0'
            }
        });
        
        if (response.ok) {
            const blob = await response.blob();
            console.log(`âœ… Archivo descargado exitosamente: ${filePath}`);
            
            // Guardar en cache
            const objectUrl = URL.createObjectURL(blob);
            githubStorage.downloadCache.set(filePath, objectUrl);
            
            return objectUrl;
        } else {
            throw new Error(`Download failed: ${response.status}`);
        }
        
    } catch (error) {
        console.error('âŒ Error descargando desde GitHub:', error);
        return null;
    }
}

/**
 * Crear o actualizar archivo de metadata
 */
async function updateMetadata(photoData, githubPath) {
    try {
        const metadataEntry = {
            id: photoData.id,
            githubPath: githubPath,
            originalData: {
                plant: photoData.plant,
                turn: photoData.turn,
                locationId: photoData.locationId,
                timestamp: photoData.timestamp,
                size: photoData.size
            },
            uploadTime: new Date().toISOString()
        };
        
        // Generar nombre de archivo de metadata
        const metaFileName = `meta/${fileEncryption.simpleHash(photoData.id)}.json`;
        
        // Subir metadata
        const result = await uploadToGitHub(
            metaFileName,
            JSON.stringify(metadataEntry, null, 2),
            `Update metadata for photo ${photoData.id}`
        );
        
        if (result.success) {
            console.log('ğŸ“‹ Metadata actualizada exitosamente');
            return metaFileName;
        } else {
            throw new Error(result.error);
        }
        
    } catch (error) {
        console.error('âŒ Error actualizando metadata:', error);
        return null;
    }
}

/**
 * Obtener estadÃ­sticas de uso del repositorio
 */
async function getRepositoryStats() {
    try {
        console.log('ğŸ“Š Obteniendo estadÃ­sticas del repositorio...');
        
        const response = await fetch(`${GITHUB_CONFIG.baseUrl}`, {
            method: 'GET',
            headers: {
                'Authorization': `token ${GITHUB_CONFIG.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'ControlRondas/1.0'
            }
        });
        
        if (response.ok) {
            const repoData = await response.json();
            
            return {
                size: repoData.size, // En KB
                sizeMB: (repoData.size / 1024).toFixed(2),
                updatedAt: repoData.updated_at,
                language: repoData.language,
                stars: repoData.stargazers_count,
                private: repoData.private
            };
        } else {
            throw new Error(`Stats request failed: ${response.status}`);
        }
        
    } catch (error) {
        console.error('âŒ Error obteniendo estadÃ­sticas:', error);
        return null;
    }
}

/**
 * Probar conectividad con upload de prueba
 */
async function testGitHubUpload() {
    try {
        console.log('ğŸ§ª Realizando prueba de upload...');
        
        const testContent = JSON.stringify({
            test: true,
            timestamp: new Date().toISOString(),
            message: 'Prueba de conectividad del sistema de rondas'
        }, null, 2);
        
        const testPath = `meta/connectivity_test_${Date.now()}.json`;
        
        const result = await uploadToGitHub(
            testPath,
            testContent,
            'Connectivity test from Control de Rondas system'
        );
        
        if (result.success) {
            console.log('âœ… Prueba de upload exitosa');
            showNotificationIfEnabled('ğŸ”— Conectividad GitHub', 'ConexiÃ³n verificada exitosamente');
            return true;
        } else {
            throw new Error(result.error);
        }
        
    } catch (error) {
        console.error('âŒ Fallo en prueba de upload:', error);
        showAlert('âš ï¸ Advertencia', 'La conectividad con GitHub estÃ¡ limitada. Las fotos se guardarÃ¡n localmente y se sincronizarÃ¡n cuando mejore la conexiÃ³n.');
        return false;
    }
}

/**
 * Mostrar notificaciÃ³n si estÃ¡n habilitadas
 */
function showNotificationIfEnabled(title, message) {
    if (notificationsEnabled && 'Notification' in window && Notification.permission === 'granted') {
        new Notification(title, {
            body: message,
            icon: 'ğŸ”—'
        });
    }
}

// ===============================================
// ğŸ“¤ SISTEMA DE BACKUP AUTOMÃTICO A GITHUB
// ===============================================

/**
 * Realizar backup de foto a GitHub en background
 */
async function backupPhotoToGitHub(photoData, localPhotoData) {
    try {
        console.log('â˜ï¸ Iniciando backup automÃ¡tico a GitHub...');
        
        // Verificar conectividad
        if (!githubStorage.connected) {
            console.log('âš ï¸ Sin conectividad GitHub, agregando a cola de pendientes');
            addToUploadQueue(photoData, localPhotoData);
            return;
        }
        
        // Mostrar indicador de backup en progreso
        showBackupProgress(localPhotoData.id, 'uploading');
        
        // Generar ruta encriptada
        const githubPath = fileEncryption.createStoragePath(photoData);
        
        // Subir foto a GitHub
        const uploadResult = await uploadToGitHub(
            githubPath,
            photoData.blob,
            `Backup foto ${photoData.plant} - ${new Date(photoData.timestamp).toLocaleDateString()}`
        );
        
        if (uploadResult.success) {
            // Crear y subir metadata
            const metadataPath = await updateMetadata({
                ...photoData,
                githubPath: githubPath,
                downloadUrl: uploadResult.downloadUrl
            }, githubPath);
            
            if (metadataPath) {
                // Marcar como respaldada
                localPhotoData.backedUp = true;
                localPhotoData.githubPath = githubPath;
                localPhotoData.downloadUrl = uploadResult.downloadUrl;
                
                // Actualizar en IndexedDB
                await updatePhotoBackupStatus(localPhotoData.id, {
                    backedUp: true,
                    githubPath: githubPath,
                    downloadUrl: uploadResult.downloadUrl,
                    backupTime: new Date().toISOString()
                });
                
                console.log('âœ… Backup automÃ¡tico completado exitosamente');
                showBackupProgress(localPhotoData.id, 'success');
                
                // Actualizar estadÃ­sticas UI
                updateBackupStatistics();
                
                // NotificaciÃ³n opcional
                showNotificationIfEnabled('â˜ï¸ Backup Completado', 'Foto respaldada en la nube exitosamente');
                
            } else {
                throw new Error('Error creando metadata');
            }
            
        } else {
            throw new Error(uploadResult.error || 'Error desconocido en upload');
        }
        
    } catch (error) {
        console.error('âŒ Error en backup automÃ¡tico:', error);
        
        // Agregar a cola para reintentar
        addToUploadQueue(photoData, localPhotoData);
        
        // Mostrar error temporal
        showBackupProgress(localPhotoData.id, 'error');
        
        console.log('ğŸ“‹ Foto agregada a cola de reintento');
    }
}

/**
 * Backup automÃ¡tico de recorrido a GitHub
 */
async function backupRoundToGitHub(roundData) {
    try {
        console.log('â˜ï¸ Iniciando backup de recorrido a GitHub:', roundData.id);
        addDebugLog(`ğŸ“‹ Backup recorrido: ${roundData.id}`, 'info');
        
        if (!githubStorage.connected) {
            console.log('âš ï¸ Sin conectividad GitHub, agregando recorrido a cola');
            addToRoundUploadQueue(roundData);
            return;
        }
        
        // Crear ruta para el archivo
        const fileName = `rounds/round_${roundData.plant}_${roundData.id}.json`;
        
        // Preparar datos para upload
        const roundDataForUpload = {
            ...roundData,
            uploadedAt: new Date().toISOString(),
            uploadedFrom: roundData.device || 'unknown'
        };
        
        // Subir a GitHub
        const uploadResult = await uploadToGitHub(
            fileName,
            JSON.stringify(roundDataForUpload, null, 2),
            `Backup recorrido ${roundData.plant} - ${new Date(roundData.startTime).toLocaleDateString()}`
        );
        
        if (uploadResult.success) {
            // Marcar como sincronizado en IndexedDB
            await markRoundAsSynced(roundData.id);
            
            console.log('âœ… Recorrido respaldado exitosamente en GitHub');
            addDebugLog(`âœ… Recorrido respaldado: ${roundData.id}`, 'success');
            
            // Actualizar estadÃ­sticas
            updateBackupStatistics();
        } else {
            throw new Error(uploadResult.error);
        }
        
    } catch (error) {
        console.error('âŒ Error respaldando recorrido:', error);
        addDebugLog(`âŒ Error backup recorrido: ${error.message}`, 'error');
        addToRoundUploadQueue(roundData);
    }
}

/**
 * Backup automÃ¡tico de incidencia a GitHub
 */
async function backupIncidentToGitHub(incidentData) {
    try {
        console.log('â˜ï¸ Iniciando backup de incidencia a GitHub:', incidentData.id);
        addDebugLog(`ğŸš¨ Backup incidencia: ${incidentData.id}`, 'info');
        
        if (!githubStorage.connected) {
            console.log('âš ï¸ Sin conectividad GitHub, agregando incidencia a cola');
            addToIncidentUploadQueue(incidentData);
            return;
        }
        
        // Crear ruta para el archivo
        const fileName = `incidents/incident_${incidentData.plant}_${incidentData.id}.json`;
        
        // Preparar datos para upload
        const incidentDataForUpload = {
            ...incidentData,
            uploadedAt: new Date().toISOString(),
            uploadedFrom: incidentData.device || 'unknown'
        };
        
        // Subir a GitHub
        const uploadResult = await uploadToGitHub(
            fileName,
            JSON.stringify(incidentDataForUpload, null, 2),
            `Backup incidencia ${incidentData.incidentType || 'general'} - ${incidentData.plant}`
        );
        
        if (uploadResult.success) {
            // Marcar como sincronizado en IndexedDB
            await markIncidentAsSynced(incidentData.id);
            
            console.log('âœ… Incidencia respaldada exitosamente en GitHub');
            addDebugLog(`âœ… Incidencia respaldada: ${incidentData.id}`, 'success');
            
            // Actualizar estadÃ­sticas
            updateBackupStatistics();
        } else {
            throw new Error(uploadResult.error);
        }
        
    } catch (error) {
        console.error('âŒ Error respaldando incidencia:', error);
        addDebugLog(`âŒ Error backup incidencia: ${error.message}`, 'error');
        addToIncidentUploadQueue(incidentData);
    }
}


/**
 * Actualizar estado de backup en IndexedDB
 */
async function updatePhotoBackupStatus(photoId, backupInfo) {
    try {
        if (isIndexedDBAvailable() && roundsDB) {
            // Obtener foto existente
            const existingPhoto = await roundsDB.getPhoto(photoId);
            if (existingPhoto) {
                // Actualizar con informaciÃ³n de backup
                const updatedPhoto = {
                    ...existingPhoto,
                    ...backupInfo
                };
                
                // Guardar actualizaciÃ³n (esto podrÃ­a requerir implementar updatePhoto en roundsDB)
                console.log('ğŸ’¾ Estado de backup actualizado en IndexedDB');
            }
        }
    } catch (error) {
        console.error('âŒ Error actualizando estado de backup:', error);
    }
}

/**
 * Agregar foto a cola de subida pendiente
 */
function addToUploadQueue(photoData, localPhotoData) {
    const queueItem = {
        id: localPhotoData.id,
        photoData: photoData,
        localPhotoData: localPhotoData,
        attempts: 0,
        maxAttempts: 3,
        addedAt: new Date().toISOString()
    };
    
    githubStorage.uploadQueue.push(queueItem);
    console.log(`ğŸ“‹ Foto agregada a cola de upload: ${githubStorage.uploadQueue.length} pendientes`);
    
    // Guardar cola en localStorage para persistencia
    localStorage.setItem('githubUploadQueue', JSON.stringify(githubStorage.uploadQueue));
}

/**
 * Agregar recorrido a cola de upload
 */
function addToRoundUploadQueue(roundData) {
    const queueItem = {
        id: roundData.id,
        type: 'round',
        data: roundData,
        attempts: 0,
        maxAttempts: 3,
        addedAt: new Date().toISOString()
    };
    
    if (!githubStorage.roundUploadQueue) {
        githubStorage.roundUploadQueue = [];
    }
    
    githubStorage.roundUploadQueue.push(queueItem);
    console.log(`ğŸ“‹ Recorrido agregado a cola de upload: ${githubStorage.roundUploadQueue.length} pendientes`);
    addDebugLog(`ğŸ“‹ Recorrido en cola: ${roundData.id}`, 'info');
    
    // Guardar cola en localStorage para persistencia
    localStorage.setItem('githubRoundUploadQueue', JSON.stringify(githubStorage.roundUploadQueue));
}

/**
 * Agregar incidencia a cola de upload
 */
function addToIncidentUploadQueue(incidentData) {
    const queueItem = {
        id: incidentData.id,
        type: 'incident',
        data: incidentData,
        attempts: 0,
        maxAttempts: 3,
        addedAt: new Date().toISOString()
    };
    
    if (!githubStorage.incidentUploadQueue) {
        githubStorage.incidentUploadQueue = [];
    }
    
    githubStorage.incidentUploadQueue.push(queueItem);
    console.log(`ğŸš¨ Incidencia agregada a cola de upload: ${githubStorage.incidentUploadQueue.length} pendientes`);
    addDebugLog(`ğŸš¨ Incidencia en cola: ${incidentData.id}`, 'info');
    
    // Guardar cola en localStorage para persistencia
    localStorage.setItem('githubIncidentUploadQueue', JSON.stringify(githubStorage.incidentUploadQueue));
}

/**
 * Procesar cola de recorridos pendientes
 */
async function processRoundUploadQueue() {
    if (!githubStorage.roundUploadQueue || githubStorage.roundUploadQueue.length === 0) {
        return;
    }
    
    console.log(`ğŸ”„ Procesando cola de recorridos: ${githubStorage.roundUploadQueue.length} elementos`);
    addDebugLog(`ğŸ”„ Procesando ${githubStorage.roundUploadQueue.length} recorridos pendientes`, 'info');
    
    // Procesar un elemento a la vez
    const item = githubStorage.roundUploadQueue.shift();
    
    if (item.attempts < item.maxAttempts) {
        item.attempts++;
        console.log(`ğŸ”„ Reintentando upload recorrido (intento ${item.attempts}/${item.maxAttempts})`);
        
        try {
            await backupRoundToGitHub(item.data);
        } catch (error) {
            console.error(`âŒ Error procesando recorrido ${item.id}:`, error);
            // Volver a agregar a la cola si no ha alcanzado el mÃ¡ximo de intentos
            if (item.attempts < item.maxAttempts) {
                githubStorage.roundUploadQueue.push(item);
            } else {
                addDebugLog(`âŒ MÃ¡ximo de intentos alcanzado para recorrido ${item.id}`, 'error');
            }
        }
    }
    
    // Actualizar cola en localStorage
    localStorage.setItem('githubRoundUploadQueue', JSON.stringify(githubStorage.roundUploadQueue));
    
    // Procesar siguiente elemento si hay conectividad
    if (githubStorage.connected && githubStorage.roundUploadQueue.length > 0) {
        setTimeout(processRoundUploadQueue, 3000); // Esperar 3 segundos entre uploads
    }
}

/**
 * Procesar cola de incidencias pendientes
 */
async function processIncidentUploadQueue() {
    if (!githubStorage.incidentUploadQueue || githubStorage.incidentUploadQueue.length === 0) {
        return;
    }
    
    console.log(`ğŸ”„ Procesando cola de incidencias: ${githubStorage.incidentUploadQueue.length} elementos`);
    addDebugLog(`ğŸ”„ Procesando ${githubStorage.incidentUploadQueue.length} incidencias pendientes`, 'info');
    
    // Procesar un elemento a la vez
    const item = githubStorage.incidentUploadQueue.shift();
    
    if (item.attempts < item.maxAttempts) {
        item.attempts++;
        console.log(`ğŸ”„ Reintentando upload incidencia (intento ${item.attempts}/${item.maxAttempts})`);
        
        try {
            await backupIncidentToGitHub(item.data);
        } catch (error) {
            console.error(`âŒ Error procesando incidencia ${item.id}:`, error);
            // Volver a agregar a la cola si no ha alcanzado el mÃ¡ximo de intentos
            if (item.attempts < item.maxAttempts) {
                githubStorage.incidentUploadQueue.push(item);
            } else {
                addDebugLog(`âŒ MÃ¡ximo de intentos alcanzado para incidencia ${item.id}`, 'error');
            }
        }
    }
    
    // Actualizar cola en localStorage
    localStorage.setItem('githubIncidentUploadQueue', JSON.stringify(githubStorage.incidentUploadQueue));
    
    // Procesar siguiente elemento si hay conectividad
    if (githubStorage.connected && githubStorage.incidentUploadQueue.length > 0) {
        setTimeout(processIncidentUploadQueue, 3000); // Esperar 3 segundos entre uploads
    }
}

/**
 * Marcar recorrido como sincronizado en IndexedDB
 */
async function markRoundAsSynced(roundId) {
    try {
        if (!isIndexedDBAvailable() || !roundsDB) {
            console.log('âš ï¸ IndexedDB no disponible para marcar recorrido como sincronizado');
            return;
        }
        
        const transaction = roundsDB.db.transaction(['rounds'], 'readwrite');
        const store = transaction.objectStore('rounds');
        
        // Obtener el recorrido actual
        const getRequest = store.get(roundId);
        
        getRequest.onsuccess = () => {
            const roundData = getRequest.result;
            if (roundData) {
                roundData.synced = true;
                roundData.syncedAt = new Date().toISOString();
                
                // Actualizar en la base de datos
                const putRequest = store.put(roundData);
                putRequest.onsuccess = () => {
                    console.log(`âœ… Recorrido ${roundId} marcado como sincronizado`);
                    addDebugLog(`âœ… Recorrido sincronizado: ${roundId}`, 'success');
                };
                putRequest.onerror = () => {
                    console.error(`âŒ Error marcando recorrido como sincronizado: ${putRequest.error}`);
                };
            }
        };
        
        getRequest.onerror = () => {
            console.error(`âŒ Error obteniendo recorrido para marcar como sincronizado: ${getRequest.error}`);
        };
        
    } catch (error) {
        console.error('âŒ Error en markRoundAsSynced:', error);
    }
}

/**
 * Marcar incidencia como sincronizada en IndexedDB
 */
async function markIncidentAsSynced(incidentId) {
    try {
        if (!isIndexedDBAvailable() || !roundsDB) {
            console.log('âš ï¸ IndexedDB no disponible para marcar incidencia como sincronizada');
            return;
        }
        
        const transaction = roundsDB.db.transaction(['incidents'], 'readwrite');
        const store = transaction.objectStore('incidents');
        
        // Obtener la incidencia actual
        const getRequest = store.get(incidentId);
        
        getRequest.onsuccess = () => {
            const incidentData = getRequest.result;
            if (incidentData) {
                incidentData.synced = true;
                incidentData.syncedAt = new Date().toISOString();
                
                // Actualizar en la base de datos
                const putRequest = store.put(incidentData);
                putRequest.onsuccess = () => {
                    console.log(`âœ… Incidencia ${incidentId} marcada como sincronizada`);
                    addDebugLog(`âœ… Incidencia sincronizada: ${incidentId}`, 'success');
                };
                putRequest.onerror = () => {
                    console.error(`âŒ Error marcando incidencia como sincronizada: ${putRequest.error}`);
                };
            }
        };
        
        getRequest.onerror = () => {
            console.error(`âŒ Error obteniendo incidencia para marcar como sincronizada: ${getRequest.error}`);
        };
        
    } catch (error) {
        console.error('âŒ Error en markIncidentAsSynced:', error);
    }
}

/**
 * Cargar colas desde localStorage al iniciar
 */
function loadUploadQueuesFromStorage() {
    try {
        // Cargar cola de recorridos
        const savedRoundQueue = localStorage.getItem('githubRoundUploadQueue');
        if (savedRoundQueue) {
            githubStorage.roundUploadQueue = JSON.parse(savedRoundQueue);
            console.log(`ğŸ“‹ Cola de recorridos cargada: ${githubStorage.roundUploadQueue.length} elementos pendientes`);
        } else {
            githubStorage.roundUploadQueue = [];
        }
        
        // Cargar cola de incidencias
        const savedIncidentQueue = localStorage.getItem('githubIncidentUploadQueue');
        if (savedIncidentQueue) {
            githubStorage.incidentUploadQueue = JSON.parse(savedIncidentQueue);
            console.log(`ğŸš¨ Cola de incidencias cargada: ${githubStorage.incidentUploadQueue.length} elementos pendientes`);
        } else {
            githubStorage.incidentUploadQueue = [];
        }
        
    } catch (error) {
        console.error('âŒ Error cargando colas de upload:', error);
        githubStorage.roundUploadQueue = [];
        githubStorage.incidentUploadQueue = [];
    }
}

/**
 * Procesar todas las colas pendientes
 */
async function processAllUploadQueues() {
    if (!githubStorage.connected) {
        console.log('âš ï¸ Sin conexiÃ³n GitHub, no se pueden procesar las colas');
        return;
    }
    
    console.log('ğŸ”„ Procesando todas las colas de upload...');
    
    // Procesar recorridos pendientes
    if (githubStorage.roundUploadQueue && githubStorage.roundUploadQueue.length > 0) {
        console.log(`ğŸ“‹ Procesando ${githubStorage.roundUploadQueue.length} recorridos pendientes`);
        addDebugLog(`ğŸ“‹ Iniciando procesamiento de ${githubStorage.roundUploadQueue.length} recorridos`, 'info');
        setTimeout(processRoundUploadQueue, 1000);
    }
    
    // Procesar incidencias pendientes
    if (githubStorage.incidentUploadQueue && githubStorage.incidentUploadQueue.length > 0) {
        console.log(`ğŸš¨ Procesando ${githubStorage.incidentUploadQueue.length} incidencias pendientes`);
        addDebugLog(`ğŸš¨ Iniciando procesamiento de ${githubStorage.incidentUploadQueue.length} incidencias`, 'info');
        setTimeout(processIncidentUploadQueue, 2000);
    }
}


/**
 * Procesar cola de uploads pendientes
 */
async function processUploadQueue() {
    if (githubStorage.uploadQueue.length === 0) {
        return;
    }
    
    console.log(`ğŸ”„ Procesando cola de uploads: ${githubStorage.uploadQueue.length} elementos`);
    
    // Procesar un elemento a la vez para no sobrecargar
    const item = githubStorage.uploadQueue.shift();
    
    if (item.attempts < item.maxAttempts) {
        item.attempts++;
        console.log(`ğŸ”„ Reintentando upload (intento ${item.attempts}/${item.maxAttempts})`);
        
        await backupPhotoToGitHub(item.photoData, item.localPhotoData);
    } else {
        console.log(`âŒ MÃ¡ximo de intentos alcanzado para foto ${item.id}`);
        showNotificationIfEnabled('âš ï¸ Error de Backup', 'Una foto no pudo ser respaldada despuÃ©s de varios intentos');
    }
    
    // Actualizar cola en localStorage
    localStorage.setItem('githubUploadQueue', JSON.stringify(githubStorage.uploadQueue));
    
    // Procesar siguiente elemento si hay conectividad
    if (githubStorage.connected && githubStorage.uploadQueue.length > 0) {
        setTimeout(processUploadQueue, 2000); // Esperar 2 segundos entre uploads
    }
}

/**
 * Mostrar progreso de backup en UI
 */
function showBackupProgress(photoId, status) {
    // Buscar indicador existente o crear uno nuevo
    let indicator = document.getElementById(`backup-indicator-${photoId}`);
    
    if (!indicator) {
        // Crear indicador si no existe
        const photoPreview = document.getElementById('capturedPhoto');
        if (photoPreview && photoPreview.parentElement) {
            indicator = document.createElement('div');
            indicator.id = `backup-indicator-${photoId}`;
            indicator.style.cssText = `
                position: absolute;
                top: 5px;
                left: 5px;
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 3px 6px;
                border-radius: 3px;
                font-size: 0.7rem;
                z-index: 10;
            `;
            
            photoPreview.parentElement.style.position = 'relative';
            photoPreview.parentElement.appendChild(indicator);
        }
    }
    
    if (indicator) {
        switch (status) {
            case 'uploading':
                indicator.textContent = 'â˜ï¸ Respaldando...';
                indicator.style.background = 'rgba(0,123,255,0.9)';
                break;
            case 'success':
                indicator.textContent = 'âœ… Respaldada';
                indicator.style.background = 'rgba(40,167,69,0.9)';
                setTimeout(() => {
                    if (indicator) indicator.style.opacity = '0.7';
                }, 2000);
                break;
            case 'error':
                indicator.textContent = 'âš ï¸ Error';
                indicator.style.background = 'rgba(220,53,69,0.9)';
                setTimeout(() => {
                    if (indicator) indicator.textContent = 'ğŸ“‹ En cola';
                }, 3000);
                break;
        }
    }
}

/**
 * Actualizar estadÃ­sticas de backup en dashboard
 */
function updateBackupStatistics() {
    // Actualizar contadores en UI
    const uploadedElement = document.getElementById('uploadedCount');
    const storageElement = document.getElementById('storageUsed');
    const lastSyncElement = document.getElementById('lastSyncTime');
    
    if (uploadedElement) {
        uploadedElement.textContent = githubStorage.statistics.totalUploaded;
    }
    
    if (storageElement) {
        const sizeMB = (githubStorage.statistics.totalSize / (1024 * 1024)).toFixed(2);
        storageElement.textContent = `${sizeMB} MB`;
    }
    
    if (lastSyncElement && githubStorage.statistics.lastSync) {
        const syncTime = new Date(githubStorage.statistics.lastSync);
        lastSyncElement.textContent = syncTime.toLocaleString('es-ES');
    }
    
    // Mostrar panel de estadÃ­sticas
    const statsPanel = document.getElementById('githubStats');
    if (statsPanel && githubStorage.statistics.totalUploaded > 0) {
        statsPanel.classList.remove('hidden');
    }
}

/**
 * Cargar cola de uploads desde localStorage al iniciar
 */
function loadUploadQueueFromStorage() {
    try {
        const savedQueue = localStorage.getItem('githubUploadQueue');
        if (savedQueue) {
            githubStorage.uploadQueue = JSON.parse(savedQueue);
            console.log(`ğŸ“‹ Cola de uploads cargada: ${githubStorage.uploadQueue.length} elementos pendientes`);
        }
    } catch (error) {
        console.error('âŒ Error cargando cola de uploads:', error);
        githubStorage.uploadQueue = [];
    }
}

/**
 * Inicializar sistema de backup automÃ¡tico
 */
async function initializeAutoBackup() {
    console.log('ğŸ”„ Inicializando sistema de backup automÃ¡tico...');
    
    // Cargar cola pendiente
    loadUploadQueueFromStorage();

    // NUEVO: Cargar colas de recorridos e incidencias
loadUploadQueuesFromStorage();

// NUEVO: Procesar colas pendientes si hay conectividad
setTimeout(() => {
    if (githubStorage.connected) {
        processAllUploadQueues();
    }
}, 10000); // Esperar 10 segundos despuÃ©s del inicio
    
    // Procesar cola si hay conectividad
    if (githubStorage.connected && githubStorage.uploadQueue.length > 0) {
        console.log('ğŸ”„ Procesando cola de uploads pendientes...');
        setTimeout(processUploadQueue, 5000); // Esperar 5 segundos despuÃ©s del inicio
    }
    
    // Configurar procesamiento periÃ³dico de cola
    setInterval(() => {
        if (githubStorage.connected && githubStorage.uploadQueue.length > 0) {
            processUploadQueue();
        }
    }, 30000); // Revisar cada 30 segundos
    
    // Actualizar estadÃ­sticas iniciales
    updateBackupStatistics();

    // NUEVO: Configurar sincronizaciÃ³n periÃ³dica desde GitHub
setInterval(async () => {
    if (githubStorage.connected) {
        try {
            const syncedCount = await syncPhotosFromGitHub();
            if (syncedCount > 0) {
                addDebugLog(`ğŸ”„ Auto-sync: ${syncedCount} fotos nuevas`, 'info');
                updateBackupStatistics();
            }
        } catch (error) {
            console.error('âŒ Error en auto-sync:', error);
        }
    }
}, 300000); // Cada 5 minutos

// Limpiar cache automÃ¡ticamente cada hora
setInterval(() => {
    cleanPhotoCache();
}, 3600000); // Cada hora
    
    console.log('âœ… Sistema de backup automÃ¡tico inicializado');

// NUEVO: Inicializar sistema completo de cache inteligente
await initAdvancedCacheSystem();
}

// ===============================================
// ğŸ“¥ SISTEMA DE DESCARGA Y ACCESO MULTIPLATAFORMA
// ===============================================

// ===============================================
// ğŸ—„ï¸ SISTEMA DE CACHE INTELIGENTE MULTINIVEL
// ===============================================

/**
 * Gestor de cache multinivel para fotos
 * Optimiza el rendimiento y gestiona memoria automÃ¡ticamente
 */
class CacheManager {
    constructor() {
        this.caches = {
            memory: new Map(),      // Cache en memoria (mÃ¡s rÃ¡pido)
            persistent: new Map(),  // Cache persistente (localStorage)
            download: new Map(),    // Cache de descargas (URLs blob)
            metadata: new Map()     // Cache de metadatos
        };
        
        this.config = {
            maxMemorySize: 50 * 1024 * 1024,    // 50MB en memoria
            maxPersistentSize: 200 * 1024 * 1024, // 200MB persistente
            maxDownloadCache: 100,               // 100 URLs blob mÃ¡ximo
            defaultTTL: 24 * 60 * 60 * 1000,   // 24 horas TTL por defecto
            cleanupInterval: 5 * 60 * 1000       // Limpieza cada 5 minutos
        };
        
        this.stats = {
            hits: 0,
            misses: 0,
            downloads: 0,
            cleanups: 0,
            memoryUsed: 0,
            lastCleanup: null
        };
        
        this.isInitialized = false;
        this.cleanupTimer = null;
    }

    /**
     * Inicializar el gestor de cache
     */
    async init() {
        try {
            console.log('ğŸ—„ï¸ Inicializando CacheManager...');
            
            // Detectar capacidades del dispositivo
            await this.detectDeviceCapabilities();
            
            // Cargar cache persistente
            await this.loadPersistentCache();
            
            // Configurar limpieza automÃ¡tica
            this.setupAutomaticCleanup();
            
            // Registrar eventos
            this.setupEventListeners();
            
            this.isInitialized = true;
            console.log('âœ… CacheManager inicializado correctamente');
            addDebugLog('âœ… Cache manager inicializado', 'success');
            
            return true;
            
        } catch (error) {
            console.error('âŒ Error inicializando CacheManager:', error);
            addDebugLog(`âŒ Error cache manager: ${error.message}`, 'error');
            return false;
        }
    }

    /**
     * Detectar capacidades del dispositivo
     */
    async detectDeviceCapabilities() {
        try {
            // Detectar memoria disponible
            if (navigator.deviceMemory) {
                const deviceMemoryGB = navigator.deviceMemory;
                console.log(`ğŸ“± Memoria del dispositivo: ${deviceMemoryGB}GB`);
                
                // Ajustar lÃ­mites segÃºn la memoria disponible
                if (deviceMemoryGB <= 2) {
                    this.config.maxMemorySize = 20 * 1024 * 1024;  // 20MB
                    this.config.maxPersistentSize = 100 * 1024 * 1024; // 100MB
                    this.config.maxDownloadCache = 50;
                } else if (deviceMemoryGB <= 4) {
                    this.config.maxMemorySize = 30 * 1024 * 1024;  // 30MB
                    this.config.maxPersistentSize = 150 * 1024 * 1024; // 150MB
                    this.config.maxDownloadCache = 75;
                }
                
                console.log(`ğŸ”§ LÃ­mites ajustados: Memoria=${(this.config.maxMemorySize/1024/1024).toFixed(0)}MB, Persistente=${(this.config.maxPersistentSize/1024/1024).toFixed(0)}MB`);
            }
            
            // Detectar tipo de conexiÃ³n
            if (navigator.connection) {
                const connection = navigator.connection;
                const effectiveType = connection.effectiveType;
                
                console.log(`ğŸ“¡ ConexiÃ³n: ${effectiveType}`);
                
                // Ajustar configuraciÃ³n segÃºn la conexiÃ³n
                if (effectiveType === 'slow-2g' || effectiveType === '2g') {
                    this.config.maxDownloadCache = 25; // Reducir cache en conexiones lentas
                    this.config.defaultTTL = 48 * 60 * 60 * 1000; // Mantener cache mÃ¡s tiempo
                }
            }
            
        } catch (error) {
            console.warn('âš ï¸ Error detectando capacidades del dispositivo:', error);
        }
    }

    /**
     * Cargar cache persistente desde localStorage
     */
    async loadPersistentCache() {
        try {
            const savedCache = localStorage.getItem('photo_cache_persistent');
            if (savedCache) {
                const parsed = JSON.parse(savedCache);
                
                // Verificar formato y validez
                if (parsed.version === '1.0' && parsed.data) {
                    let validEntries = 0;
                    const now = Date.now();
                    
                    for (const [key, entry] of Object.entries(parsed.data)) {
                        // Verificar TTL
                        if (!entry.expires || entry.expires > now) {
                            this.caches.persistent.set(key, entry);
                            validEntries++;
                        }
                    }
                    
                    console.log(`ğŸ’¾ Cache persistente cargado: ${validEntries} entradas vÃ¡lidas`);
                }
            }
            
        } catch (error) {
            console.warn('âš ï¸ Error cargando cache persistente:', error);
            // Limpiar cache corrupto
            localStorage.removeItem('photo_cache_persistent');
        }
    }

    /**
     * Configurar limpieza automÃ¡tica
     */
    setupAutomaticCleanup() {
        // Limpiar al inicio
        this.cleanup();
        
        // Configurar timer de limpieza
        this.cleanupTimer = setInterval(() => {
            this.cleanup();
        }, this.config.cleanupInterval);
        
        console.log(`ğŸ§¹ Limpieza automÃ¡tica configurada (cada ${this.config.cleanupInterval/1000/60} minutos)`);
    }

    /**
     * Configurar event listeners
     */
    setupEventListeners() {
        // Limpiar al cerrar la pÃ¡gina
        window.addEventListener('beforeunload', () => {
            this.savePersistentCache();
            this.cleanup();
        });
        
        // Limpiar en caso de errores de memoria
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('memory')) {
                console.log('ğŸš¨ Error de memoria detectado, ejecutando limpieza de emergencia');
                this.emergencyCleanup();
            }
        });
    }

    /**
     * Obtener foto desde cache (mÃ©todo principal)
     */
    async get(photoId, metadata = null) {
        try {
            if (!this.isInitialized) {
                await this.init();
            }
            
            const cacheKey = `photo_${photoId}`;
            console.log(`ğŸ” Buscando en cache: ${photoId}`);
            
            // Nivel 1: Cache en memoria (mÃ¡s rÃ¡pido)
            if (this.caches.memory.has(cacheKey)) {
                const entry = this.caches.memory.get(cacheKey);
                if (this.isEntryValid(entry)) {
                    this.stats.hits++;
                    entry.lastAccessed = Date.now();
                    console.log(`âœ… Cache hit (memoria): ${photoId}`);
                    return entry.data;
                } else {
                    this.caches.memory.delete(cacheKey);
                }
            }
            
            // Nivel 2: Cache de descargas (URLs blob)
            if (this.caches.download.has(cacheKey)) {
                const entry = this.caches.download.get(cacheKey);
                if (this.isEntryValid(entry) && await this.validateBlobUrl(entry.data)) {
                    this.stats.hits++;
                    entry.lastAccessed = Date.now();
                    
                    // Promover a cache en memoria
                    this.set(photoId, entry.data, 'memory', entry.ttl);
                    
                    console.log(`âœ… Cache hit (download): ${photoId}`);
                    return entry.data;
                } else {
                    this.caches.download.delete(cacheKey);
                }
            }
            
            // Nivel 3: Cache persistente
            if (this.caches.persistent.has(cacheKey)) {
                const entry = this.caches.persistent.get(cacheKey);
                if (this.isEntryValid(entry)) {
                    this.stats.hits++;
                    entry.lastAccessed = Date.now();
                    console.log(`âœ… Cache hit (persistente): ${photoId}`);
                    
                    // Si tiene URL, promover a cache de descarga
                    if (entry.data && typeof entry.data === 'string' && entry.data.startsWith('blob:')) {
                        this.set(photoId, entry.data, 'download', entry.ttl);
                    }
                    
                    return entry.data;
                } else {
                    this.caches.persistent.delete(cacheKey);
                }
            }
            
            // Cache miss
            this.stats.misses++;
            console.log(`âŒ Cache miss: ${photoId}`);
            return null;
            
        } catch (error) {
            console.error('âŒ Error obteniendo desde cache:', error);
            this.stats.misses++;
            return null;
        }
    }

    /**
     * Guardar en cache
     */
    set(photoId, data, level = 'auto', customTTL = null) {
        try {
            if (!this.isInitialized) return false;
            
            const cacheKey = `photo_${photoId}`;
            const ttl = customTTL || this.config.defaultTTL;
            const now = Date.now();
            
            const entry = {
                data: data,
                created: now,
                lastAccessed: now,
                expires: now + ttl,
                size: this.calculateEntrySize(data),
                ttl: ttl
            };
            
            // Determinar nivel automÃ¡ticamente si no se especifica
            if (level === 'auto') {
                if (typeof data === 'string' && data.startsWith('blob:')) {
                    level = 'download';
                } else if (entry.size < 1024 * 1024) { // < 1MB
                    level = 'memory';
                } else {
                    level = 'persistent';
                }
            }
            
            // Verificar espacio disponible
            if (!this.hasSpaceForEntry(entry, level)) {
                console.log(`ğŸ§¹ Limpiando ${level} cache para hacer espacio`);
                this.cleanupLevel(level);
                
                // Verificar de nuevo
                if (!this.hasSpaceForEntry(entry, level)) {
                    console.warn(`âš ï¸ No hay espacio suficiente en ${level} cache`);
                    return false;
                }
            }
            
            // Guardar en el nivel especificado
            this.caches[level].set(cacheKey, entry);
            this.updateMemoryStats();
            
            console.log(`ğŸ’¾ Guardado en cache (${level}): ${photoId} (${(entry.size/1024).toFixed(1)}KB)`);
            return true;
            
        } catch (error) {
            console.error('âŒ Error guardando en cache:', error);
            return false;
        }
    }

    /**
     * Verificar si una entrada es vÃ¡lida
     */
    isEntryValid(entry) {
        if (!entry) return false;
        
        const now = Date.now();
        
        // Verificar expiraciÃ³n
        if (entry.expires && entry.expires < now) {
            return false;
        }
        
        // Verificar datos
        if (!entry.data) {
            return false;
        }
        
        return true;
    }

    /**
     * Validar URL blob
     */
    async validateBlobUrl(url) {
        if (!url || !url.startsWith('blob:')) {
            return false;
        }
        
        try {
            const response = await fetch(url, { method: 'HEAD' });
            return response.ok;
        } catch (error) {
            return false;
        }
    }

    /**
     * Calcular tamaÃ±o de entrada
     */
    calculateEntrySize(data) {
        if (typeof data === 'string') {
            return data.length * 2; // AproximaciÃ³n para UTF-16
        } else if (data instanceof Blob) {
            return data.size;
        } else if (data && typeof data === 'object') {
            return JSON.stringify(data).length * 2;
        }
        return 0;
    }

    /**
     * Verificar si hay espacio para una entrada
     */
    hasSpaceForEntry(entry, level) {
        const currentSize = this.getCurrentLevelSize(level);
        const maxSize = this.getMaxLevelSize(level);
        
        return (currentSize + entry.size) <= maxSize;
    }

    /**
     * Obtener tamaÃ±o actual de un nivel
     */
    getCurrentLevelSize(level) {
        let size = 0;
        for (const entry of this.caches[level].values()) {
            size += entry.size || 0;
        }
        return size;
    }

    /**
     * Obtener tamaÃ±o mÃ¡ximo de un nivel
     */
    getMaxLevelSize(level) {
        switch (level) {
            case 'memory':
                return this.config.maxMemorySize;
            case 'persistent':
                return this.config.maxPersistentSize;
            case 'download':
                return this.config.maxDownloadCache * 1024 * 1024; // Convertir a bytes
            default:
                return 0;
        }
    }

    /**
     * Limpiar un nivel especÃ­fico usando algoritmo LRU
     */
    cleanupLevel(level, targetReduction = 0.3) {
        try {
            const cache = this.caches[level];
            const entries = Array.from(cache.entries());
            
            if (entries.length === 0) return;
            
            // Ordenar por Ãºltimo acceso (LRU)
            entries.sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);
            
            // Calcular cuÃ¡ntas entradas eliminar
            const targetCount = Math.floor(entries.length * targetReduction);
            const toRemove = entries.slice(0, targetCount);
            
            console.log(`ğŸ§¹ Limpiando ${level}: eliminando ${toRemove.length} entradas antiguas`);
            
            // Eliminar entradas
            for (const [key, entry] of toRemove) {
                // Limpiar URLs blob si es necesario
                if (entry.data && typeof entry.data === 'string' && entry.data.startsWith('blob:')) {
                    memoryManager.revokeObjectURL(entry.data);
                }
                
                cache.delete(key);
            }
            
            this.updateMemoryStats();
            
        } catch (error) {
            console.error(`âŒ Error limpiando ${level} cache:`, error);
        }
    }

    /**
     * Limpieza general
     */
    cleanup() {
        try {
            console.log('ğŸ§¹ Ejecutando limpieza general de cache...');
            
            const now = Date.now();
            let totalCleaned = 0;
            
            // Limpiar entradas expiradas en todos los niveles
            for (const [levelName, cache] of Object.entries(this.caches)) {
                const initialSize = cache.size;
                
                for (const [key, entry] of cache.entries()) {
                    if (!this.isEntryValid(entry)) {
                        // Limpiar URL blob si es necesario
                        if (entry.data && typeof entry.data === 'string' && entry.data.startsWith('blob:')) {
                            memoryManager.revokeObjectURL(entry.data);
                        }
                        
                        cache.delete(key);
                        totalCleaned++;
                    }
                }
                
                const cleaned = initialSize - cache.size;
                if (cleaned > 0) {
                    console.log(`ğŸ—‘ï¸ ${levelName}: ${cleaned} entradas expiradas eliminadas`);
                }
            }
            
            // Verificar lÃ­mites de tamaÃ±o
            for (const level of ['memory', 'persistent', 'download']) {
                const currentSize = this.getCurrentLevelSize(level);
                const maxSize = this.getMaxLevelSize(level);
                
                if (currentSize > maxSize * 0.9) { // Si estÃ¡ al 90% de capacidad
                    this.cleanupLevel(level, 0.2); // Limpiar 20%
                }
            }
            
            this.updateMemoryStats();
            this.stats.cleanups++;
            this.stats.lastCleanup = now;
            
            if (totalCleaned > 0) {
                console.log(`âœ… Limpieza completada: ${totalCleaned} entradas eliminadas`);
                addDebugLog(`ğŸ§¹ Cache limpiado: ${totalCleaned} entradas`, 'info');
            }
            
        } catch (error) {
            console.error('âŒ Error en limpieza general:', error);
        }
    }

    /**
     * Limpieza de emergencia
     */
    emergencyCleanup() {
        try {
            console.log('ğŸš¨ Ejecutando limpieza de emergencia...');
            
            // Limpiar agresivamente cache en memoria
            this.cleanupLevel('memory', 0.8);
            
            // Limpiar cache de descargas
            this.cleanupLevel('download', 0.6);
            
            // Forzar garbage collection si estÃ¡ disponible
            if (window.gc) {
                window.gc();
            }
            
            addDebugLog('ğŸš¨ Limpieza de emergencia ejecutada', 'warning');
            
        } catch (error) {
            console.error('âŒ Error en limpieza de emergencia:', error);
        }
    }

    /**
     * Actualizar estadÃ­sticas de memoria
     */
    updateMemoryStats() {
        this.stats.memoryUsed = this.getCurrentLevelSize('memory');
    }

    /**
     * Guardar cache persistente
     */
    savePersistentCache() {
        try {
            if (this.caches.persistent.size === 0) return;
            
            const cacheData = {
                version: '1.0',
                saved: Date.now(),
                data: Object.fromEntries(this.caches.persistent.entries())
            };
            
            localStorage.setItem('photo_cache_persistent', JSON.stringify(cacheData));
            console.log(`ğŸ’¾ Cache persistente guardado: ${this.caches.persistent.size} entradas`);
            
        } catch (error) {
            console.warn('âš ï¸ Error guardando cache persistente:', error);
        }
    }

    /**
     * Obtener estadÃ­sticas del cache
     */
    getStats() {
        return {
            ...this.stats,
            hitRate: this.stats.hits / (this.stats.hits + this.stats.misses) * 100,
            levels: {
                memory: {
                    entries: this.caches.memory.size,
                    size: this.getCurrentLevelSize('memory'),
                    maxSize: this.config.maxMemorySize
                },
                persistent: {
                    entries: this.caches.persistent.size,
                    size: this.getCurrentLevelSize('persistent'),
                    maxSize: this.config.maxPersistentSize
                },
                download: {
                    entries: this.caches.download.size,
                    size: this.getCurrentLevelSize('download'),
                    maxSize: this.getMaxLevelSize('download')
                }
            }
        };
    }

    /**
     * Destructor
     */
    destroy() {
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
        }
        
        this.savePersistentCache();
        this.cleanup();
        
        console.log('ğŸ—„ï¸ CacheManager destruido');
    }
}

// Instancia global del gestor de cache
let globalCacheManager = null;

/**
 * Inicializar sistema de cache global
 */
async function initCacheSystem() {
    try {
        if (globalCacheManager) {
            console.log('âœ… Sistema de cache ya inicializado');
            return globalCacheManager;
        }
        
        console.log('ğŸ—„ï¸ Inicializando sistema de cache global...');
        
        globalCacheManager = new CacheManager();
        const success = await globalCacheManager.init();
        
        if (success) {
            console.log('âœ… Sistema de cache inicializado correctamente');
            addDebugLog('âœ… Sistema de cache inicializado', 'success');
            
            // Integrar con el sistema existente
            integrateWithExistingSystem();
            
            return globalCacheManager;
        } else {
            throw new Error('Error en inicializaciÃ³n');
        }
        
    } catch (error) {
        console.error('âŒ Error inicializando sistema de cache:', error);
        addDebugLog(`âŒ Error cache system: ${error.message}`, 'error');
        return null;
    }
}

/**
 * Integrar con sistema existente
 */
function integrateWithExistingSystem() {
    try {
        // Migrar githubStorage.downloadCache existente al nuevo sistema
        if (githubStorage && githubStorage.downloadCache) {
            console.log('ğŸ”„ Migrando cache existente al nuevo sistema...');
            
            let migratedCount = 0;
            for (const [key, url] of githubStorage.downloadCache.entries()) {
                if (key.startsWith('photo_cache_')) {
                    const photoId = key.replace('photo_cache_', '');
                    globalCacheManager.set(photoId, url, 'download');
                    migratedCount++;
                }
            }
            
            console.log(`âœ… ${migratedCount} entradas migradas al nuevo sistema de cache`);
        }
        
    } catch (error) {
        console.error('âŒ Error integrando con sistema existente:', error);
    }
}


// ===============================================
// ğŸš€ SISTEMA DE PRE-CARGA INTELIGENTE
// ===============================================

/**
 * Sistema de pre-carga predictiva para fotos
 * Pre-carga fotos que probablemente el usuario verÃ¡ pronto
 */
class PrefetchSystem {
    constructor(cacheManager) {
        this.cacheManager = cacheManager;
        this.config = {
            maxConcurrentDownloads: 2,      // MÃ¡ximo 2 descargas simultÃ¡neas
            prefetchRadius: 2,              // Pre-cargar 2 fotos antes y despuÃ©s
            minBandwidth: 1000,             // MÃ­nimo 1MB/s para pre-cargar
            maxPrefetchSize: 10 * 1024 * 1024, // MÃ¡ximo 10MB por sesiÃ³n
            intelligentDelay: 2000,         // Esperar 2s antes de pre-cargar
            priorityThreshold: 5000         // Prioridad alta si foto > 5MB
        };
        
        this.state = {
            isActive: false,
            currentDownloads: 0,
            totalPrefetched: 0,
            sessionSize: 0,
            lastActivity: Date.now(),
            bandwidthEstimate: 0,
            patterns: new Map()             // Patrones de navegaciÃ³n del usuario
        };
        
        this.downloadQueue = [];
        this.activeDownloads = new Set();
        this.prefetchTimer = null;
    }

    /**
     * Inicializar sistema de pre-carga
     */
    async init() {
        try {
            console.log('ğŸš€ Inicializando sistema de pre-carga...');
            
            // Detectar velocidad de conexiÃ³n
            await this.detectBandwidth();
            
            // Configurar observadores
            this.setupObservers();
            
            // Cargar patrones guardados
            this.loadUserPatterns();
            
            this.state.isActive = true;
            console.log('âœ… Sistema de pre-carga inicializado');
            addDebugLog('âœ… Prefetch system iniciado', 'success');
            
            return true;
            
        } catch (error) {
            console.error('âŒ Error inicializando pre-carga:', error);
            addDebugLog(`âŒ Error prefetch: ${error.message}`, 'error');
            return false;
        }
    }

    /**
     * Detectar ancho de banda disponible
     */
    async detectBandwidth() {
        try {
            if (navigator.connection) {
                const connection = navigator.connection;
                this.state.bandwidthEstimate = connection.downlink * 1000 * 1000; // Convertir a bytes/s
                
                console.log(`ğŸ“¡ Ancho de banda estimado: ${(this.state.bandwidthEstimate / 1000 / 1000).toFixed(1)} Mbps`);
                
                // Ajustar configuraciÃ³n segÃºn el ancho de banda
                if (this.state.bandwidthEstimate < this.config.minBandwidth) {
                    this.config.maxConcurrentDownloads = 1;
                    this.config.prefetchRadius = 1;
                    console.log('ğŸ“¡ ConexiÃ³n lenta detectada, reduciendo pre-carga');
                }
                
                // Monitorear cambios de conexiÃ³n
                connection.addEventListener('change', () => {
                    this.detectBandwidth();
                });
                
            } else {
                // Fallback: estimar con una descarga de prueba
                await this.estimateBandwidthWithTest();
            }
            
        } catch (error) {
            console.warn('âš ï¸ Error detectando ancho de banda:', error);
            this.state.bandwidthEstimate = this.config.minBandwidth; // Valor por defecto
        }
    }

    /**
     * Estimar ancho de banda con descarga de prueba
     */
    async estimateBandwidthWithTest() {
        try {
            const testUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==';
            const startTime = performance.now();
            
            await fetch(testUrl);
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            // EstimaciÃ³n bÃ¡sica
            this.state.bandwidthEstimate = duration < 100 ? this.config.minBandwidth * 2 : this.config.minBandwidth;
            
        } catch (error) {
            this.state.bandwidthEstimate = this.config.minBandwidth;
        }
    }

    /**
     * Configurar observadores de actividad
     */
    setupObservers() {
        // Observar apertura del visor de fotos
        const originalOpenPhotoViewer = window.openPhotoViewer;
        if (originalOpenPhotoViewer) {
            window.openPhotoViewer = async (...args) => {
                const result = await originalOpenPhotoViewer.apply(this, args);
                this.onPhotoViewerOpened(args[0], args[1]);
                return result;
            };
        }
        
        // Observar navegaciÃ³n en galerÃ­a
        const originalNavigateGallery = window.navigateGallery;
        if (originalNavigateGallery) {
            window.navigateGallery = (...args) => {
                const result = originalNavigateGallery.apply(this, args);
                this.onGalleryNavigation(args[0]);
                return result;
            };
        }
        
        // Observar actividad del usuario
        ['click', 'scroll', 'keydown'].forEach(event => {
            document.addEventListener(event, () => {
                this.state.lastActivity = Date.now();
            }, { passive: true });
        });
    }

    /**
     * Evento: Visor de fotos abierto
     */
    onPhotoViewerOpened(photoData, startIndex = 0) {
        try {
            console.log('ğŸ“¸ Visor abierto, iniciando anÃ¡lisis de pre-carga...');
            
            let photosArray = Array.isArray(photoData) ? photoData : [photoData];
            
            // Registrar patrÃ³n de acceso
            this.recordAccessPattern(startIndex, photosArray.length);
            
            // Programar pre-carga despuÃ©s de un breve delay
            setTimeout(() => {
                this.schedulePrefetch(photosArray, startIndex);
            }, this.config.intelligentDelay);
            
        } catch (error) {
            console.error('âŒ Error en evento de visor abierto:', error);
        }
    }

    /**
     * Evento: NavegaciÃ³n en galerÃ­a
     */
    onGalleryNavigation(direction) {
        try {
            const currentIndex = currentPhotoViewer.currentIndex;
            const totalPhotos = currentPhotoViewer.photos.length;
            
            console.log(`ğŸ§­ NavegaciÃ³n detectada: direcciÃ³n ${direction}, Ã­ndice ${currentIndex}`);
            
            // Registrar patrÃ³n de navegaciÃ³n
            this.recordNavigationPattern(direction, currentIndex, totalPhotos);
            
            // Re-calcular pre-carga basado en nueva posiciÃ³n
            this.schedulePrefetch(currentPhotoViewer.photos, currentIndex);
            
        } catch (error) {
            console.error('âŒ Error en evento de navegaciÃ³n:', error);
        }
    }

    /**
     * Registrar patrÃ³n de acceso del usuario
     */
    recordAccessPattern(startIndex, totalPhotos) {
        const pattern = {
            startIndex: startIndex,
            totalPhotos: totalPhotos,
            timestamp: Date.now(),
            sessionId: this.getSessionId()
        };
        
        const key = `access_${totalPhotos}`;
        if (!this.state.patterns.has(key)) {
            this.state.patterns.set(key, []);
        }
        
        this.state.patterns.get(key).push(pattern);
        
        // Mantener solo los Ãºltimos 50 patrones por tipo
        if (this.state.patterns.get(key).length > 50) {
            this.state.patterns.get(key).shift();
        }
    }

    /**
     * Registrar patrÃ³n de navegaciÃ³n
     */
    recordNavigationPattern(direction, currentIndex, totalPhotos) {
        const pattern = {
            direction: direction,
            fromIndex: currentIndex - direction,
            toIndex: currentIndex,
            totalPhotos: totalPhotos,
            timestamp: Date.now()
        };
        
        const key = 'navigation';
        if (!this.state.patterns.has(key)) {
            this.state.patterns.set(key, []);
        }
        
        this.state.patterns.get(key).push(pattern);
        
        // Mantener solo los Ãºltimos 100 patrones de navegaciÃ³n
        if (this.state.patterns.get(key).length > 100) {
            this.state.patterns.get(key).shift();
        }
    }

    /**
     * Programar pre-carga inteligente
     */
    schedulePrefetch(photos, currentIndex) {
        try {
            if (!this.state.isActive || !this.shouldPrefetch()) {
                return;
            }
            
            console.log(`ğŸ”® Programando pre-carga para Ã­ndice ${currentIndex} de ${photos.length} fotos`);
            
            // Cancelar pre-carga anterior
            this.cancelCurrentPrefetch();
            
            // Calcular fotos a pre-cargar usando IA predictiva
            const toPreload = this.calculatePrefetchTargets(photos, currentIndex);
            
            if (toPreload.length > 0) {
                console.log(`ğŸ¯ Objetivos de pre-carga: ${toPreload.map(t => t.index).join(', ')}`);
                this.startPrefetch(toPreload);
            }
            
        } catch (error) {
            console.error('âŒ Error programando pre-carga:', error);
        }
    }

    /**
     * Calcular objetivos de pre-carga usando algoritmos predictivos
     */
    calculatePrefetchTargets(photos, currentIndex) {
        const targets = [];
        
        // Algoritmo 1: Pre-carga basada en proximidad
        const proximityTargets = this.getProximityTargets(photos, currentIndex);
        targets.push(...proximityTargets);
        
        // Algoritmo 2: Pre-carga basada en patrones de navegaciÃ³n
        const patternTargets = this.getPatternBasedTargets(photos, currentIndex);
        targets.push(...patternTargets);
        
        // Algoritmo 3: Pre-carga basada en metadatos (fotos relacionadas)
        const relatedTargets = this.getRelatedTargets(photos, currentIndex);
        targets.push(...relatedTargets);
        
        // Eliminar duplicados y ordenar por prioridad
        const uniqueTargets = this.deduplicateAndPrioritize(targets);
        
        // Limitar segÃºn configuraciÃ³n
        return uniqueTargets.slice(0, this.config.prefetchRadius * 2);
    }

    /**
     * Obtener objetivos basados en proximidad
     */
    getProximityTargets(photos, currentIndex) {
        const targets = [];
        
        // Pre-cargar fotos adyacentes
        for (let i = 1; i <= this.config.prefetchRadius; i++) {
            // Foto siguiente
            if (currentIndex + i < photos.length) {
                targets.push({
                    index: currentIndex + i,
                    photo: photos[currentIndex + i],
                    priority: 100 - (i * 10), // Prioridad decreciente
                    reason: 'proximity_next'
                });
            }
            
            // Foto anterior
            if (currentIndex - i >= 0) {
                targets.push({
                    index: currentIndex - i,
                    photo: photos[currentIndex - i],
                    priority: 90 - (i * 10), // Ligeramente menor prioridad para anteriores
                    reason: 'proximity_prev'
                });
            }
        }
        
        return targets;
    }

    /**
     * Obtener objetivos basados en patrones de navegaciÃ³n
     */
    getPatternBasedTargets(photos, currentIndex) {
        const targets = [];
        
        try {
            const navPatterns = this.state.patterns.get('navigation') || [];
            
            if (navPatterns.length > 10) { // Suficientes datos para anÃ¡lisis
                // Analizar tendencia de direcciÃ³n
                const recentPatterns = navPatterns.slice(-20);
                const forwardCount = recentPatterns.filter(p => p.direction > 0).length;
                const backwardCount = recentPatterns.filter(p => p.direction < 0).length;
                
                // Si el usuario tiende a ir hacia adelante
                if (forwardCount > backwardCount * 1.5) {
                    for (let i = 1; i <= this.config.prefetchRadius + 1; i++) {
                        if (currentIndex + i < photos.length) {
                            targets.push({
                                index: currentIndex + i,
                                photo: photos[currentIndex + i],
                                priority: 80 + (i <= 2 ? 10 : 0), // Prioridad extra para los primeros
                                reason: 'pattern_forward'
                            });
                        }
                    }
                }
                
                // Si el usuario tiende a ir hacia atrÃ¡s
                if (backwardCount > forwardCount * 1.5) {
                    for (let i = 1; i <= this.config.prefetchRadius + 1; i++) {
                        if (currentIndex - i >= 0) {
                            targets.push({
                                index: currentIndex - i,
                                photo: photos[currentIndex - i],
                                priority: 75 + (i <= 2 ? 10 : 0),
                                reason: 'pattern_backward'
                            });
                        }
                    }
                }
            }
            
        } catch (error) {
            console.warn('âš ï¸ Error analizando patrones:', error);
        }
        
        return targets;
    }

    /**
     * Obtener objetivos basados en relaciÃ³n (misma ubicaciÃ³n, mismo tipo, etc.)
     */
    getRelatedTargets(photos, currentIndex) {
        const targets = [];
        
        try {
            const currentPhoto = photos[currentIndex];
            if (!currentPhoto) return targets;
            
            // Buscar fotos de la misma ubicaciÃ³n
            for (let i = 0; i < photos.length; i++) {
                if (i === currentIndex) continue;
                
                const photo = photos[i];
                if (photo.locationId && photo.locationId === currentPhoto.locationId) {
                    targets.push({
                        index: i,
                        photo: photo,
                        priority: 60,
                        reason: 'same_location'
                    });
                }
                
                // Fotos del mismo tipo de incidencia
                if (photo.incidentType && photo.incidentType === currentPhoto.incidentType) {
                    targets.push({
                        index: i,
                        photo: photo,
                        priority: 55,
                        reason: 'same_incident_type'
                    });
                }
                
                // Fotos de la misma planta
                if (photo.plant && photo.plant === currentPhoto.plant) {
                    targets.push({
                        index: i,
                        photo: photo,
                        priority: 50,
                        reason: 'same_plant'
                    });
                }
            }
            
        } catch (error) {
            console.warn('âš ï¸ Error analizando fotos relacionadas:', error);
        }
        
        return targets;
    }

    /**
     * Eliminar duplicados y priorizar objetivos
     */
    deduplicateAndPrioritize(targets) {
        // Eliminar duplicados por Ã­ndice
        const uniqueMap = new Map();
        
        for (const target of targets) {
            const existing = uniqueMap.get(target.index);
            if (!existing || target.priority > existing.priority) {
                uniqueMap.set(target.index, target);
            }
        }
        
        // Convertir a array y ordenar por prioridad
        return Array.from(uniqueMap.values()).sort((a, b) => b.priority - a.priority);
    }

    /**
     * Verificar si deberÃ­a pre-cargar
     */
    shouldPrefetch() {
        // Verificar si el usuario estÃ¡ activo
        if (Date.now() - this.state.lastActivity > 30000) { // 30 segundos de inactividad
            return false;
        }
        
        // Verificar ancho de banda
        if (this.state.bandwidthEstimate < this.config.minBandwidth) {
            return false;
        }
        
        // Verificar lÃ­mites de sesiÃ³n
        if (this.state.sessionSize > this.config.maxPrefetchSize) {
            return false;
        }
        
        // Verificar nÃºmero de descargas activas
        if (this.state.currentDownloads >= this.config.maxConcurrentDownloads) {
            return false;
        }
        
        return true;
    }

    /**
     * Iniciar pre-carga de objetivos
     */
    async startPrefetch(targets) {
        try {
            for (const target of targets) {
                if (!this.shouldPrefetch()) break;
                
                // Verificar si ya estÃ¡ en cache
                const cached = await this.cacheManager.get(target.photo.id);
                if (cached) {
                    console.log(`âœ… Ya en cache: foto ${target.index} (${target.reason})`);
                    continue;
                }
                
                // Agregar a cola de descarga
                this.downloadQueue.push(target);
            }
            
            // Procesar cola
            this.processDownloadQueue();
            
        } catch (error) {
            console.error('âŒ Error iniciando pre-carga:', error);
        }
    }

    /**
     * Procesar cola de descargas
     */
    async processDownloadQueue() {
        while (this.downloadQueue.length > 0 && this.shouldPrefetch()) {
            const target = this.downloadQueue.shift();
            
            try {
                await this.prefetchPhoto(target);
            } catch (error) {
                console.warn(`âš ï¸ Error pre-cargando foto ${target.index}:`, error);
            }
        }
    }

    /**
     * Pre-cargar una foto especÃ­fica
     */
    async prefetchPhoto(target) {
        try {
            const photoId = target.photo.id;
            
            if (this.activeDownloads.has(photoId)) {
                return; // Ya se estÃ¡ descargando
            }
            
            this.activeDownloads.add(photoId);
            this.state.currentDownloads++;
            
            console.log(`ğŸ”„ Pre-cargando foto ${target.index}: ${photoId} (${target.reason})`);
            addDebugLog(`ğŸ”„ Prefetch: foto ${target.index}`, 'info');
            
            // Usar el sistema de descarga existente
            const photoUrl = await getPhotoUrl(target.photo);
            
            if (photoUrl) {
                // Guardar en cache
                this.cacheManager.set(photoId, photoUrl, 'download');
                
                // Actualizar estadÃ­sticas
                this.state.totalPrefetched++;
                this.state.sessionSize += target.photo.size || 1024 * 1024; // Estimar 1MB si no hay tamaÃ±o
                
                console.log(`âœ… Pre-carga exitosa: foto ${target.index}`);
                addDebugLog(`âœ… Prefetch exitoso: ${photoId}`, 'success');
            }
            
        } catch (error) {
            console.error('âŒ Error en pre-carga individual:', error);
            addDebugLog(`âŒ Error prefetch: ${error.message}`, 'error');
            
        } finally {
            this.activeDownloads.delete(target.photo.id);
            this.state.currentDownloads--;
        }
    }

    /**
     * Cancelar pre-carga actual
     */
    cancelCurrentPrefetch() {
        this.downloadQueue.length = 0;
        
        if (this.prefetchTimer) {
            clearTimeout(this.prefetchTimer);
            this.prefetchTimer = null;
        }
        
        console.log('ğŸ›‘ Pre-carga anterior cancelada');
    }

    /**
     * Obtener ID de sesiÃ³n
     */
    getSessionId() {
        if (!this.sessionId) {
            this.sessionId = Date.now().toString(36) + Math.random().toString(36).substr(2);
        }
        return this.sessionId;
    }

    /**
     * Cargar patrones de usuario guardados
     */
    loadUserPatterns() {
        try {
            const saved = localStorage.getItem('prefetch_patterns');
            if (saved) {
                const patterns = JSON.parse(saved);
                
                for (const [key, value] of Object.entries(patterns)) {
                    this.state.patterns.set(key, value);
                }
                
                console.log(`ğŸ“‹ Patrones de usuario cargados: ${this.state.patterns.size} tipos`);
            }
            
        } catch (error) {
            console.warn('âš ï¸ Error cargando patrones de usuario:', error);
        }
    }

    /**
     * Guardar patrones de usuario
     */
    saveUserPatterns() {
        try {
            const patterns = Object.fromEntries(this.state.patterns.entries());
            localStorage.setItem('prefetch_patterns', JSON.stringify(patterns));
            
        } catch (error) {
            console.warn('âš ï¸ Error guardando patrones de usuario:', error);
        }
    }

    /**
     * Obtener estadÃ­sticas del sistema de pre-carga
     */
    getStats() {
        return {
            isActive: this.state.isActive,
            totalPrefetched: this.state.totalPrefetched,
            sessionSize: this.state.sessionSize,
            currentDownloads: this.state.currentDownloads,
            queueLength: this.downloadQueue.length,
            bandwidthEstimate: this.state.bandwidthEstimate,
            patterns: {
                types: this.state.patterns.size,
                totalRecords: Array.from(this.state.patterns.values()).reduce((sum, arr) => sum + arr.length, 0)
            }
        };
    }

    /**
     * Destructor
     */
    destroy() {
        this.state.isActive = false;
        this.cancelCurrentPrefetch();
        this.saveUserPatterns();
        
        console.log('ğŸš€ PrefetchSystem destruido');
    }
}

// Instancia global del sistema de pre-carga
let globalPrefetchSystem = null;

/**
 * Inicializar sistema de pre-carga global
 */
async function initPrefetchSystem() {
    try {
        if (globalPrefetchSystem) {
            console.log('âœ… Sistema de pre-carga ya inicializado');
            return globalPrefetchSystem;
        }
        
        // Verificar que el cache manager estÃ© disponible
        if (!globalCacheManager) {
            await initCacheSystem();
        }
        
        if (!globalCacheManager) {
            throw new Error('Cache manager no disponible');
        }
        
        console.log('ğŸš€ Inicializando sistema de pre-carga global...');
        
        globalPrefetchSystem = new PrefetchSystem(globalCacheManager);
        const success = await globalPrefetchSystem.init();
        
        if (success) {
            console.log('âœ… Sistema de pre-carga inicializado correctamente');
            addDebugLog('âœ… Prefetch system inicializado', 'success');
            return globalPrefetchSystem;
        } else {
            throw new Error('Error en inicializaciÃ³n');
        }
        
    } catch (error) {
        console.error('âŒ Error inicializando sistema de pre-carga:', error);
        addDebugLog(`âŒ Error prefetch system: ${error.message}`, 'error');
        return null;
    }
}


// ===============================================
// ğŸ“Š ANÃLISIS Y MÃ‰TRICAS DE CACHE AVANZADO
// ===============================================

/**
 * Analizador de rendimiento y mÃ©tricas de cache
 * Proporciona insights detallados y optimizaciÃ³n automÃ¡tica
 */
class CacheAnalytics {
    constructor(cacheManager, prefetchSystem) {
        this.cacheManager = cacheManager;
        this.prefetchSystem = prefetchSystem;
        this.metrics = {
            sessions: [],
            performance: {
                avgLoadTime: 0,
                cacheEfficiency: 0,
                bandwidthSaved: 0,
                totalRequests: 0
            },
            patterns: {
                peakHours: new Map(),
                popularLocations: new Map(),
                deviceTypes: new Map()
            },
            recommendations: []
        };
        
        this.sessionStart = Date.now();
        this.loadTimes = [];
        this.requestLog = [];
    }

    /**
     * Inicializar sistema de anÃ¡lisis
     */
    init() {
        try {
            console.log('ğŸ“Š Inicializando sistema de anÃ¡lisis de cache...');
            
            // Cargar mÃ©tricas histÃ³ricas
            this.loadHistoricalMetrics();
            
            // Configurar interceptores de rendimiento
            this.setupPerformanceInterceptors();
            
            // Programar anÃ¡lisis periÃ³dico
            this.schedulePeriodicAnalysis();
            
            console.log('âœ… Sistema de anÃ¡lisis inicializado');
            addDebugLog('âœ… Cache analytics iniciado', 'success');
            
            return true;
            
        } catch (error) {
            console.error('âŒ Error inicializando anÃ¡lisis:', error);
            addDebugLog(`âŒ Error analytics: ${error.message}`, 'error');
            return false;
        }
    }

    /**
     * Configurar interceptores de rendimiento
     */
    setupPerformanceInterceptors() {
        // Interceptar getPhotoUrl para medir rendimiento
        const originalGetPhotoUrl = window.getPhotoUrl;
        if (originalGetPhotoUrl) {
            window.getPhotoUrl = async (...args) => {
                const startTime = performance.now();
                const photoId = args[0]?.id || 'unknown';
                
                try {
                    const result = await originalGetPhotoUrl.apply(this, args);
                    const loadTime = performance.now() - startTime;
                    
                    this.recordLoadTime(photoId, loadTime, !!result);
                    
                    return result;
                } catch (error) {
                    const loadTime = performance.now() - startTime;
                    this.recordLoadTime(photoId, loadTime, false);
                    throw error;
                }
            };
        }
        
        // Interceptar cache hits/misses
        this.interceptCacheOperations();
    }

    /**
     * Interceptar operaciones de cache
     */
    interceptCacheOperations() {
        if (!this.cacheManager) return;
        
        const originalGet = this.cacheManager.get.bind(this.cacheManager);
        this.cacheManager.get = async (...args) => {
            const startTime = performance.now();
            const photoId = args[0];
            
            const result = await originalGet(...args);
            const duration = performance.now() - startTime;
            
            this.recordCacheOperation(photoId, !!result, duration);
            
            return result;
        };
    }

    /**
     * Registrar tiempo de carga
     */
    recordLoadTime(photoId, loadTime, success) {
        const record = {
            photoId,
            loadTime,
            success,
            timestamp: Date.now(),
            cached: loadTime < 100 // Asumimos que < 100ms es desde cache
        };
        
        this.loadTimes.push(record);
        this.requestLog.push(record);
        
        // Mantener solo Ãºltimos 1000 registros
        if (this.loadTimes.length > 1000) {
            this.loadTimes.shift();
        }
        
        if (this.requestLog.length > 1000) {
            this.requestLog.shift();
        }
        
        // Actualizar mÃ©tricas en tiempo real
        this.updatePerformanceMetrics();
        
        console.log(`ğŸ“Š Load time registrado: ${photoId} = ${loadTime.toFixed(1)}ms (${success ? 'exitoso' : 'fallo'})`);
    }

    /**
     * Registrar operaciÃ³n de cache
     */
    recordCacheOperation(photoId, hit, duration) {
        const operation = {
            photoId,
            hit,
            duration,
            timestamp: Date.now()
        };
        
        // Actualizar estadÃ­sticas de cache
        if (hit) {
            this.cacheManager.stats.hits++;
        } else {
            this.cacheManager.stats.misses++;
        }
        
        console.log(`ğŸ“‹ Cache operation: ${photoId} = ${hit ? 'HIT' : 'MISS'} (${duration.toFixed(1)}ms)`);
    }

    /**
     * Actualizar mÃ©tricas de rendimiento
     */
    updatePerformanceMetrics() {
        if (this.loadTimes.length === 0) return;
        
        // Calcular tiempo promedio de carga
        const totalTime = this.loadTimes.reduce((sum, record) => sum + record.loadTime, 0);
        this.metrics.performance.avgLoadTime = totalTime / this.loadTimes.length;
        
        // Calcular eficiencia de cache
        const cachedLoads = this.loadTimes.filter(record => record.cached).length;
        this.metrics.performance.cacheEfficiency = (cachedLoads / this.loadTimes.length) * 100;
        
        // Estimar ancho de banda ahorrado
        const avgPhotoSize = 2 * 1024 * 1024; // 2MB promedio
        this.metrics.performance.bandwidthSaved = cachedLoads * avgPhotoSize;
        
        this.metrics.performance.totalRequests = this.loadTimes.length;
    }

    /**
     * Analizar patrones de uso
     */
    analyzeUsagePatterns() {
        try {
            console.log('ğŸ” Analizando patrones de uso...');
            
            // Analizar horas pico
            this.analyzeRepeakHours();
            
            // Analizar ubicaciones populares
            this.analyzePopularLocations();
            
            // Analizar tipos de dispositivo
            this.analyzeDeviceTypes();
            
            // Generar recomendaciones
            this.generateRecommendations();
            
            console.log('âœ… AnÃ¡lisis de patrones completado');
            
        } catch (error) {
            console.error('âŒ Error analizando patrones:', error);
        }
    }

    /**
     * Analizar horas pico de uso
     */
    analyzeRepeakHours() {
        const hourCounts = new Map();
        
        for (const record of this.requestLog) {
            const hour = new Date(record.timestamp).getHours();
            hourCounts.set(hour, (hourCounts.get(hour) || 0) + 1);
        }
        
        this.metrics.patterns.peakHours = hourCounts;
        
        // Encontrar hora mÃ¡s activa
        let peakHour = 0;
        let maxCount = 0;
        for (const [hour, count] of hourCounts.entries()) {
            if (count > maxCount) {
                maxCount = count;
                peakHour = hour;
            }
        }
        
        console.log(`ğŸ“ˆ Hora pico detectada: ${peakHour}:00 (${maxCount} solicitudes)`);
    }

    /**
     * Analizar ubicaciones populares
     */
    analyzePopularLocations() {
        // Esta funciÃ³n requerirÃ­a acceso a datos de ubicaciÃ³n
        // Por ahora, simular anÃ¡lisis bÃ¡sico
        const locations = ['ENTRADA', 'ALMACEN_1', 'OFICINAS', 'PATIO'];
        
        locations.forEach(location => {
            const count = Math.floor(Math.random() * 50) + 1;
            this.metrics.patterns.popularLocations.set(location, count);
        });
    }

    /**
     * Analizar tipos de dispositivo
     */
    analyzeDeviceTypes() {
        const userAgent = navigator.userAgent;
        let deviceType = 'desktop';
        
        if (/Mobile|Android|iPhone|iPad/.test(userAgent)) {
            deviceType = 'mobile';
        } else if (/Tablet|iPad/.test(userAgent)) {
            deviceType = 'tablet';
        }
        
        const current = this.metrics.patterns.deviceTypes.get(deviceType) || 0;
        this.metrics.patterns.deviceTypes.set(deviceType, current + 1);
    }

    /**
     * Generar recomendaciones automÃ¡ticas
     */
    generateRecommendations() {
        this.metrics.recommendations = [];
        
        // RecomendaciÃ³n 1: Eficiencia de cache
        if (this.metrics.performance.cacheEfficiency < 60) {
            this.metrics.recommendations.push({
                type: 'cache_efficiency',
                priority: 'high',
                title: 'Baja eficiencia de cache',
                description: `La eficiencia de cache estÃ¡ en ${this.metrics.performance.cacheEfficiency.toFixed(1)}%. Considera aumentar el tamaÃ±o del cache o mejorar los algoritmos de pre-carga.`,
                action: 'Aumentar prefetchRadius o maxMemorySize'
            });
        }
        
        // RecomendaciÃ³n 2: Tiempo de carga
        if (this.metrics.performance.avgLoadTime > 2000) {
            this.metrics.recommendations.push({
                type: 'load_time',
                priority: 'medium',
                title: 'Tiempos de carga altos',
                description: `El tiempo promedio de carga es ${this.metrics.performance.avgLoadTime.toFixed(0)}ms. Considera optimizar la compresiÃ³n de imÃ¡genes.`,
                action: 'Revisar configuraciÃ³n de compresiÃ³n'
            });
        }
        
        // RecomendaciÃ³n 3: Ancho de banda
        const bandwidthSavedMB = this.metrics.performance.bandwidthSaved / (1024 * 1024);
        if (bandwidthSavedMB > 100) {
            this.metrics.recommendations.push({
                type: 'bandwidth_savings',
                priority: 'info',
                title: 'Excelente ahorro de ancho de banda',
                description: `Se han ahorrado ${bandwidthSavedMB.toFixed(1)}MB de ancho de banda gracias al cache.`,
                action: 'Mantener configuraciÃ³n actual'
            });
        }
        
        // RecomendaciÃ³n 4: Patrones de pre-carga
        if (this.prefetchSystem && this.prefetchSystem.getStats().totalPrefetched < 10) {
            this.metrics.recommendations.push({
                type: 'prefetch_usage',
                priority: 'medium',
                title: 'Poco uso de pre-carga',
                description: 'El sistema de pre-carga estÃ¡ siendo poco utilizado. Considera ajustar los algoritmos predictivos.',
                action: 'Revisar configuraciÃ³n de prefetch'
            });
        }
    }

    /**
     * Programar anÃ¡lisis periÃ³dico
     */
    schedulePeriodicAnalysis() {
        // AnÃ¡lisis cada 10 minutos
        setInterval(() => {
            this.analyzeUsagePatterns();
            this.optimizeAutomatically();
        }, 10 * 60 * 1000);
        
        // Guardar mÃ©tricas cada 5 minutos
        setInterval(() => {
            this.saveMetrics();
        }, 5 * 60 * 1000);
    }

    /**
     * OptimizaciÃ³n automÃ¡tica basada en mÃ©tricas
     */
    optimizeAutomatically() {
        try {
            console.log('ğŸ¯ Ejecutando optimizaciÃ³n automÃ¡tica...');
            
            let optimizationsApplied = 0;
            
            // OptimizaciÃ³n 1: Ajustar cache segÃºn eficiencia
            if (this.metrics.performance.cacheEfficiency < 50 && this.cacheManager) {
                this.cacheManager.config.maxMemorySize *= 1.2; // Aumentar 20%
                console.log('ğŸ“ˆ Cache en memoria aumentado debido a baja eficiencia');
                optimizationsApplied++;
            }
            
            // OptimizaciÃ³n 2: Ajustar pre-carga segÃºn patrones
            if (this.prefetchSystem && this.metrics.performance.avgLoadTime > 1500) {
                this.prefetchSystem.config.prefetchRadius = Math.min(
                    this.prefetchSystem.config.prefetchRadius + 1, 
                    4
                );
                console.log('ğŸ”® Radio de pre-carga aumentado debido a tiempos de carga altos');
                optimizationsApplied++;
            }
            
            // OptimizaciÃ³n 3: Ajustar limpieza segÃºn uso de memoria
            if (this.cacheManager && this.cacheManager.stats.memoryUsed > this.cacheManager.config.maxMemorySize * 0.9) {
                this.cacheManager.config.cleanupInterval = Math.max(
                    this.cacheManager.config.cleanupInterval * 0.8,
                    60000 // MÃ­nimo 1 minuto
                );
                console.log('ğŸ§¹ Intervalo de limpieza reducido debido a alto uso de memoria');
                optimizationsApplied++;
            }
            
            if (optimizationsApplied > 0) {
                console.log(`âœ… ${optimizationsApplied} optimizaciones automÃ¡ticas aplicadas`);
                addDebugLog(`ğŸ¯ ${optimizationsApplied} optimizaciones aplicadas`, 'success');
            }
            
        } catch (error) {
            console.error('âŒ Error en optimizaciÃ³n automÃ¡tica:', error);
        }
    }

    /**
     * Cargar mÃ©tricas histÃ³ricas
     */
    loadHistoricalMetrics() {
        try {
            const saved = localStorage.getItem('cache_analytics_metrics');
            if (saved) {
                const parsed = JSON.parse(saved);
                
                // Merge con mÃ©tricas actuales
                if (parsed.performance) {
                    Object.assign(this.metrics.performance, parsed.performance);
                }
                
                if (parsed.sessions && Array.isArray(parsed.sessions)) {
                    this.metrics.sessions = parsed.sessions.slice(-50); // Ãšltimas 50 sesiones
                }
                
                console.log('ğŸ“Š MÃ©tricas histÃ³ricas cargadas');
            }
        } catch (error) {
            console.warn('âš ï¸ Error cargando mÃ©tricas histÃ³ricas:', error);
        }
    }

    /**
     * Guardar mÃ©tricas
     */
    saveMetrics() {
        try {
            // Agregar sesiÃ³n actual
            const currentSession = {
                start: this.sessionStart,
                end: Date.now(),
                requests: this.requestLog.length,
                avgLoadTime: this.metrics.performance.avgLoadTime,
                cacheEfficiency: this.metrics.performance.cacheEfficiency
            };
            
            this.metrics.sessions.push(currentSession);
            
            // Mantener solo Ãºltimas 50 sesiones
            if (this.metrics.sessions.length > 50) {
                this.metrics.sessions = this.metrics.sessions.slice(-50);
            }
            
            // Guardar en localStorage
            const toSave = {
                performance: this.metrics.performance,
                sessions: this.metrics.sessions,
                savedAt: Date.now()
            };
            
            localStorage.setItem('cache_analytics_metrics', JSON.stringify(toSave));
            
        } catch (error) {
            console.warn('âš ï¸ Error guardando mÃ©tricas:', error);
        }
    }

    /**
     * Obtener reporte completo
     */
    getFullReport() {
        // Actualizar mÃ©tricas antes del reporte
        this.updatePerformanceMetrics();
        this.analyzeUsagePatterns();
        
        return {
            summary: {
                sessionDuration: Date.now() - this.sessionStart,
                totalRequests: this.metrics.performance.totalRequests,
                avgLoadTime: this.metrics.performance.avgLoadTime,
                cacheEfficiency: this.metrics.performance.cacheEfficiency,
                bandwidthSaved: this.metrics.performance.bandwidthSaved
            },
            cache: this.cacheManager ? this.cacheManager.getStats() : null,
            prefetch: this.prefetchSystem ? this.prefetchSystem.getStats() : null,
            patterns: {
                peakHours: Object.fromEntries(this.metrics.patterns.peakHours),
                popularLocations: Object.fromEntries(this.metrics.patterns.popularLocations),
                deviceTypes: Object.fromEntries(this.metrics.patterns.deviceTypes)
            },
            recommendations: this.metrics.recommendations,
            recentLoadTimes: this.loadTimes.slice(-20) // Ãšltimos 20 registros
        };
    }

    /**
     * Destructor
     */
    destroy() {
        this.saveMetrics();
        console.log('ğŸ“Š CacheAnalytics destruido');
    }
}

// Instancia global del sistema de anÃ¡lisis
let globalCacheAnalytics = null;

/**
 * Inicializar sistema completo de cache inteligente
 */
async function initAdvancedCacheSystem() {
    try {
        console.log('ğŸš€ Inicializando sistema completo de cache inteligente...');
        addDebugLog('ğŸš€ Iniciando sistema avanzado de cache', 'info');
        
        // Paso 1: Inicializar cache manager
        const cacheManager = await initCacheSystem();
        if (!cacheManager) {
            throw new Error('Error inicializando cache manager');
        }
        
        // Paso 2: Inicializar sistema de pre-carga
        const prefetchSystem = await initPrefetchSystem();
        // Nota: prefetchSystem puede ser null si falla, pero continuamos
        
        // Paso 3: Inicializar anÃ¡lisis
        globalCacheAnalytics = new CacheAnalytics(cacheManager, prefetchSystem);
        const analyticsSuccess = globalCacheAnalytics.init();
        
        if (!analyticsSuccess) {
            console.warn('âš ï¸ AnÃ¡lisis de cache no pudo inicializarse');
        }
        
        // Paso 4: Integrar con funciÃ³n de inicializaciÃ³n existente
        await integrateWithAutoBackup();
        
        console.log('âœ… Sistema completo de cache inteligente inicializado');
        addDebugLog('âœ… Sistema completo inicializado correctamente', 'success');
        
        // Mostrar resumen inicial
        if (globalCacheAnalytics) {
            setTimeout(() => {
                const report = globalCacheAnalytics.getFullReport();
                console.log('ğŸ“Š Reporte inicial del sistema:', report.summary);
            }, 2000);
        }
        
        return {
            cacheManager: globalCacheManager,
            prefetchSystem: globalPrefetchSystem,
            analytics: globalCacheAnalytics
        };
        
    } catch (error) {
        console.error('âŒ Error inicializando sistema completo de cache:', error);
        addDebugLog(`âŒ Error sistema completo: ${error.message}`, 'error');
        return null;
    }
}

/**
 * Integrar con sistema de backup automÃ¡tico existente
 */
async function integrateWithAutoBackup() {
    try {
        // Buscar la funciÃ³n initializeAutoBackup existente y modificarla
        const originalInitializeAutoBackup = window.initializeAutoBackup;
        if (originalInitializeAutoBackup) {
            window.initializeAutoBackup = async function() {
                // Ejecutar inicializaciÃ³n original
                const result = await originalInitializeAutoBackup.call(this);
                
                // Agregar inicializaciÃ³n del cache inteligente
                await initAdvancedCacheSystem();
                
                return result;
            };
            
            console.log('ğŸ”— IntegraciÃ³n con initializeAutoBackup completada');
        }
        
        // TambiÃ©n integrar con la funciÃ³n existente de getPhotoUrl para optimizaciÃ³n
        await optimizeExistingPhotoFunctions();
        
    } catch (error) {
        console.error('âŒ Error integrando con sistema existente:', error);
    }
}

/**
 * Optimizar funciones existentes de fotos
 */
async function optimizeExistingPhotoFunctions() {
    try {
        // La optimizaciÃ³n ya se hace en setupPerformanceInterceptors
        // AquÃ­ podemos agregar optimizaciones adicionales
        
        console.log('ğŸ¯ Optimizaciones de funciones de foto aplicadas');
        
    } catch (error) {
        console.error('âŒ Error optimizando funciones de foto:', error);
    }
}

/**
 * FunciÃ³n de utilidad para obtener reporte del sistema
 */
function getCacheSystemReport() {
    if (!globalCacheAnalytics) {
        return { error: 'Sistema de anÃ¡lisis no inicializado' };
    }
    
    return globalCacheAnalytics.getFullReport();
}

/**
 * FunciÃ³n de utilidad para mostrar estadÃ­sticas en debug panel
 */
function updateDebugCacheStats() {
    try {
        if (!globalCacheManager) return;
        
        const stats = globalCacheManager.getStats();
        
        // Actualizar elementos de debug si existen
        const cacheHitRate = document.getElementById('debugCacheHitRate');
        if (cacheHitRate) {
            cacheHitRate.textContent = `${stats.hitRate.toFixed(1)}%`;
        }
        
        const memoryUsage = document.getElementById('debugMemoryUsage');
        if (memoryUsage) {
            const usedMB = (stats.levels.memory.size / 1024 / 1024).toFixed(1);
            const maxMB = (stats.levels.memory.maxSize / 1024 / 1024).toFixed(1);
            memoryUsage.textContent = `${usedMB}/${maxMB} MB`;
        }
        
        const prefetchStats = document.getElementById('debugPrefetchStats');
        if (prefetchStats && globalPrefetchSystem) {
            const pStats = globalPrefetchSystem.getStats();
            prefetchStats.textContent = `${pStats.totalPrefetched} fotos`;
        }
        
    } catch (error) {
        console.error('âŒ Error actualizando stats de debug:', error);
    }
}

// Configurar actualizaciÃ³n periÃ³dica de stats en debug panel
setInterval(updateDebugCacheStats, 5000); // Cada 5 segundos


/**
 * Descargar y cachear foto desde GitHub
 */
/**
 * Descargar y cachear foto desde GitHub - VERSIÃ“N MEJORADA
 * REEMPLAZAR la funciÃ³n downloadAndCachePhoto existente CON ESTA
 */
async function downloadAndCachePhoto(photoMetadata) {
    try {
        console.log(`ğŸ“¥ Descargando foto desde GitHub: ${photoMetadata.id}`);
        addDebugLog(`ğŸ“¥ Descargando foto: ${photoMetadata.id}`, 'info');
        
        // Verificar si ya estÃ¡ en cache
        const cacheKey = `photo_cache_${photoMetadata.id}`;
        const cachedUrl = githubStorage.downloadCache.get(cacheKey);
        
        if (cachedUrl) {
            console.log('ğŸ“‹ Foto encontrada en cache');
            // Verificar que la URL cacheada sigue siendo vÃ¡lida
            const isValidCached = await validatePhotoUrl(cachedUrl);
            if (isValidCached) {
                return cachedUrl;
            } else {
                // Limpiar cache invÃ¡lido
                githubStorage.downloadCache.delete(cacheKey);
                memoryManager.revokeObjectURL(cachedUrl);
                console.log('ğŸ—‘ï¸ Cache invÃ¡lido limpiado');
            }
        }
        
        // Determinar URL de descarga
        let downloadUrl = null;
        
        if (photoMetadata.downloadUrl) {
            downloadUrl = photoMetadata.downloadUrl;
            console.log('ğŸ”— Usando downloadUrl directa');
        } else if (photoMetadata.githubPath) {
            downloadUrl = `${GITHUB_CONFIG.rawUrl}/${photoMetadata.githubPath}`;
            console.log('ğŸ”— Construyendo URL desde githubPath');
        } else {
            throw new Error('No hay informaciÃ³n de ubicaciÃ³n en GitHub');
        }
        
        console.log(`ğŸ“¡ Descargando desde: ${downloadUrl}`);
        
        // Realizar descarga con reintentos
        let lastError = null;
        const maxRetries = 3;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                console.log(`ğŸ“¥ Intento ${attempt}/${maxRetries} de descarga...`);
                
                const response = await fetch(downloadUrl, {
                    method: 'GET',
                    headers: {
                        'User-Agent': 'ControlRondas/1.0',
                        'Cache-Control': 'no-cache'
                    },
                    // Timeout de 30 segundos
                    signal: AbortSignal.timeout(30000)
                });
                
                if (response.ok) {
                    const blob = await response.blob();
                    
                    // Verificar que el blob es vÃ¡lido
                    if (blob.size === 0) {
                        throw new Error('Archivo descargado estÃ¡ vacÃ­o');
                    }
                    
                    console.log(`ğŸ“¦ Blob descargado: ${(blob.size / 1024).toFixed(1)}KB`);
                    
                    // Crear URL del objeto con gestiÃ³n de memoria
                    const objectUrl = memoryManager.createObjectURL(blob);
                    
                    if (!objectUrl) {
                        throw new Error('Error creando URL del objeto');
                    }
                    
                    // Guardar en cache
                    githubStorage.downloadCache.set(cacheKey, objectUrl);
                    
                    console.log(`âœ… Foto descargada y cacheada: ${photoMetadata.id}`);
                    addDebugLog(`âœ… Foto descargada exitosamente`, 'success');
                    
                    return objectUrl;
                    
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
            } catch (error) {
                lastError = error;
                console.warn(`âš ï¸ Intento ${attempt} fallÃ³:`, error.message);
                
                // Si no es el Ãºltimo intento, esperar antes de reintentar
                if (attempt < maxRetries) {
                    const delay = attempt * 1000; // 1s, 2s, 3s
                    console.log(`â³ Esperando ${delay}ms antes del siguiente intento...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        
        // Si llegamos aquÃ­, todos los intentos fallaron
        throw new Error(`Descarga fallÃ³ despuÃ©s de ${maxRetries} intentos. Ãšltimo error: ${lastError.message}`);
        
    } catch (error) {
        console.error('âŒ Error descargando foto:', error);
        addDebugLog(`âŒ Error descarga: ${error.message}`, 'error');
        
        // Limpiar cache si existe
        const cacheKey = `photo_cache_${photoMetadata.id}`;
        if (githubStorage.downloadCache.has(cacheKey)) {
            const oldUrl = githubStorage.downloadCache.get(cacheKey);
            memoryManager.revokeObjectURL(oldUrl);
            githubStorage.downloadCache.delete(cacheKey);
        }
        
        return null;
    }
}

/**
 * FunciÃ³n auxiliar para crear timeout personalizado (NUEVA FUNCIÃ“N)
 * Agregar esta funciÃ³n DESPUÃ‰S de downloadAndCachePhoto
 */
function createTimeoutSignal(timeoutMs) {
    const controller = new AbortController();
    setTimeout(() => controller.abort(), timeoutMs);
    return controller.signal;
}

/**
 * Obtener URL con proxy para bypass CORS
 * @param {string} originalUrl - URL original de GitHub Raw
 * @returns {string} URL con proxy
 */
function getProxyUrl(originalUrl) {
    try {
        const proxy = githubStorage.proxy;
        if (!proxy.enabled || proxy.urls.length === 0) {
            return originalUrl;
        }
        
        const proxyUrl = proxy.urls[proxy.currentIndex];
        const encodedUrl = encodeURIComponent(originalUrl);
        
        console.log(`ğŸ”— Usando proxy ${proxy.currentIndex + 1}/${proxy.urls.length}: ${proxyUrl}`);
        addDebugLog(`ğŸ”— Proxy activo: ${proxyUrl}`, 'info');
        
        return proxyUrl + encodedUrl;
        
    } catch (error) {
        console.error('âŒ Error configurando proxy:', error);
        addDebugLog(`âŒ Error proxy: ${error.message}`, 'error');
        return originalUrl;
    }
}

/**
 * Cambiar al siguiente proxy en caso de fallo
 */
function switchToNextProxy() {
    try {
        const proxy = githubStorage.proxy;
        proxy.currentIndex = (proxy.currentIndex + 1) % proxy.urls.length;
        
        console.log(`ğŸ”„ Cambiando a proxy ${proxy.currentIndex + 1}/${proxy.urls.length}`);
        addDebugLog(`ğŸ”„ Proxy cambiado: Ã­ndice ${proxy.currentIndex}`, 'warning');
        
    } catch (error) {
        console.error('âŒ Error cambiando proxy:', error);
    }
}

/**
 * Descargar con reintentos automÃ¡ticos de proxy
 * @param {string} url - URL original
 * @param {number} maxRetries - MÃ¡ximo de reintentos
 * @returns {Promise<Response>} Respuesta fetch
 */
async function fetchWithProxyRetries(url, maxRetries = 3) {
    let lastError = null;
    
    for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
            const proxyUrl = getProxyUrl(url);
            console.log(`ğŸ“¥ Intento ${attempt + 1}/${maxRetries}: ${proxyUrl.substring(0, 80)}...`);
            
            const response = await fetch(proxyUrl, {
                method: 'GET',
                headers: {
                    'User-Agent': 'ControlRondas/1.0'
                },
                signal: AbortSignal.timeout(15000) // 15 segundos timeout
            });
            
            if (response.ok) {
                console.log(`âœ… Descarga exitosa con proxy en intento ${attempt + 1}`);
                addDebugLog(`âœ… Descarga exitosa: intento ${attempt + 1}`, 'success');
                return response;
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
        } catch (error) {
            lastError = error;
            console.warn(`âš ï¸ Intento ${attempt + 1} fallÃ³:`, error.message);
            addDebugLog(`âš ï¸ Intento ${attempt + 1} fallÃ³: ${error.message}`, 'warning');
            
            // Cambiar proxy para siguiente intento
            if (attempt < maxRetries - 1) {
                switchToNextProxy();
                await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar 1s
            }
        }
    }
    
    throw new Error(`Todos los intentos fallaron. Ãšltimo error: ${lastError.message}`);
}


/**
 * Limpiar cache de descargas antiguas (FUNCIÃ“N MEJORADA)
 * Agregar esta funciÃ³n DESPUÃ‰S de createTimeoutSignal
 */
function cleanDownloadCache() {
    try {
        console.log('ğŸ§¹ Limpiando cache de descargas...');
        
        let cleanedCount = 0;
        githubStorage.downloadCache.forEach((url, key) => {
            try {
                // Intentar usar la URL para verificar si sigue siendo vÃ¡lida
                memoryManager.revokeObjectURL(url);
                cleanedCount++;
            } catch (error) {
                console.warn('âš ï¸ Error limpiando URL:', error);
            }
        });
        
        githubStorage.downloadCache.clear();
        
        console.log(`âœ… Cache limpiado: ${cleanedCount} URLs liberadas`);
        addDebugLog(`ğŸ§¹ Cache limpiado: ${cleanedCount} URLs`, 'info');
        
    } catch (error) {
        console.error('âŒ Error limpiando cache:', error);
        addDebugLog(`âŒ Error limpiando cache: ${error.message}`, 'error');
    }
}



/**
 * Obtener URL de foto (local o remota) - VERSIÃ“N MEJORADA
 * REEMPLAZAR la funciÃ³n getPhotoUrl existente CON ESTA
 */
async function getPhotoUrl(photoData) {
    try {
        console.log('ğŸ” Obteniendo URL para foto:', photoData.id || 'sin ID');
        addDebugLog(`ğŸ” Obteniendo foto: ${photoData.id}`, 'info');
        
        // PRIORIDAD 1: URL local vÃ¡lida (verificar primero)
        if (photoData.url) {
            console.log('ğŸ“‹ Verificando URL existente...');
            const isValidUrl = await validatePhotoUrlFixed(photoData.url);
            if (isValidUrl) {
                console.log('âœ… URL local vÃ¡lida');
                return photoData.url;
            } else {
                console.log('âŒ URL local invÃ¡lida, limpiando...');
                // Limpiar URL invÃ¡lida
                if (photoData.url.startsWith('blob:')) {
                    memoryManager.revokeObjectURL(photoData.url);
                }
                photoData.url = null;
            }
        }
        
        // PRIORIDAD 2: IndexedDB local
        if (photoData.id && isIndexedDBAvailable() && roundsDB) {
            console.log('ğŸ’¾ Buscando en IndexedDB...');
            try {
                const localPhoto = await roundsDB.getPhoto(photoData.id);
                if (localPhoto && localPhoto.blob) {
                    const url = memoryManager.createObjectURL(localPhoto.blob);
                    if (url) {
                        photoData.url = url; // Cache para siguientes usos
                        console.log('âœ… Foto encontrada en IndexedDB');
                        return url;
                    }
                }
            } catch (dbError) {
                console.log('âš ï¸ Error accediendo IndexedDB:', dbError.message);
                addDebugLog(`âš ï¸ Error IndexedDB: ${dbError.message}`, 'warning');
            }
        }
        
        // PRIORIDAD 3: Almacenamiento temporal con validaciÃ³n
        if (photoData.id && window.tempPhotos && window.tempPhotos.has(photoData.id)) {
            console.log('ğŸ“ Verificando almacenamiento temporal...');
            const tempData = window.tempPhotos.get(photoData.id);
            if (tempData && tempData.url) {
                const isValidTemp = await validatePhotoUrlFixed(tempData.url);
                if (isValidTemp) {
                    console.log('âœ… Foto encontrada en almacenamiento temporal');
                    return tempData.url;
                } else {
                    // Limpiar entrada temporal invÃ¡lida
                    if (tempData.url.startsWith('blob:')) {
                        memoryManager.revokeObjectURL(tempData.url);
                    }
                    window.tempPhotos.delete(photoData.id);
                    console.log('ğŸ—‘ï¸ Almacenamiento temporal invÃ¡lido limpiado');
                }
            }
        }
        
        // PRIORIDAD 4: Descargar desde GitHub con proxy (MEJORADO)
        if ((photoData.githubPath || photoData.downloadUrl) && githubStorage.connected) {
            console.log('â˜ï¸ Descargando desde GitHub con proxy...');
            try {
                const remoteUrl = await downloadWithProxySupport(photoData);
                if (remoteUrl) {
                    photoData.url = remoteUrl; // Cache para siguientes usos
                    console.log('âœ… Foto descargada desde GitHub');
                    addDebugLog('âœ… Foto descargada desde GitHub', 'success');
                    return remoteUrl;
                }
            } catch (downloadError) {
                console.error('âŒ Error descargando desde GitHub:', downloadError.message);
                addDebugLog(`âŒ Error descarga GitHub: ${downloadError.message}`, 'error');
            }
        }
        
        // PRIORIDAD 5: Buscar en metadata cacheada con proxy
        if (photoData.id) {
            console.log('ğŸ“‹ Buscando en metadata cacheada...');
            const cachedMetadata = getCachedPhotoMetadata(photoData.id);
            if (cachedMetadata && (cachedMetadata.githubPath || cachedMetadata.downloadUrl)) {
                console.log('ğŸ“¥ Intentando descarga desde metadata cacheada...');
                try {
                    const remoteUrl = await downloadWithProxySupport(cachedMetadata);
                    if (remoteUrl) {
                        photoData.url = remoteUrl;
                        console.log('âœ… Foto descargada desde metadata cacheada');
                        addDebugLog('âœ… Descarga desde metadata exitosa', 'success');
                        return remoteUrl;
                    }
                } catch (metaError) {
                    console.error('âŒ Error con metadata cacheada:', metaError.message);
                    addDebugLog(`âŒ Error metadata: ${metaError.message}`, 'error');
                }
            }
        }
        
        // Si llegamos aquÃ­, no pudimos obtener la foto
        console.warn('âš ï¸ No se pudo obtener URL para foto:', photoData.id);
        addDebugLog(`âš ï¸ Foto no disponible: ${photoData.id}`, 'warning');
        return null;
        
    } catch (error) {
        console.error('âŒ Error crÃ­tico obteniendo URL de foto:', error);
        addDebugLog(`âŒ Error crÃ­tico foto: ${error.message}`, 'error');
        return null;
    }
}

/**
 * Validar URL de foto con manejo robusto de errores
 * @param {string} url - URL a validar
 * @returns {Promise<boolean>} true si es vÃ¡lida
 */
async function validatePhotoUrlFixed(url) {
    if (!url || typeof url !== 'string') {
        return false;
    }
    
    try {
        if (url.startsWith('blob:')) {
            // Para URLs blob, intentar crear un fetch rÃ¡pido
            const response = await fetch(url, { 
                method: 'HEAD',
                signal: AbortSignal.timeout(2000) // 2 segundos mÃ¡ximo
            });
            return response.ok;
        } else if (url.startsWith('http')) {
            // Para URLs HTTP, asumir vÃ¡lidas (se validarÃ¡n al usarse)
            return true;
        }
        return false;
    } catch (error) {
        console.log('ğŸ” URL no vÃ¡lida detectada:', url.substring(0, 50) + '...');
        return false;
    }
}

/**
 * Descargar foto con soporte completo de proxy
 * @param {Object} photoMetadata - Metadatos de la foto
 * @returns {Promise<string>} URL de la foto descargada
 */
async function downloadWithProxySupport(photoMetadata) {
    try {
        console.log(`ğŸ“¥ Descargando con proxy: ${photoMetadata.id}`);
        
        // Verificar cache primero
        const cacheKey = `photo_cache_${photoMetadata.id}`;
        const cachedUrl = githubStorage.downloadCache.get(cacheKey);
        
        if (cachedUrl) {
            console.log('ğŸ“‹ Foto encontrada en cache');
            const isValidCached = await validatePhotoUrlFixed(cachedUrl);
            if (isValidCached) {
                return cachedUrl;
            } else {
                // Limpiar cache invÃ¡lido
                githubStorage.downloadCache.delete(cacheKey);
                if (cachedUrl.startsWith('blob:')) {
                    memoryManager.revokeObjectURL(cachedUrl);
                }
                console.log('ğŸ—‘ï¸ Cache invÃ¡lido limpiado');
            }
        }
        
        // Determinar URL de descarga
        let downloadUrl = null;
        
        if (photoMetadata.downloadUrl) {
            downloadUrl = photoMetadata.downloadUrl;
            console.log('ğŸ”— Usando downloadUrl directa');
        } else if (photoMetadata.githubPath) {
            downloadUrl = `${GITHUB_CONFIG.rawUrl}/${photoMetadata.githubPath}`;
            console.log('ğŸ”— Construyendo URL desde githubPath');
        } else {
            throw new Error('No hay informaciÃ³n de ubicaciÃ³n en GitHub');
        }
        
        console.log(`ğŸ“¡ URL a descargar: ${downloadUrl}`);
        
        // Descargar con reintentos automÃ¡ticos de proxy
        const response = await fetchWithProxyRetries(downloadUrl, 3);
        const blob = await response.blob();
        
        // Verificar que el blob es vÃ¡lido
        if (blob.size === 0) {
            throw new Error('Archivo descargado estÃ¡ vacÃ­o');
        }
        
        console.log(`ğŸ“¦ Blob descargado: ${(blob.size / 1024).toFixed(1)}KB`);
        
        // Crear URL del objeto con gestiÃ³n de memoria
        const objectUrl = memoryManager.createObjectURL(blob);
        
        if (!objectUrl) {
            throw new Error('Error creando URL del objeto');
        }
        
        // Guardar en cache
        githubStorage.downloadCache.set(cacheKey, objectUrl);
        
        console.log(`âœ… Foto descargada con proxy: ${photoMetadata.id}`);
        addDebugLog(`âœ… Descarga con proxy exitosa`, 'success');
        
        return objectUrl;
        
    } catch (error) {
        console.error('âŒ Error en descarga con proxy:', error);
        addDebugLog(`âŒ Error descarga proxy: ${error.message}`, 'error');
        
        // Limpiar cache si existe
        const cacheKey = `photo_cache_${photoMetadata.id}`;
        if (githubStorage.downloadCache.has(cacheKey)) {
            const oldUrl = githubStorage.downloadCache.get(cacheKey);
            if (oldUrl.startsWith('blob:')) {
                memoryManager.revokeObjectURL(oldUrl);
            }
            githubStorage.downloadCache.delete(cacheKey);
        }
        
        return null;
    }
}



/**
 * Sincronizar fotos desde GitHub
 */
async function syncPhotosFromGitHub() {
    try {
        if (!githubStorage.connected) {
            addDebugLog('âš ï¸ Sin conexiÃ³n GitHub para sincronizaciÃ³n', 'warning');
            return;
        }
        
        console.log('ğŸ”„ Sincronizando fotos desde GitHub...');
        addDebugLog('ğŸ”„ Iniciando sincronizaciÃ³n desde GitHub', 'info');
        
        // Obtener lista de archivos de metadata
        const metaResponse = await fetch(`${GITHUB_CONFIG.baseUrl}/contents/meta`, {
            headers: {
                'Authorization': `token ${GITHUB_CONFIG.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'ControlRondas/1.0'
            }
        });
        
        if (!metaResponse.ok) {
            throw new Error(`Error obteniendo metadata: ${metaResponse.status}`);
        }
        
        const metaFiles = await metaResponse.json();
        const photoMetaFiles = metaFiles.filter(file => 
            file.name.endsWith('.json') && 
            !file.name.includes('connectivity_test')
        );
        
        console.log(`ğŸ“‹ Encontrados ${photoMetaFiles.length} archivos de metadata`);
        
        let syncedPhotos = 0;
        
        // Procesar archivos de metadata
        for (const metaFile of photoMetaFiles.slice(0, 10)) { // Limitar a 10 por sincronizaciÃ³n
            try {
                const metaContent = await fetch(metaFile.download_url);
                const metadata = await metaContent.json();
                
                // Verificar si ya tenemos esta foto localmente
                const hasLocal = await checkIfPhotoExistsLocally(metadata.id);
                
                if (!hasLocal) {
                    // Pre-cargar metadata para acceso rÃ¡pido
                    await cachePhotoMetadata(metadata);
                    syncedPhotos++;
                }
                
            } catch (error) {
                console.error(`âŒ Error procesando metadata ${metaFile.name}:`, error);
            }
        }
        
        console.log(`âœ… SincronizaciÃ³n completada: ${syncedPhotos} fotos nuevas`);
        addDebugLog(`âœ… Sincronizadas ${syncedPhotos} fotos desde GitHub`, 'success');
        
        return syncedPhotos;
        
    } catch (error) {
        console.error('âŒ Error en sincronizaciÃ³n:', error);
        addDebugLog(`âŒ Error sincronizaciÃ³n: ${error.message}`, 'error');
        return 0;
    }
}

/**
 * Verificar si foto existe localmente
 */
async function checkIfPhotoExistsLocally(photoId) {
    try {
        // Verificar en IndexedDB
        if (isIndexedDBAvailable() && roundsDB) {
            const localPhoto = await roundsDB.getPhoto(photoId);
            if (localPhoto) return true;
        }
        
        // Verificar en almacenamiento temporal
        if (window.tempPhotos && window.tempPhotos.has(photoId)) {
            return true;
        }
        
        return false;
        
    } catch (error) {
        console.error('âŒ Error verificando foto local:', error);
        return false;
    }
}

/**
 * Cachear metadata de foto para acceso rÃ¡pido
 */
async function cachePhotoMetadata(metadata) {
    try {
        // Guardar metadata en localStorage para acceso rÃ¡pido
        const cachedMetadata = JSON.parse(localStorage.getItem('cached_photo_metadata') || '{}');
        cachedMetadata[metadata.id] = {
            ...metadata,
            cachedAt: new Date().toISOString()
        };
        
        // Mantener solo Ãºltimas 100 entradas
        const entries = Object.entries(cachedMetadata);
        if (entries.length > 100) {
            const sorted = entries.sort((a, b) => 
                new Date(b[1].cachedAt) - new Date(a[1].cachedAt)
            );
            const trimmed = Object.fromEntries(sorted.slice(0, 100));
            localStorage.setItem('cached_photo_metadata', JSON.stringify(trimmed));
        } else {
            localStorage.setItem('cached_photo_metadata', JSON.stringify(cachedMetadata));
        }
        
        console.log(`ğŸ“‹ Metadata cacheada para foto: ${metadata.id}`);
        
    } catch (error) {
        console.error('âŒ Error cacheando metadata:', error);
    }
}

/**
 * Obtener metadata de foto desde cache
 */
function getCachedPhotoMetadata(photoId) {
    try {
        const cachedMetadata = JSON.parse(localStorage.getItem('cached_photo_metadata') || '{}');
        return cachedMetadata[photoId] || null;
    } catch (error) {
        console.error('âŒ Error obteniendo metadata desde cache:', error);
        return null;
    }
}

/**
 * Limpiar cache de fotos antiguas con optimizaciÃ³n inteligente
 */
function cleanPhotoCache() {
    try {
        console.log('ğŸ§¹ Iniciando limpieza inteligente de cache...');
        addDebugLog('ğŸ§¹ Limpieza de cache iniciada', 'info');
        
        let cleanedUrls = 0;
        let cleanedMetadata = 0;
        
        // PASO 1: Limpiar URLs de objeto que pueden estar en memoria
        const urlsArray = Array.from(githubStorage.downloadCache.entries());
        urlsArray.forEach(([key, url]) => {
            try {
                if (url && url.startsWith('blob:')) {
                    memoryManager.revokeObjectURL(url);
                    cleanedUrls++;
                }
            } catch (error) {
                // Silenciar errores de URLs ya liberadas
            }
        });
        
        githubStorage.downloadCache.clear();
        
        // PASO 2: Limpiar metadata antigua (mÃ¡s de 7 dÃ­as) de forma inteligente
        try {
            const cachedMetadata = JSON.parse(localStorage.getItem('cached_photo_metadata') || '{}');
            const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
            const cleaned = {};
            
            Object.entries(cachedMetadata).forEach(([id, metadata]) => {
                if (metadata.cachedAt && new Date(metadata.cachedAt) > weekAgo) {
                    cleaned[id] = metadata;
                } else {
                    cleanedMetadata++;
                }
            });
            
            localStorage.setItem('cached_photo_metadata', JSON.stringify(cleaned));
            
        } catch (metadataError) {
            console.warn('âš ï¸ Error limpiando metadata, recreando cache:', metadataError.message);
            localStorage.setItem('cached_photo_metadata', '{}');
            cleanedMetadata = -1; // Indicar reset completo
        }
        
        // PASO 3: Limpiar tempPhotos expiradas
        let cleanedTemp = 0;
        if (window.tempPhotos && window.tempPhotos.size > 0) {
            const tempArray = Array.from(window.tempPhotos.entries());
            const hourAgo = new Date(Date.now() - 60 * 60 * 1000); // 1 hora
            
            tempArray.forEach(([id, data]) => {
                if (data.timestamp && new Date(data.timestamp) < hourAgo) {
                    if (data.url && data.url.startsWith('blob:')) {
                        memoryManager.revokeObjectURL(data.url);
                    }
                    window.tempPhotos.delete(id);
                    cleanedTemp++;
                }
            });
        }
        
        // PASO 4: Ejecutar limpieza general de memoria
        memoryManager.cleanup();
        
        console.log(`âœ… Limpieza completada: ${cleanedUrls} URLs, ${cleanedMetadata >= 0 ? cleanedMetadata : 'reset'} metadata, ${cleanedTemp} temporales`);
        addDebugLog(`âœ… Cache limpiado: ${cleanedUrls + cleanedTemp} elementos`, 'success');
        
    } catch (error) {
        console.error('âŒ Error en limpieza de cache:', error);
        addDebugLog(`âŒ Error limpieza: ${error.message}`, 'error');
        
        // Limpieza de emergencia
        try {
            githubStorage.downloadCache.clear();
            if (window.tempPhotos) window.tempPhotos.clear();
            memoryManager.cleanup();
            console.log('ğŸš¨ Limpieza de emergencia ejecutada');
        } catch (emergencyError) {
            console.error('âŒ Error en limpieza de emergencia:', emergencyError);
        }
    }
}

// ===============================================
// ğŸ‘” SISTEMA DE SINCRONIZACIÃ“N AUTOMÃTICA PARA SUPERVISORES
// ===============================================

/**
 * SincronizaciÃ³n completa para supervisores
 */
async function syncAllDataForSupervisor() {
    try {
        console.log('ğŸ‘” Iniciando sincronizaciÃ³n completa para supervisor...');
        addDebugLog('ğŸ‘” SincronizaciÃ³n supervisor iniciada', 'info');
        
        // Mostrar indicador de carga
        showSupervisorSyncProgress(true);
        
        if (!githubStorage.connected) {
            throw new Error('Sin conexiÃ³n a GitHub');
        }
        
        let totalSynced = 0;
        
        // 1. Sincronizar recorridos desde GitHub
        const syncedRounds = await syncRoundsFromGitHub();
        totalSynced += syncedRounds;
        
        // 2. Sincronizar incidencias desde GitHub
        const syncedIncidents = await syncIncidentsFromGitHub();
        totalSynced += syncedIncidents;
        
        // 3. Sincronizar fotos desde GitHub
        const syncedPhotos = await syncPhotosFromGitHub();
        totalSynced += syncedPhotos;
        
        // Actualizar timestamp de Ãºltima sincronizaciÃ³n
        localStorage.setItem('supervisor_last_sync', new Date().toISOString());
        
        console.log(`âœ… SincronizaciÃ³n supervisor completada: ${totalSynced} elementos`);
        addDebugLog(`âœ… Sync supervisor: ${totalSynced} elementos`, 'success');
        
        // Ocultar indicador de carga
        showSupervisorSyncProgress(false);
        
        // Actualizar dashboard
        await loadDashboardDataWithPhotos();
        
        return totalSynced;
        
    } catch (error) {
        console.error('âŒ Error en sincronizaciÃ³n supervisor:', error);
        addDebugLog(`âŒ Error sync supervisor: ${error.message}`, 'error');
        showSupervisorSyncProgress(false);
        return 0;
    }
}

/**
 * Sincronizar recorridos desde GitHub
 */
async function syncRoundsFromGitHub() {
    try {
        console.log('ğŸ“‹ Sincronizando recorridos desde GitHub...');
        
        // Buscar en la carpeta rounds/ directamente
        const roundsResponse = await fetch(`${GITHUB_CONFIG.baseUrl}/contents/rounds`, {
            headers: {
                'Authorization': `token ${GITHUB_CONFIG.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'ControlRondas/1.0'
            }
        });
        
        if (!roundsResponse.ok) {
            if (roundsResponse.status === 404) {
                console.log('ğŸ“‹ Carpeta rounds/ no existe aÃºn en GitHub');
                return 0;
            }
            throw new Error(`Error obteniendo recorridos de GitHub: ${roundsResponse.status}`);
        }
        
        const roundFiles = await roundsResponse.json();
        const jsonFiles = roundFiles.filter(file => file.name.endsWith('.json'));
        
        console.log(`ğŸ“‹ Encontrados ${jsonFiles.length} archivos de recorridos en GitHub`);
        
        let syncedRounds = 0;
        let existingRounds = [];
        
        // Obtener recorridos locales existentes
        if (isIndexedDBAvailable() && roundsDB) {
            existingRounds = await roundsDB.getRounds();
        } else {
            existingRounds = JSON.parse(localStorage.getItem('rounds') || '[]');
        }
        
        const existingIds = new Set(existingRounds.map(r => r.id));
        
        // Procesar archivos de recorridos
        for (const file of jsonFiles) {
            try {
                const roundContent = await fetch(file.download_url);
                const roundData = await roundContent.json();
                
                // Solo agregar si no existe localmente
                if (roundData.id && !existingIds.has(roundData.id)) {
                    // Guardar en IndexedDB si estÃ¡ disponible
                    if (isIndexedDBAvailable() && roundsDB) {
                        await roundsDB.saveRound(roundData);
                    }
                    
                    // Agregar a localStorage como respaldo
                    existingRounds.push(roundData);
                    localStorage.setItem('rounds', JSON.stringify(existingRounds));
                    
                    syncedRounds++;
                    console.log(`ğŸ“‹ Recorrido sincronizado desde GitHub: ${roundData.id}`);
                    addDebugLog(`ğŸ“‹ Recorrido descargado: ${roundData.id}`, 'success');
                }
                
            } catch (error) {
                console.error(`âŒ Error procesando recorrido ${file.name}:`, error);
            }
        }
        
        console.log(`âœ… ${syncedRounds} recorridos nuevos sincronizados`);
        return syncedRounds;
        
    } catch (error) {
        console.error('âŒ Error sincronizando recorridos:', error);
        return 0;
    }
}

/**
 * Sincronizar incidencias desde GitHub
 */
async function syncIncidentsFromGitHub() {
    try {
        console.log('ğŸš¨ Sincronizando incidencias desde GitHub...');
        
        // Buscar en la carpeta incidents/ directamente
        const incidentsResponse = await fetch(`${GITHUB_CONFIG.baseUrl}/contents/incidents`, {
            headers: {
                'Authorization': `token ${GITHUB_CONFIG.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'ControlRondas/1.0'
            }
        });
        
        if (!incidentsResponse.ok) {
            if (incidentsResponse.status === 404) {
                console.log('ğŸš¨ Carpeta incidents/ no existe aÃºn en GitHub');
                return 0;
            }
            throw new Error(`Error obteniendo incidencias de GitHub: ${incidentsResponse.status}`);
        }
        
        const incidentFiles = await incidentsResponse.json();
        const jsonFiles = incidentFiles.filter(file => file.name.endsWith('.json'));
        
        console.log(`ğŸš¨ Encontrados ${jsonFiles.length} archivos de incidencias en GitHub`);
        
        let syncedIncidents = 0;
        let existingIncidents = [];
        
        // Obtener incidencias locales existentes
        if (isIndexedDBAvailable() && roundsDB) {
            existingIncidents = await roundsDB.getIncidents();
        } else {
            existingIncidents = JSON.parse(localStorage.getItem('incidents') || '[]');
        }
        
        const existingIds = new Set(existingIncidents.map(i => i.id));
        
        // Procesar archivos de incidencias
        for (const file of jsonFiles) {
            try {
                const incidentContent = await fetch(file.download_url);
                const incidentData = await incidentContent.json();
                
                // Solo agregar si no existe localmente
                if (incidentData.id && !existingIds.has(incidentData.id)) {
                    // NUEVO: Si la incidencia tiene foto, buscar metadata
                    if (incidentData.hasPhoto && incidentData.photoData) {
                        // Intentar sincronizar metadata de la foto
                        try {
                            await cachePhotoMetadata(incidentData.photoData);
                            console.log(`ğŸ“¸ Metadata de foto cacheada para incidencia: ${incidentData.id}`);
                        } catch (photoError) {
                            console.warn(`âš ï¸ Error cacheando metadata de foto para incidencia ${incidentData.id}:`, photoError);
                        }
                    }
                    
                    // Guardar en IndexedDB si estÃ¡ disponible
                    if (isIndexedDBAvailable() && roundsDB) {
                        await roundsDB.saveIncident(incidentData);
                    }
                    
                    // Agregar a localStorage como respaldo
                    existingIncidents.push(incidentData);
                    localStorage.setItem('incidents', JSON.stringify(existingIncidents));
                    
                    syncedIncidents++;
                    console.log(`ğŸš¨ Incidencia sincronizada desde GitHub: ${incidentData.id}`);
                    addDebugLog(`ğŸš¨ Incidencia descargada: ${incidentData.id}`, 'success');
                }
                
            } catch (error) {
                console.error(`âŒ Error procesando incidencia ${file.name}:`, error);
            }
        }
        
        console.log(`âœ… ${syncedIncidents} incidencias nuevas sincronizadas`);
        return syncedIncidents;
        
    } catch (error) {
        console.error('âŒ Error sincronizando incidencias:', error);
        return 0;
    }
}

/**
 * Mostrar/ocultar indicador de sincronizaciÃ³n supervisor
 */
function showSupervisorSyncProgress(show) {
    // Buscar o crear indicador de sincronizaciÃ³n
    let indicator = document.getElementById('supervisorSyncIndicator');
    
    if (show && !indicator) {
        // Crear indicador
        indicator = document.createElement('div');
        indicator.id = 'supervisorSyncIndicator';
        indicator.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        `;
        indicator.innerHTML = `
            <div class="loading-spinner"></div>
            <div>
                <div style="font-weight: bold; margin-bottom: 5px;">ğŸ”„ Sincronizando datos...</div>
                <div style="font-size: 0.9rem; opacity: 0.8;">Obteniendo datos de todos los dispositivos</div>
            </div>
        `;
        document.body.appendChild(indicator);
    } else if (!show && indicator) {
        indicator.remove();
    }
}

/**
 * Obtener informaciÃ³n de Ãºltima sincronizaciÃ³n
 */
function getLastSyncInfo() {
    try {
        const lastSync = localStorage.getItem('supervisor_last_sync');
        if (lastSync) {
            const syncDate = new Date(lastSync);
            const now = new Date();
            const diffMinutes = Math.floor((now - syncDate) / 60000);
            
            if (diffMinutes < 1) {
                return 'Hace menos de 1 minuto';
            } else if (diffMinutes < 60) {
                return `Hace ${diffMinutes} minuto${diffMinutes > 1 ? 's' : ''}`;
            } else {
                const diffHours = Math.floor(diffMinutes / 60);
                return `Hace ${diffHours} hora${diffHours > 1 ? 's' : ''}`;
            }
        }
        return 'Nunca';
    } catch (error) {
        return 'Error obteniendo info';
    }
}

/**
 * Verificar si necesita sincronizaciÃ³n
 */
function needsSyncCheck() {
    try {
        const lastSync = localStorage.getItem('supervisor_last_sync');
        if (!lastSync) return true;
        
        const syncDate = new Date(lastSync);
        const now = new Date();
        const diffMinutes = Math.floor((now - syncDate) / 60000);
        
        // Sugerir sincronizaciÃ³n cada 10 minutos
        return diffMinutes >= 10;
    } catch (error) {
        return true;
    }
}

/**
 * Actualizar indicadores de sincronizaciÃ³n en dashboard
 */
function updateSyncIndicators() {
    try {
        // Actualizar display de Ãºltima sincronizaciÃ³n
        const lastSyncDisplay = document.getElementById('lastSyncDisplay');
        if (lastSyncDisplay) {
            lastSyncDisplay.textContent = getLastSyncInfo();
        }
        
        // Actualizar indicador de fuente de datos
        const dataSourceIndicator = document.getElementById('dataSourceIndicator');
        if (dataSourceIndicator) {
            const lastSync = localStorage.getItem('supervisor_last_sync');
            if (lastSync) {
                dataSourceIndicator.textContent = 'â˜ï¸ Datos Globales';
                dataSourceIndicator.style.background = '#00b894';
                dataSourceIndicator.style.color = 'white';
            } else {
                dataSourceIndicator.textContent = 'ğŸ’¾ Solo Locales';
                dataSourceIndicator.style.background = '#fdcb6e';
                dataSourceIndicator.style.color = '#2d3436';
            }
        }
        
        // Actualizar indicador de conexiÃ³n
        const connectionIndicator = document.getElementById('connectionIndicator');
        if (connectionIndicator) {
            if (githubStorage.connected) {
                connectionIndicator.textContent = 'âœ… Conectado';
                connectionIndicator.style.background = '#00b894';
                connectionIndicator.style.color = 'white';
            } else {
                connectionIndicator.textContent = 'âŒ Offline';
                connectionIndicator.style.background = '#e17055';
                connectionIndicator.style.color = 'white';
            }
        }
        
    } catch (error) {
        console.error('âŒ Error actualizando indicadores:', error);
    }
}


// ===============================================
// ğŸ”§ FUNCIONES AUXILIARES PARA FOTOS
// ===============================================

/**
 * Modal personalizado para mostrar contenido detallado
 */
function showCustomModal(title, content) {
    // Crear modal dinÃ¡mico
    const modalHTML = `
        <div id="customModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
                <div class="modal-header">
                    <h3>${title}</h3>
                    <button class="close-modal" onclick="closeCustomModal()">&times;</button>
                </div>
                <div style="padding: 20px;">
                    ${content}
                </div>
                <div style="text-align: center; padding: 20px;">
                    <button onclick="closeCustomModal()" class="btn btn-secondary">âŒ Cerrar</button>
                </div>
            </div>
        </div>
    `;
    
    // Remover modal anterior si existe
    const existingModal = document.getElementById('customModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Agregar nuevo modal
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

/**
 * Cerrar modal personalizado
 */
function closeCustomModal() {
    const modal = document.getElementById('customModal');
    if (modal) {
        modal.remove();
    }
}

/**
 * Recuperar fotos perdidas al cargar la pÃ¡gina
 */
async function recoverLostPhotos() {
    try {
        console.log('ğŸ”„ Recuperando fotos perdidas...');
        
        if (!isIndexedDBAvailable() || !roundsDB) {
            console.log('âš ï¸ IndexedDB no disponible para recuperaciÃ³n');
            return;
        }
        
        // Obtener todas las observaciones e incidencias
        const rounds = await roundsDB.getRounds();
        const incidents = await roundsDB.getIncidents();
        
        let recoveredCount = 0;
        
        // Recuperar fotos de recorridos
        for (const round of rounds) {
            if (round.locations) {
                for (const locationId in round.locations) {
                    const location = round.locations[locationId];
                    if (location.observations) {
                        for (const obs of location.observations) {
                            if (obs.hasPhoto && obs.photoData && !obs.photoData.url) {
                                const photoUrl = await getPhotoUrlFromDB(obs.photoData.id);
                                if (photoUrl) {
                                    obs.photoData.url = photoUrl;
                                    recoveredCount++;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Recuperar fotos de incidencias
        for (const incident of incidents) {
            if (incident.hasPhoto && incident.photoData && !incident.photoData.url) {
                const photoUrl = await getPhotoUrlFromDB(incident.photoData.id);
                if (photoUrl) {
                    incident.photoData.url = photoUrl;
                    recoveredCount++;
                }
            }
        }
        
        if (recoveredCount > 0) {
            console.log(`âœ… ${recoveredCount} fotos recuperadas`);
        } else {
            console.log('â„¹ï¸ No se encontraron fotos para recuperar');
        }
        
    } catch (error) {
        console.error('âŒ Error recuperando fotos:', error);
    }
}

/**
 * FunciÃ³n mejorada para cargar datos del dashboard con fotos
 */
async function loadDashboardDataWithPhotos() {
    try {
        console.log('ğŸ“Š Cargando dashboard con datos de fotos...');
        
        // Obtener datos
        let rounds = [];
        let incidents = [];
        
        if (isIndexedDBAvailable() && roundsDB) {
            rounds = await roundsDB.getRounds();
            incidents = await roundsDB.getIncidents();
        } else {
            rounds = JSON.parse(localStorage.getItem('rounds') || '[]');
            incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
        }
        
        // Verificar si los elementos existen antes de usarlos
const totalRoundsEl = document.getElementById('totalRounds');
const totalIncidentsEl = document.getElementById('totalIncidents');
const matrizRoundsEl = document.getElementById('matrizRounds');
const ekzotikRoundsEl = document.getElementById('ekzotikRounds');

if (totalRoundsEl) totalRoundsEl.textContent = rounds.length;
if (totalIncidentsEl) totalIncidentsEl.textContent = incidents.length;
if (matrizRoundsEl) matrizRoundsEl.textContent = rounds.filter(r => r.plant === 'matriz').length;
if (ekzotikRoundsEl) ekzotikRoundsEl.textContent = rounds.filter(r => r.plant === 'ekzotikart').length;
        
        // Contar fotos totales
        let totalPhotos = 0;
        for (const round of rounds) {
            totalPhotos += await countPhotosInRound(round);
        }
        totalPhotos += incidents.filter(inc => inc.hasPhoto).length;
        
        // Agregar estadÃ­stica de fotos si no existe
        let photosStat = document.getElementById('totalPhotos');
        if (!photosStat) {
            const statsGrid = document.querySelector('.stats-grid');
            if (statsGrid) {
                const photoCard = document.createElement('div');
                photoCard.className = 'stat-card';
                photoCard.innerHTML = `
                    <div class="stat-value" id="totalPhotos">${totalPhotos}</div>
                    <div class="stat-label">Total Fotos</div>
                `;
                statsGrid.appendChild(photoCard);
            }
        } else {
            photosStat.textContent = totalPhotos;
        }
        
        // Cargar lista de incidencias con fotos
        await loadIncidentsList(incidents);

        // NUEVO: Actualizar indicadores de sincronizaciÃ³n
updateSyncIndicators();

// NUEVO: Verificar si necesita sincronizaciÃ³n
if (needsSyncCheck() && githubStorage.connected) {
    setTimeout(() => {
        const syncInfo = document.getElementById('syncInfoPanel');
        if (syncInfo) {
            syncInfo.style.background = '#fff3e0';
            syncInfo.style.borderColor = '#ffcc02';
            syncInfo.innerHTML = `
                <div>
                    <strong>âš ï¸ Datos Antiguos</strong><br>
                    <small>Considera actualizar para ver informaciÃ³n reciente</small>
                </div>
                <button onclick="syncAllDataForSupervisor()" class="btn" style="background: #ff9500; color: white; padding: 4px 8px; font-size: 0.8rem;">
                    ğŸ”„ Actualizar Ahora
                </button>
            `;
        }
    }, 1000);
}
        
        console.log('âœ… Dashboard cargado con datos de fotos');
        
    } catch (error) {
        console.error('âŒ Error cargando dashboard con fotos:', error);
        // Fallback a funciÃ³n original
        loadDashboardData();
    }
}

// ===============================================
// ğŸ”§ SISTEMA DE DEBUG VISUAL PARA MÃ“VIL
// ===============================================

// Variables globales para debug
let debugLog = [];
let debugPanelVisible = false;

/**
 * Agregar entrada al log de debug
 */
function addDebugLog(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString('es-ES');
    const logEntry = {
        time: timestamp,
        message: message,
        type: type
    };
    
    debugLog.push(logEntry);
    
    // Mantener solo Ãºltimas 50 entradas
    if (debugLog.length > 50) {
        debugLog.shift();
    }
    
    // Actualizar UI si el panel estÃ¡ visible
    if (debugPanelVisible) {
        updateDebugLogUI();
    }
    
    // TambiÃ©n loggear en consola
    console.log(`[DEBUG ${type.toUpperCase()}] ${message}`);
}

/**
 * Actualizar log de debug en UI
 */
function updateDebugLogUI() {
    const logContainer = document.getElementById('debugLog');
    if (!logContainer) return;
    
    const logHTML = debugLog.slice(-20).map(entry => 
        `<div class="log-entry ${entry.type}">[${entry.time}] ${entry.message}</div>`
    ).join('');
    
    logContainer.innerHTML = logHTML;
    logContainer.scrollTop = logContainer.scrollHeight;
}

/**
 * Actualizar estado del sistema en debug panel
 */
function updateDebugSystemStatus() {
    // IndexedDB Status
    const indexedDBStatus = document.getElementById('debugIndexedDB');
    if (indexedDBStatus) {
        indexedDBStatus.textContent = isIndexedDBAvailable() ? 'âœ… OK' : 'âŒ NO';
        indexedDBStatus.style.color = isIndexedDBAvailable() ? '#00b894' : '#e17055';
    }
    
    // GitHub Status
    const githubStatus = document.getElementById('debugGitHub');
    if (githubStatus) {
        githubStatus.textContent = githubStorage.connected ? 'âœ… OK' : 'âŒ NO';
        githubStatus.style.color = githubStorage.connected ? '#00b894' : '#e17055';
    }
    
    // Photos Backup Count
    const photosBackup = document.getElementById('debugPhotosBackup');
    if (photosBackup) {
        photosBackup.textContent = githubStorage.statistics.totalUploaded;
    }
    
    // Upload Queue Count
    const uploadQueue = document.getElementById('debugUploadQueue');
    if (uploadQueue) {
        uploadQueue.textContent = githubStorage.uploadQueue.length;
    }
    
    // EstadÃ­sticas
    const totalUploads = document.getElementById('debugTotalUploads');
    if (totalUploads) {
        totalUploads.textContent = githubStorage.statistics.totalUploaded;
    }
    
    const storageUsed = document.getElementById('debugStorageUsed');
    if (storageUsed) {
        const sizeMB = (githubStorage.statistics.totalSize / (1024 * 1024)).toFixed(2);
        storageUsed.textContent = `${sizeMB} MB`;
    }
    
    const errors = document.getElementById('debugErrors');
    if (errors) {
        errors.textContent = githubStorage.statistics.errors;
    }
    
    const lastSync = document.getElementById('debugLastSync');
    if (lastSync) {
        if (githubStorage.statistics.lastSync) {
            const syncTime = new Date(githubStorage.statistics.lastSync);
            lastSync.textContent = syncTime.toLocaleTimeString('es-ES');
        } else {
            lastSync.textContent = 'Nunca';
        }
    }
}

/**
 * Toggle del panel de debug
 */
function toggleDebugPanel() {
    const panel = document.getElementById('debugPanel');
    if (!panel) return;
    
    debugPanelVisible = !debugPanelVisible;
    
    if (debugPanelVisible) {
        panel.classList.remove('hidden');
        updateDebugLogUI();
        updateDebugSystemStatus();
        addDebugLog('Panel de debug abierto', 'info');
    } else {
        panel.classList.add('hidden');
        addDebugLog('Panel de debug cerrado', 'info');
    }
}

/**
 * Limpiar log de debug
 */
function clearDebugLog() {
    debugLog = [];
    updateDebugLogUI();
    addDebugLog('Log de debug limpiado', 'info');
}

/**
 * Test manual de conexiÃ³n GitHub con debug detallado
 */
async function testGitHubConnection() {
    addDebugLog('Iniciando test de conexiÃ³n GitHub...', 'info');
    
    try {
        // Test 1: Conectividad bÃ¡sica
        addDebugLog('ğŸŒ Verificando conectividad bÃ¡sica...', 'info');
        
        const basicResponse = await fetch('https://api.github.com', {
            method: 'GET',
            headers: {
                'User-Agent': 'ControlRondas/1.0'
            }
        });
        
        if (basicResponse.ok) {
            addDebugLog('âœ… Conectividad GitHub bÃ¡sica OK', 'success');
        } else {
            addDebugLog(`âš ï¸ GitHub API status: ${basicResponse.status}`, 'warning');
        }
        
        // Test 2: AutenticaciÃ³n
        addDebugLog('ğŸ”‘ Verificando autenticaciÃ³n...', 'info');
        
        const authResponse = await fetch(`${GITHUB_CONFIG.baseUrl}`, {
            method: 'GET',
            headers: {
                'Authorization': `token ${GITHUB_CONFIG.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'ControlRondas/1.0'
            }
        });
        
        if (authResponse.ok) {
            addDebugLog('âœ… AutenticaciÃ³n GitHub OK', 'success');
            githubStorage.connected = true;
            
            // Test 3: Upload de prueba
            addDebugLog('ğŸ“¤ Probando upload...', 'info');
            await testGitHubUpload();
            
        } else {
            const errorData = await authResponse.text();
            addDebugLog(`âŒ Auth fallÃ³: ${authResponse.status} - ${errorData}`, 'error');
            githubStorage.connected = false;
        }
        
    } catch (error) {
        addDebugLog(`âŒ Error de red: ${error.message}`, 'error');
        addDebugLog(`ğŸ“± Tipo de error: ${error.name}`, 'error');
        
        // InformaciÃ³n adicional para debug
        addDebugLog(`ğŸŒ Navigator online: ${navigator.onLine}`, 'info');
        addDebugLog(`ğŸ“¡ Connection type: ${navigator.connection?.effectiveType || 'unknown'}`, 'info');
    }
    
    updateDebugSystemStatus();
}

/**
 * Procesar cola de upload manualmente
 */
async function processUploadQueueManual() {
    addDebugLog(`ğŸ”„ Procesando cola manualmente (${githubStorage.uploadQueue.length} elementos)`, 'info');
    
    if (githubStorage.uploadQueue.length === 0) {
        addDebugLog('â„¹ï¸ Cola de upload vacÃ­a', 'warning');
        return;
    }
    
    await processUploadQueue();
    updateDebugSystemStatus();
}

/**
 * Mostrar informaciÃ³n del sistema
 */
async function showDebugInfo() {
    const info = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        cookieEnabled: navigator.cookieEnabled,
        onLine: navigator.onLine,
        localStorage: !!window.localStorage,
        sessionStorage: !!window.sessionStorage,
        indexedDB: !!window.indexedDB,
        serviceWorker: 'serviceWorker' in navigator,
        notifications: 'Notification' in window
    };
    
    addDebugLog(`ğŸ“± Platform: ${info.platform}`, 'info');
    addDebugLog(`ğŸŒ Online: ${info.onLine}`, 'info');
    addDebugLog(`ğŸ’¾ Storage: Local=${info.localStorage}, Session=${info.sessionStorage}, IndexedDB=${info.indexedDB}`, 'info');
    addDebugLog(`ğŸ”” Notifications: ${info.notifications}`, 'info');
    
    // NUEVA PARTE AGREGADA - DiagnÃ³stico de IndexedDB
    if (isIndexedDBAvailable() && roundsDB) {
        try {
            const dbDiagnostics = await roundsDB.getDiagnostics();
            addDebugLog(`ğŸ’¾ DB Conectada: ${dbDiagnostics.dbConnected}`, 'info');
            addDebugLog(`ğŸ”„ MigraciÃ³n Completada: ${dbDiagnostics.migrationCompleted}`, 'info');
            addDebugLog(`ğŸ“Š Recorridos: ${dbDiagnostics.stats.rounds}`, 'info');
            addDebugLog(`ğŸš¨ Incidencias: ${dbDiagnostics.stats.incidents}`, 'info');
            addDebugLog(`ğŸ“¸ Fotos: ${dbDiagnostics.stats.photos}`, 'info');
        } catch (diagError) {
            addDebugLog(`âŒ Error diagnÃ³stico DB: ${diagError.message}`, 'error');
        }
    } else {
        addDebugLog(`âš ï¸ IndexedDB no disponible`, 'warning');
    }
}

/**
 * Exportar datos de debug
 */
function exportDebugData() {
    const debugData = {
        timestamp: new Date().toISOString(),
        system: {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            onLine: navigator.onLine
        },
        github: {
            connected: githubStorage.connected,
            statistics: githubStorage.statistics,
            queueLength: githubStorage.uploadQueue.length
        },
        log: debugLog
    };
    
    const dataStr = JSON.stringify(debugData, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `debug-log-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    memoryManager.revokeObjectURL(url);
    
    addDebugLog('ğŸ“¤ Log de debug exportado', 'success');
}

/**
 * Inicializar sistema de debug
 */
function initializeDebugSystem() {
    addDebugLog('ğŸš€ Sistema de debug inicializado', 'success');
    updateDebugSystemStatus();
    
    // Actualizar estado periÃ³dicamente
    setInterval(updateDebugSystemStatus, 5000);
    
    // Interceptar funciones clave para logging automÃ¡tico
    interceptDebugFunctions();
}

/**
 * Interceptar funciones para logging automÃ¡tico
 */
function interceptDebugFunctions() {
    // Interceptar funciones de GitHub
    const originalUploadToGitHub = window.uploadToGitHub;
    if (originalUploadToGitHub) {
        window.uploadToGitHub = async function(...args) {
            addDebugLog(`ğŸ“¤ Iniciando upload: ${args[0]}`, 'info');
            try {
                const result = await originalUploadToGitHub.apply(this, args);
                if (result.success) {
                    addDebugLog(`âœ… Upload exitoso: ${args[0]}`, 'success');
                } else {
                    addDebugLog(`âŒ Upload fallÃ³: ${result.error}`, 'error');
                }
                return result;
            } catch (error) {
                addDebugLog(`âŒ Error en upload: ${error.message}`, 'error');
                throw error;
            }
        };
    }
}

/**
 * Crear botÃ³n flotante dinÃ¡micamente
 */
function createFloatingReportButton() {
    try {
        // Eliminar botÃ³n existente si existe
        const existingBtn = document.getElementById('reportIncidentBtn');
        if (existingBtn) {
            existingBtn.remove();
        }
        
        // Crear nuevo botÃ³n
        const btn = document.createElement('button');
        btn.id = 'reportIncidentBtn';
        btn.innerHTML = 'ğŸš¨';
        btn.title = 'Reportar Incidencia';
        btn.className = 'floating-button hidden';
        
        // Aplicar estilos inline para garantizar funcionamiento
        btn.style.cssText = `
            position: fixed !important;
            bottom: 20px !important;
            right: 20px !important;
            width: 60px !important;
            height: 60px !important;
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%) !important;
            color: white !important;
            border: none !important;
            border-radius: 50% !important;
            font-size: 1.5rem !important;
            cursor: pointer !important;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3) !important;
            z-index: 99999 !important;
            display: none !important;
            align-items: center !important;
            justify-content: center !important;
            visibility: visible !important;
            opacity: 1 !important;
            transition: all 0.3s ease !important;
        `;
        
        // FunciÃ³n de click
        btn.onclick = function() {
            console.log('ğŸš¨ BotÃ³n de incidencias clickeado');
            addDebugLog('ğŸš¨ Modal de incidencias abierto', 'info');
            
            // Verificar que hay un recorrido activo
            if (!currentRound) {
                showAlert('âš ï¸ Sin recorrido activo', 'Inicia un recorrido antes de reportar incidencias');
                addDebugLog('âš ï¸ Intento de reportar sin recorrido activo', 'warning');
                return;
            }
            
            // Abrir modal en modo incidencia
            openObservationModal(null);
        };
        
        // Agregar hover effect
        btn.onmouseenter = function() {
            this.style.transform = 'scale(1.1)';
            this.style.boxShadow = '0 8px 20px rgba(255, 65, 108, 0.6)';
        };
        
        btn.onmouseleave = function() {
            this.style.transform = 'scale(1)';
            this.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
        };
        
        // Agregar al body
        document.body.appendChild(btn);
        
        console.log('âœ… BotÃ³n flotante creado dinÃ¡micamente');
        addDebugLog('ğŸ“± BotÃ³n flotante inicializado', 'success');
        
        return btn;
        
    } catch (error) {
        console.error('âŒ Error creando botÃ³n flotante:', error);
        addDebugLog(`âŒ Error creando botÃ³n: ${error.message}`, 'error');
    }
}

/**
 * Mostrar botÃ³n flotante
 */
function showFloatingButton() {
    const btn = document.getElementById('reportIncidentBtn');
    if (btn) {
        btn.style.display = 'flex';
        btn.classList.remove('hidden');
        console.log('âœ… BotÃ³n flotante mostrado');
        addDebugLog('ğŸ“± BotÃ³n de reportes activado', 'info');
    } else {
        console.log('âš ï¸ BotÃ³n flotante no encontrado, recreando...');
        createFloatingReportButton();
        setTimeout(() => showFloatingButton(), 100);
    }
}

/**
 * Ocultar botÃ³n flotante
 */
function hideFloatingButton() {
    const btn = document.getElementById('reportIncidentBtn');
    if (btn) {
        btn.style.display = 'none';
        btn.classList.add('hidden');
        console.log('ğŸ”’ BotÃ³n flotante ocultado');
    }
}


        // ===============================================
        // ğŸ”§ INICIALIZACIÃ“N Y EVENTOS
        // ===============================================
        document.addEventListener('DOMContentLoaded', async function() {
    console.log('ğŸš€ Iniciando Control de Rondas Corporativo v2.0');
    
    // NUEVO: Inicializar base de datos IndexedDB
    try {
        await initDatabase();
        console.log('âœ… Base de datos inicializada correctamente');
    } catch (error) {
        console.error('âŒ Error inicializando base de datos:', error);
        console.log('âš ï¸ Continuando con localStorage como respaldo');
    }
    
    // Tu cÃ³digo existente
    updateCurrentTime();
    setInterval(updateCurrentTime, 60000);
    // NUEVO: Crear botÃ³n flotante dinÃ¡micamente para evitar conflictos CSS
setTimeout(() => {
    createFloatingReportButton();
}, 1000);
});

        window.onclick = function(event) {
            const observationModal = document.getElementById('observationModal');
            const remindersModal = document.getElementById('remindersModal');
            
            if (event.target === observationModal) {
                closeModal();
            } else if (event.target === remindersModal) {
                closeRemindersModal();
            }
        };

        // ===============================================
        // ğŸ”§ INICIALIZACIÃ“N FINAL Y EVENTOS GLOBALES
        // ===============================================
        
        // InicializaciÃ³n completa del sistema - CORREGIDA
document.addEventListener('DOMContentLoaded', async function() {
    console.log('ğŸš€ Iniciando Control de Rondas Corporativo v2.0 - COMPLETO');
    
    // NUEVO: Inicializar base de datos PRIMERO
    try {
        await initDatabase();
        console.log('âœ… IndexedDB lista');
        
        // AGREGAR ESTA LÃNEA:
        await initImageProcessingSystem();

        await recoverLostPhotos();
        
        // NUEVO: Inicializar conectividad GitHub con configuraciÃ³n segura
setTimeout(async () => {
    console.log('ğŸ”— Inicializando conectividad GitHub segura...');
    
    // Inicializar token de forma segura
    const tokenConfigured = initializeGitHubToken();
    
    if (tokenConfigured) {
        // Verificar conectividad inicial
        const connected = await checkGitHubConnectivity();
        
        if (connected) {
            // Realizar prueba de upload
            await testGitHubUpload();
            
            // Obtener estadÃ­sticas del repositorio
            const stats = await getRepositoryStats();
            if (stats) {
                console.log('ğŸ“Š EstadÃ­sticas del repositorio:', stats);
            }
        } else {
            console.log('âš ï¸ Token configurado pero sin conectividad');
        }
    } else {
        console.log('â„¹ï¸ Token no configurado - Sistema funcionarÃ¡ solo local');
        
        // Mostrar configuraciÃ³n despuÃ©s de un tiempo si el usuario interactÃºa
        setTimeout(() => {
            if (!tokenConfigured && !tokenPromptShown) {
                addDebugLog('ğŸ’¡ Tip: Configura GitHub token para backup en la nube', 'info');
            }
        }, 10000);
    }
}, 3000);

// NUEVO: Inicializar sistema de backup automÃ¡tico
await initializeAutoBackup();

// NUEVO: Inicializar sistema de debug visual
initializeDebugSystem();

    } catch (error) {
        console.error('âŒ Error IndexedDB:', error);
    }
            
            // Verificar integridad de datos
            validateDataIntegrity();
            
            // Limpiar datos antiguos
            cleanOldData();
            
            // Verificar conectividad
            checkConnectivity();
            
            // Configurar eventos de conectividad
            window.addEventListener('online', checkConnectivity);
            window.addEventListener('offline', checkConnectivity);
            
            // Respaldo automÃ¡tico cada 30 minutos
            setInterval(autoBackup, 30 * 60 * 1000);
            
            // Log de inicio del sistema
            logAction('SYSTEM_START', 'Sistema iniciado correctamente');
            
            // NUEVO: Verificar jsQR en background para diagnÃ³stico
            setTimeout(() => {
                console.log('ğŸ” VerificaciÃ³n inicial de jsQR:', typeof jsQR);
                if (typeof jsQR !== 'undefined') {
                    console.log('âœ… jsQR pre-cargado correctamente');
                } else {
                    console.log('âš ï¸ jsQR no pre-cargado, se cargarÃ¡ dinÃ¡micamente cuando sea necesario');
                }
            }, 2000);
            
            console.log('âœ… Sistema completamente inicializado');
        });

        // Cleanup completo al cerrar
        window.addEventListener('beforeunload', function() {
            console.log('ğŸ›‘ Cerrando sistema...');
            
            // Detener scanner QR
            if (scanningActive) {
                cancelQRScan();
            }
            
            // Detener cÃ¡maras
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
            if (qrStream) {
                qrStream.getTracks().forEach(track => track.stop());
            }
            
            // Detener recordatorios
            if (reminderInterval) {
                clearTimeout(reminderInterval);
            }
            
            // Detener timer de recorrido
            if (roundTimer) {
                clearInterval(roundTimer);
            }
            
            // Log de cierre
            logAction('SYSTEM_CLOSE', 'Sistema cerrado correctamente');
            
            console.log('ğŸ Sistema cerrado completamente');
        });

        // ===============================================
        // ğŸ¤– PREPARACIÃ“N PARA IA (FUTURO)
        // ===============================================
        function detectRiskPatterns() {
            console.log('ğŸ¤– FunciÃ³n de IA: detectRiskPatterns() - Pendiente de implementar');
        }

        function predictIncidents() {
            console.log('ğŸ¤– FunciÃ³n de IA: predictIncidents() - Pendiente de implementar');
        }

        function suggestImprovements() {
            console.log('ğŸ¤– FunciÃ³n de IA: suggestImprovements() - Pendiente de implementar');
        }

        function optimizeRoutes() {
            console.log('ğŸ¤– FunciÃ³n de IA: optimizeRoutes() - Pendiente de implementar');
        }

        function generateInsights() {
            console.log('ğŸ¤– FunciÃ³n de IA: generateInsights() - Pendiente de implementar');
        }

// ===============================================
// ğŸ“¦ PARTE 1: CONFIGURACIÃ“N INDEXEDDB + FUNCIONES BÃSICAS
// ===============================================

/**
 * Sistema de almacenamiento IndexedDB para reemplazar localStorage
 * Capacidad: GB en lugar de MB
 * Optimizado para fotos y datos del sistema de rondas
 */

class RoundsDB {
    constructor() {
        this.dbName = 'RoundsControlDB';
        this.version = 1;
        this.db = null;
        
        // ConfiguraciÃ³n de stores (tablas)
        this.stores = {
            rounds: 'rounds',           // Recorridos
            incidents: 'incidents',     // Incidencias
            photos: 'photos',          // Fotos (BLOB)
            settings: 'settings',      // Configuraciones
            syncQueue: 'syncQueue'     // Cola de sincronizaciÃ³n
        };
    }

    /**
     * Inicializar la base de datos IndexedDB
     * @returns {Promise<boolean>} true si inicializaciÃ³n exitosa
     */
    async init() {
        try {
            console.log('ğŸš€ Inicializando IndexedDB...');
            
            return new Promise((resolve, reject) => {
                // Verificar compatibilidad
                if (!window.indexedDB) {
                    console.error('âŒ IndexedDB no soportado en este navegador');
                    reject(new Error('IndexedDB no soportado'));
                    return;
                }

                const request = indexedDB.open(this.dbName, this.version);

                request.onerror = () => {
                    console.error('âŒ Error abriendo IndexedDB:', request.error);
                    reject(request.error);
                };

                request.onsuccess = () => {
                    this.db = request.result;
                    console.log('âœ… IndexedDB inicializada correctamente');
                    resolve(true);
                };

                request.onupgradeneeded = (event) => {
                    console.log('ğŸ”§ Configurando estructura de IndexedDB...');
                    const db = event.target.result;
                    const oldVersion = event.oldVersion;
                    const newVersion = event.newVersion;
                    
                    console.log(`ğŸ“Š Actualizando DB de versiÃ³n ${oldVersion} a ${newVersion}`);
                    
                    try {
                        this.createStores(db);
                        console.log('âœ… Estructura de base de datos actualizada correctamente');
                    } catch (storeError) {
                        console.error('âŒ Error creando stores:', storeError);
                        reject(storeError);
                    }
                };
            });

        } catch (error) {
            console.error('âŒ Error en inicializaciÃ³n:', error);
            throw error;
        }
    }

    /**
     * Crear las tablas (object stores) necesarias
     * @param {IDBDatabase} db - Instancia de la base de datos
     */
    createStores(db) {
        try {
            // Store para recorridos
            if (!db.objectStoreNames.contains(this.stores.rounds)) {
                const roundsStore = db.createObjectStore(this.stores.rounds, {
                    keyPath: 'id',
                    autoIncrement: false
                });
                roundsStore.createIndex('plant', 'plant', { unique: false });
                roundsStore.createIndex('turn', 'turn', { unique: false });
                roundsStore.createIndex('startTime', 'startTime', { unique: false });
                console.log('ğŸ“‹ Store "rounds" creado');
            }

            // Store para incidencias
if (!db.objectStoreNames.contains(this.stores.incidents)) {
    const incidentsStore = db.createObjectStore(this.stores.incidents, {
        keyPath: 'id',
        autoIncrement: false  // CAMBIO: false para usar IDs manuales
    });
                incidentsStore.createIndex('locationId', 'locationId', { unique: false });
                incidentsStore.createIndex('plant', 'plant', { unique: false });
                incidentsStore.createIndex('timestamp', 'timestamp', { unique: false });
                incidentsStore.createIndex('incidentType', 'incidentType', { unique: false });
                console.log('ğŸš¨ Store "incidents" creado');
            }

            // Store para fotos (CRÃTICO para el problema principal)
            if (!db.objectStoreNames.contains(this.stores.photos)) {
                const photosStore = db.createObjectStore(this.stores.photos, {
                    keyPath: 'id',
                    autoIncrement: true
                });
                photosStore.createIndex('roundId', 'roundId', { unique: false });
                photosStore.createIndex('incidentId', 'incidentId', { unique: false });
                photosStore.createIndex('timestamp', 'timestamp', { unique: false });
                photosStore.createIndex('synced', 'synced', { unique: false });
                console.log('ğŸ“¸ Store "photos" creado');
            }

            // Store para configuraciones
            if (!db.objectStoreNames.contains(this.stores.settings)) {
                const settingsStore = db.createObjectStore(this.stores.settings, {
                    keyPath: 'key'
                });
                console.log('âš™ï¸ Store "settings" creado');
            }

            // Store para cola de sincronizaciÃ³n
            if (!db.objectStoreNames.contains(this.stores.syncQueue)) {
                const syncStore = db.createObjectStore(this.stores.syncQueue, {
                    keyPath: 'id',
                    autoIncrement: true
                });
                syncStore.createIndex('priority', 'priority', { unique: false });
                syncStore.createIndex('attempts', 'attempts', { unique: false });
                syncStore.createIndex('status', 'status', { unique: false });
                console.log('ğŸ”„ Store "syncQueue" creado');
            }

            console.log('âœ… Todos los stores creados correctamente');

        } catch (error) {
            console.error('âŒ Error creando stores:', error);
            throw error;
        }
    }

    /**
     * FUNCIONES BÃSICAS DE CRUD
     */

    /**
     * Guardar un recorrido
     * @param {Object} roundData - Datos del recorrido
     * @returns {Promise<string>} ID del recorrido guardado
     */
    async saveRound(roundData) {
    try {
        const transaction = this.db.transaction([this.stores.rounds], 'readwrite');
        const store = transaction.objectStore(this.stores.rounds);
        
        // Asegurar que tiene ID Ãºnico
        if (!roundData.id) {
            roundData.id = Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        // Agregar metadatos
        roundData.savedAt = new Date().toISOString();
        roundData.synced = false;
        roundData.device = navigator.userAgent.includes('Mobile') ? 'mobile' : 'desktop';
        roundData.syncVersion = 1; // Para control de versiones

        await store.put(roundData);
        console.log('âœ… Recorrido guardado:', roundData.id);
        
        // NUEVO: Backup automÃ¡tico a GitHub
        if (githubStorage.connected) {
            setTimeout(() => {
                backupRoundToGitHub(roundData);
            }, 1000); // Delay de 1 segundo para no bloquear UI
        } else {
            addToRoundUploadQueue(roundData);
        }
        
        return roundData.id;

    } catch (error) {
        console.error('âŒ Error guardando recorrido:', error);
        throw error;
    }
}

    /**
     * Obtener todos los recorridos
     * @param {string} plant - Filtrar por planta (opcional)
     * @returns {Promise<Array>} Lista de recorridos
     */
    async getRounds(plant = null) {
        try {
            const transaction = this.db.transaction([this.stores.rounds], 'readonly');
            const store = transaction.objectStore(this.stores.rounds);
            
            let request;
            if (plant) {
                const index = store.index('plant');
                request = index.getAll(plant);
            } else {
                request = store.getAll();
            }

            return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                    const rounds = request.result || [];
                    console.log(`ğŸ“‹ ${rounds.length} recorridos obtenidos`);
                    resolve(rounds);
                };
                request.onerror = () => reject(request.error);
            });

        } catch (error) {
            console.error('âŒ Error obteniendo recorridos:', error);
            throw error;
        }
    }

    /**
     * Guardar una incidencia
     * @param {Object} incidentData - Datos de la incidencia
     * @returns {Promise<number>} ID de la incidencia guardada
     */
    async saveIncident(incidentData) {
    try {
        const transaction = this.db.transaction([this.stores.incidents], 'readwrite');
        const store = transaction.objectStore(this.stores.incidents);
        
        // Generar ID Ãºnico si no existe
        if (!incidentData.id) {
            incidentData.id = Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        // Agregar metadatos
        incidentData.savedAt = new Date().toISOString();
        incidentData.synced = false;
        incidentData.device = navigator.userAgent.includes('Mobile') ? 'mobile' : 'desktop';
        incidentData.syncVersion = 1; // Para control de versiones

        return new Promise((resolve, reject) => {
            const request = store.put(incidentData);
            request.onsuccess = () => {
                console.log('âœ… Incidencia guardada/actualizada:', incidentData.id);
                
                // NUEVO: Backup automÃ¡tico a GitHub
                if (githubStorage.connected) {
                    setTimeout(() => {
                        backupIncidentToGitHub(incidentData);
                    }, 1000);
                } else {
                    addToIncidentUploadQueue(incidentData);
                }
                
                resolve(incidentData.id);
            };
            request.onerror = () => {
                console.error('âŒ Error en saveIncident:', request.error);
                reject(request.error);
            };
        });

    } catch (error) {
        console.error('âŒ Error guardando incidencia:', error);
        throw error;
    }
}

    /**
     * Obtener incidencias
     * @param {string} plant - Filtrar por planta (opcional)
     * @returns {Promise<Array>} Lista de incidencias
     */
    async getIncidents(plant = null) {
        try {
            const transaction = this.db.transaction([this.stores.incidents], 'readonly');
            const store = transaction.objectStore(this.stores.incidents);
            
            let request;
            if (plant) {
                const index = store.index('plant');
                request = index.getAll(plant);
            } else {
                request = store.getAll();
            }

            return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                    const incidents = request.result || [];
                    console.log(`ğŸš¨ ${incidents.length} incidencias obtenidas`);
                    resolve(incidents);
                };
                request.onerror = () => reject(request.error);
            });

        } catch (error) {
            console.error('âŒ Error obteniendo incidencias:', error);
            throw error;
        }
    }

    /**
     * Guardar una foto (FUNCIÃ“N CRÃTICA)
     * @param {Blob} photoBlob - Blob de la imagen
     * @param {Object} metadata - Metadatos de la foto
     * @returns {Promise<number>} ID de la foto guardada
     */
    async savePhoto(photoBlob, metadata = {}) {
        try {
            const transaction = this.db.transaction([this.stores.photos], 'readwrite');
            const store = transaction.objectStore(this.stores.photos);
            
            const photoData = {
                blob: photoBlob,
                size: photoBlob.size,
                type: photoBlob.type,
                timestamp: new Date().toISOString(),
                roundId: metadata.roundId || null,
                incidentId: metadata.incidentId || null,
                locationId: metadata.locationId || null,
                plant: metadata.plant || null,
                synced: false,
                cloudUrl: null,
                ...metadata
            };

            return new Promise((resolve, reject) => {
                const request = store.add(photoData);
                request.onsuccess = () => {
                    console.log('ğŸ“¸ Foto guardada:', request.result, `(${(photoBlob.size/1024).toFixed(1)}KB)`);
                    resolve(request.result);
                };
                request.onerror = () => reject(request.error);
            });

        } catch (error) {
            console.error('âŒ Error guardando foto:', error);
            throw error;
        }
    }

    /**
     * Obtener una foto por ID
     * @param {number} photoId - ID de la foto
     * @returns {Promise<Object>} Datos de la foto
     */
    async getPhoto(photoId) {
        try {
            const transaction = this.db.transaction([this.stores.photos], 'readonly');
            const store = transaction.objectStore(this.stores.photos);

            return new Promise((resolve, reject) => {
                const request = store.get(photoId);
                request.onsuccess = () => {
                    if (request.result) {
                        console.log('ğŸ“¸ Foto obtenida:', photoId);
                        resolve(request.result);
                    } else {
                        resolve(null);
                    }
                };
                request.onerror = () => reject(request.error);
            });

        } catch (error) {
            console.error('âŒ Error obteniendo foto:', error);
            throw error;
        }
    }

    /**
     * MIGRACIÃ“N DESDE LOCALSTORAGE
     */

    /**
     * Migrar datos existentes desde localStorage a IndexedDB
     * @returns {Promise<Object>} EstadÃ­sticas de migraciÃ³n
     */
    async migrateFromLocalStorage() {
    try {
        console.log('ğŸ”„ Iniciando migraciÃ³n desde localStorage...');
        
        // Verificar si la migraciÃ³n ya se completÃ³
        const migrationCompleted = await this.getSetting('migration_completed', false);
        if (migrationCompleted) {
            console.log('â„¹ï¸ MigraciÃ³n ya completada anteriormente');
            return { rounds: 0, incidents: 0, errors: [], alreadyCompleted: true };
        }
        
        const stats = {
            rounds: 0,
            incidents: 0,
            errors: []
        };

        // Migrar recorridos
        try {
            const existingRounds = JSON.parse(localStorage.getItem('rounds') || '[]');
            for (const round of existingRounds) {
                // Asegurar ID Ãºnico
                if (!round.id) {
                    round.id = Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9);
                }
                await this.saveRound(round);
                stats.rounds++;
            }
            console.log(`âœ… ${stats.rounds} recorridos migrados`);
        } catch (error) {
            console.error('âŒ Error migrando recorridos:', error);
            stats.errors.push('Error migrando recorridos: ' + error.message);
        }

        // Migrar incidencias con mejor manejo de duplicados
        try {
            const existingIncidents = JSON.parse(localStorage.getItem('incidents') || '[]');
            for (const incident of existingIncidents) {
                // Generar ID Ãºnico si no existe
                if (!incident.id) {
                    incident.id = Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9) + '_incident';
                }
                
                try {
                    await this.saveIncident(incident);
                    stats.incidents++;
                    console.log(`âœ… Incidencia migrada: ${incident.id}`);
                } catch (incidentError) {
                    console.warn(`âš ï¸ Error migrando incidencia individual:`, incidentError);
                    stats.errors.push(`Error en incidencia ${incident.id}: ${incidentError.message}`);
                }
            }
            console.log(`âœ… ${stats.incidents} incidencias migradas`);
        } catch (error) {
            console.error('âŒ Error general migrando incidencias:', error);
            stats.errors.push('Error migrando incidencias: ' + error.message);
        }

        // Crear backup de localStorage antes de marcar como completado
        const backupData = {
            rounds: localStorage.getItem('rounds'),
            incidents: localStorage.getItem('incidents'),
            backup_date: new Date().toISOString(),
            migration_stats: stats
        };
        await this.saveSetting('localStorage_backup', backupData);

        // Marcar migraciÃ³n como completada solo si no hay errores crÃ­ticos
        if (stats.errors.length === 0) {
            await this.saveSetting('migration_completed', true);
            console.log('âœ… MigraciÃ³n marcada como completada');
        } else {
            console.warn('âš ï¸ MigraciÃ³n completada con errores, no se marca como finalizada');
        }

        console.log('âœ… MigraciÃ³n completada:', stats);
        return stats;

    } catch (error) {
        console.error('âŒ Error crÃ­tico en migraciÃ³n:', error);
        throw error;
    }
}


/**
 * Verificar y resetear migraciÃ³n si es necesario
 */
async resetMigrationIfNeeded() {
    try {
        const migrationCompleted = await this.getSetting('migration_completed', false);
        const hasLocalStorageData = localStorage.getItem('rounds') || localStorage.getItem('incidents');
        
        // Si hay datos en localStorage pero la migraciÃ³n estÃ¡ marcada como completada,
        // significa que hay datos nuevos que necesitan migraciÃ³n
        if (hasLocalStorageData && migrationCompleted) {
            console.log('ğŸ”„ Detectados nuevos datos en localStorage, permitiendo nueva migraciÃ³n');
            await this.saveSetting('migration_completed', false);
        }
        
        return !migrationCompleted || !!hasLocalStorageData;
    } catch (error) {
        console.error('âŒ Error verificando estado de migraciÃ³n:', error);
        return true; // En caso de error, permitir migraciÃ³n
    }
}

    /**
     * FUNCIONES DE CONFIGURACIÃ“N
     */

    /**
     * Guardar una configuraciÃ³n
     * @param {string} key - Clave de la configuraciÃ³n
     * @param {any} value - Valor de la configuraciÃ³n
     */
    async saveSetting(key, value) {
        try {
            const transaction = this.db.transaction([this.stores.settings], 'readwrite');
            const store = transaction.objectStore(this.stores.settings);
            
            await store.put({ key, value, updatedAt: new Date().toISOString() });
            console.log('âš™ï¸ ConfiguraciÃ³n guardada:', key);

        } catch (error) {
            console.error('âŒ Error guardando configuraciÃ³n:', error);
            throw error;
        }
    }

    /**
     * Obtener una configuraciÃ³n
     * @param {string} key - Clave de la configuraciÃ³n
     * @param {any} defaultValue - Valor por defecto
     * @returns {Promise<any>} Valor de la configuraciÃ³n
     */
    async getSetting(key, defaultValue = null) {
        try {
            const transaction = this.db.transaction([this.stores.settings], 'readonly');
            const store = transaction.objectStore(this.stores.settings);

            return new Promise((resolve, reject) => {
                const request = store.get(key);
                request.onsuccess = () => {
                    const result = request.result;
                    resolve(result ? result.value : defaultValue);
                };
                request.onerror = () => reject(request.error);
            });

        } catch (error) {
            console.error('âŒ Error obteniendo configuraciÃ³n:', error);
            return defaultValue;
        }
    }

    /**
     * Obtener estadÃ­sticas de uso de la base de datos
     * @returns {Promise<Object>} EstadÃ­sticas detalladas
     */
    async getStorageStats() {
        try {
            const stats = {
                rounds: 0,
                incidents: 0,
                photos: 0,
                photosSizeMB: 0,
                lastUpdate: new Date().toISOString()
            };

            // Contar recorridos
            const rounds = await this.getRounds();
            stats.rounds = rounds.length;

            // Contar incidencias
            const incidents = await this.getIncidents();
            stats.incidents = incidents.length;

            // Contar fotos y calcular tamaÃ±o
            const transaction = this.db.transaction([this.stores.photos], 'readonly');
            const store = transaction.objectStore(this.stores.photos);
            
            const photosRequest = store.getAll();
            const photos = await new Promise((resolve, reject) => {
                photosRequest.onsuccess = () => resolve(photosRequest.result || []);
                photosRequest.onerror = () => reject(photosRequest.error);
            });

            stats.photos = photos.length;
            stats.photosSizeMB = photos.reduce((total, photo) => total + (photo.size || 0), 0) / (1024 * 1024);

            console.log('ğŸ“Š EstadÃ­sticas de almacenamiento:', stats);
            return stats;

        } catch (error) {
            console.error('âŒ Error obteniendo estadÃ­sticas:', error);
            throw error;
        }
    }
    async getStorageStats() {
        // ... cÃ³digo existente ...
        console.log('ğŸ“Š EstadÃ­sticas de almacenamiento:', stats);
        return stats;
    }

    /**
     * DiagnÃ³stico de estado de la base de datos para debug
     */
    async getDiagnostics() {
        try {
            if (!this.db) {
                return { error: 'Base de datos no inicializada' };
            }

            const stats = await this.getStorageStats();
            const migrationStatus = await this.getSetting('migration_completed', false);
            const hasLocalStorage = !!(localStorage.getItem('rounds') || localStorage.getItem('incidents'));
            
            return {
                dbConnected: !!this.db,
                migrationCompleted: migrationStatus,
                hasLocalStorageData: hasLocalStorage,
                stats: stats,
                storeNames: Array.from(this.db.objectStoreNames),
                dbVersion: this.db.version
            };
        } catch (error) {
            return { error: error.message };
        }
    }
} // â† Esta es la lÃ­nea que cierra la clase RoundsDB

// ===============================================
// ğŸ”§ INSTANCIA GLOBAL Y FUNCIONES DE UTILIDAD
// ===============================================

// Instancia global de la base de datos
let roundsDB = null;

/**
 * Inicializar el sistema de IndexedDB
 * Llamar esta funciÃ³n al inicio de la aplicaciÃ³n
 */
async function initDatabase() {
    try {
        if (roundsDB) {
            console.log('âœ… Base de datos ya inicializada');
            return true;
        }

        console.log('ğŸš€ Inicializando sistema de base de datos...');
        
        roundsDB = new RoundsDB();
        await roundsDB.init();

        // Verificar si necesitamos migrar datos con nueva lÃ³gica mejorada
        const needsMigration = await roundsDB.resetMigrationIfNeeded();
        const hasLocalStorageData = localStorage.getItem('rounds') || localStorage.getItem('incidents');
        
        if (hasLocalStorageData && needsMigration) {
            console.log('ğŸ“¦ Datos detectados en localStorage, iniciando migraciÃ³n...');
            const migrationStats = await roundsDB.migrateFromLocalStorage();
            
            // Mostrar resultados de migraciÃ³n
            console.log('ğŸ“Š MigraciÃ³n completada:', migrationStats);
            
            if (migrationStats.alreadyCompleted) {
                console.log('â„¹ï¸ MigraciÃ³n ya habÃ­a sido completada anteriormente');
            } else if (migrationStats.errors.length === 0) {
                console.log('ğŸ§¹ MigraciÃ³n exitosa - localStorage se puede limpiar manualmente si se desea');
                // Opcional: Descomentar estas lÃ­neas despuÃ©s de verificar que todo funciona
                // localStorage.removeItem('rounds');
                // localStorage.removeItem('incidents');
            } else {
                console.warn('âš ï¸ MigraciÃ³n completada con errores:', migrationStats.errors);
            }
        } else if (!hasLocalStorageData) {
            console.log('â„¹ï¸ No hay datos en localStorage para migrar');
        } else {
            console.log('â„¹ï¸ MigraciÃ³n no necesaria en este momento');
        }

        console.log('âœ… Sistema de base de datos listo');
        return true;

    } catch (error) {
        console.error('âŒ Error inicializando base de datos:', error);
        
        // Fallback a localStorage si IndexedDB falla
        console.log('âš ï¸ Usando localStorage como fallback');
        return false;
    }
}

/**
 * Verificar si IndexedDB estÃ¡ disponible y funcionando
 * @returns {boolean} true si estÃ¡ disponible
 */
function isIndexedDBAvailable() {
    return !!(window.indexedDB && roundsDB && roundsDB.db);
}

/**
 * Obtener informaciÃ³n de compatibilidad del navegador
 * @returns {Object} InformaciÃ³n de compatibilidad
 */
function getBrowserCompatibility() {
    return {
        indexedDB: !!window.indexedDB,
        serviceWorker: 'serviceWorker' in navigator,
        notifications: 'Notification' in window,
        getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
        localStorage: !!window.localStorage,
        sessionStorage: !!window.sessionStorage
    };
}

// ===============================================
// ğŸ“ INSTRUCCIONES DE INTEGRACIÃ“N
// ===============================================

/*
INTEGRACIÃ“N CON TU CÃ“DIGO EXISTENTE:

1. Agregar al inicio de tu HTML (despuÃ©s de las otras declaraciones):
   
   // Inicializar base de datos al cargar la pÃ¡gina
   document.addEventListener('DOMContentLoaded', async function() {
       await initDatabase();
       // Tu cÃ³digo existente...
   });

2. Reemplazar las funciones de localStorage:

   // ANTES (localStorage):
   localStorage.setItem('rounds', JSON.stringify(rounds));
   
   // DESPUÃ‰S (IndexedDB):
   if (isIndexedDBAvailable()) {
       await roundsDB.saveRound(roundData);
   } else {
       localStorage.setItem('rounds', JSON.stringify(rounds));
   }

3. Actualizar la funciÃ³n saveObservation() para guardar fotos:

   // Cuando captures una foto:
   if (capturedPhotoUrl && isIndexedDBAvailable()) {
       // Convertir URL a Blob
       const response = await fetch(capturedPhotoUrl);
       const photoBlob = await response.blob();
       
       // Guardar en IndexedDB
       const photoId = await roundsDB.savePhoto(photoBlob, {
           roundId: currentRound?.id,
           locationId: locationId,
           plant: currentPlant
       });
       
       // Guardar ID de la foto en lugar de URL
       observation.photoId = photoId;
   }

SIGUIENTE PASO:
Una vez que integres esta Parte 1, avÃ­same para continuar con la Parte 2 (CompresiÃ³n de ImÃ¡genes).
*/

// ===============================================
// ğŸ“¸ PARTE 2: SISTEMA DE COMPRESIÃ“N DE IMÃGENES
// ===============================================

/**
 * Sistema avanzado de compresiÃ³n y optimizaciÃ³n de imÃ¡genes
 * Reduce el tamaÃ±o de las fotos en 70-80% sin perder calidad visual
 * Optimizado para dispositivos mÃ³viles y almacenamiento eficiente
 */

class ImageProcessor {
    constructor() {
        this.compressionSettings = {
            high: { quality: 0.9, maxWidth: 1920, maxHeight: 1080 },
            medium: { quality: 0.8, maxWidth: 1280, maxHeight: 720 },
            low: { quality: 0.6, maxWidth: 800, maxHeight: 600 },
            thumbnail: { quality: 0.5, maxWidth: 200, maxHeight: 150 }
        };
        
        this.defaultSetting = 'medium'; // ConfiguraciÃ³n por defecto
        this.canvas = null;
        this.context = null;
    }

    /**
     * Inicializar el procesador de imÃ¡genes
     */
    init() {
        try {
            // Crear canvas reutilizable para mejor rendimiento
            this.canvas = document.createElement('canvas');
            this.context = this.canvas.getContext('2d');
            
            // Configurar canvas para mejor calidad
            this.context.imageSmoothingEnabled = true;
            this.context.imageSmoothingQuality = 'high';
            
            console.log('ğŸ¨ Procesador de imÃ¡genes inicializado');
            return true;
            
        } catch (error) {
            console.error('âŒ Error inicializando procesador de imÃ¡genes:', error);
            return false;
        }
    }

    /**
     * Comprimir una imagen desde un Blob
     * @param {Blob} imageBlob - Blob de la imagen original
     * @param {string} quality - Nivel de calidad ('high', 'medium', 'low', 'thumbnail')
     * @param {Object} options - Opciones adicionales
     * @returns {Promise<Blob>} Imagen comprimida
     */
    async compressImage(imageBlob, quality = null, options = {}) {
        try {
            const setting = quality || this.defaultSetting;
            const config = this.compressionSettings[setting];
            
            if (!config) {
                throw new Error(`ConfiguraciÃ³n de calidad no vÃ¡lida: ${setting}`);
            }

            console.log(`ğŸ“¸ Comprimiendo imagen con calidad: ${setting}`);
            console.log(`ğŸ“Š TamaÃ±o original: ${(imageBlob.size / 1024).toFixed(1)}KB`);

            // Crear imagen desde blob
            const image = await this.createImageFromBlob(imageBlob);
            
            // Calcular nuevas dimensiones
            const { width, height } = this.calculateDimensions(
                image.width, 
                image.height, 
                config.maxWidth, 
                config.maxHeight
            );

            // Configurar canvas
            this.canvas.width = width;
            this.canvas.height = height;

            // Limpiar canvas
            this.context.clearRect(0, 0, width, height);

            // Dibujar imagen redimensionada
            this.context.drawImage(image, 0, 0, width, height);

            // Convertir a blob comprimido
            const compressedBlob = await this.canvasToBlob(config.quality);
            
            console.log(`âœ… Imagen comprimida: ${(compressedBlob.size / 1024).toFixed(1)}KB`);
            console.log(`ğŸ“‰ ReducciÃ³n: ${((1 - compressedBlob.size / imageBlob.size) * 100).toFixed(1)}%`);

            return compressedBlob;

        } catch (error) {
            console.error('âŒ Error comprimiendo imagen:', error);
            throw error;
        }
    }

    /**
     * Crear imagen desde blob
     * @param {Blob} blob - Blob de la imagen
     * @returns {Promise<HTMLImageElement>} Elemento imagen
     */
    createImageFromBlob(blob) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            const url = URL.createObjectURL(blob);
            
            img.onload = () => {
                memoryManager.revokeObjectURL(url);
                resolve(img);
            };
            
            img.onerror = () => {
                memoryManager.revokeObjectURL(url);
                reject(new Error('Error cargando imagen'));
            };
            
            img.src = url;
        });
    }

    /**
     * Calcular nuevas dimensiones manteniendo proporciÃ³n
     * @param {number} originalWidth - Ancho original
     * @param {number} originalHeight - Alto original
     * @param {number} maxWidth - Ancho mÃ¡ximo
     * @param {number} maxHeight - Alto mÃ¡ximo
     * @returns {Object} Nuevas dimensiones
     */
    calculateDimensions(originalWidth, originalHeight, maxWidth, maxHeight) {
        let { width, height } = { width: originalWidth, height: originalHeight };

        // Si la imagen es mÃ¡s pequeÃ±a que los lÃ­mites, mantener tamaÃ±o original
        if (width <= maxWidth && height <= maxHeight) {
            return { width, height };
        }

        // Calcular ratio de reducciÃ³n
        const ratioWidth = maxWidth / width;
        const ratioHeight = maxHeight / height;
        const ratio = Math.min(ratioWidth, ratioHeight);

        // Aplicar ratio manteniendo proporciÃ³n
        width = Math.round(width * ratio);
        height = Math.round(height * ratio);

        return { width, height };
    }

    /**
     * Convertir canvas a blob
     * @param {number} quality - Calidad de compresiÃ³n (0-1)
     * @returns {Promise<Blob>} Blob de la imagen
     */
    canvasToBlob(quality) {
        return new Promise((resolve, reject) => {
            this.canvas.toBlob(
                (blob) => {
                    if (blob) {
                        resolve(blob);
                    } else {
                        reject(new Error('Error convirtiendo canvas a blob'));
                    }
                },
                'image/jpeg',
                quality
            );
        });
    }

    /**
     * Comprimir imagen desde input de archivo
     * @param {File} file - Archivo de imagen
     * @param {string} quality - Nivel de calidad
     * @returns {Promise<Blob>} Imagen comprimida
     */
    async compressFromFile(file, quality = null) {
        try {
            // Validar que sea una imagen
            if (!file.type.startsWith('image/')) {
                throw new Error('El archivo no es una imagen vÃ¡lida');
            }

            console.log(`ğŸ“ Procesando archivo: ${file.name} (${(file.size / 1024).toFixed(1)}KB)`);

            // Comprimir imagen
            const compressedBlob = await this.compressImage(file, quality);

            return compressedBlob;

        } catch (error) {
            console.error('âŒ Error procesando archivo:', error);
            throw error;
        }
    }

    /**
     * Crear miniatura de una imagen
     * @param {Blob} imageBlob - Blob de la imagen
     * @returns {Promise<Blob>} Miniatura
     */
    async createThumbnail(imageBlob) {
        return await this.compressImage(imageBlob, 'thumbnail');
    }

    /**
     * Obtener informaciÃ³n de una imagen
     * @param {Blob} imageBlob - Blob de la imagen
     * @returns {Promise<Object>} InformaciÃ³n de la imagen
     */
    async getImageInfo(imageBlob) {
        try {
            const image = await this.createImageFromBlob(imageBlob);
            
            return {
                width: image.width,
                height: image.height,
                size: imageBlob.size,
                sizeMB: (imageBlob.size / (1024 * 1024)).toFixed(2),
                sizeKB: (imageBlob.size / 1024).toFixed(1),
                type: imageBlob.type,
                aspectRatio: (image.width / image.height).toFixed(2)
            };

        } catch (error) {
            console.error('âŒ Error obteniendo informaciÃ³n de imagen:', error);
            throw error;
        }
    }

    /**
     * Configurar nivel de compresiÃ³n personalizado
     * @param {string} name - Nombre del nivel
     * @param {Object} config - ConfiguraciÃ³n
     */
    setCompressionLevel(name, config) {
        this.compressionSettings[name] = {
            quality: config.quality || 0.8,
            maxWidth: config.maxWidth || 1280,
            maxHeight: config.maxHeight || 720
        };
        
        console.log(`âš™ï¸ Nivel de compresiÃ³n "${name}" configurado:`, this.compressionSettings[name]);
    }

    /**
     * Obtener configuraciones disponibles
     * @returns {Object} Configuraciones de compresiÃ³n
     */
    getCompressionSettings() {
        return { ...this.compressionSettings };
    }
}

// ===============================================
// ğŸ“· INTEGRACIÃ“N CON SISTEMA DE CÃMARA EXISTENTE
// ===============================================

class CameraHandler {
    constructor(imageProcessor) {
        this.imageProcessor = imageProcessor;
        this.currentStream = null;
        this.videoElement = null;
    }

    /**
     * Capturar foto con compresiÃ³n automÃ¡tica
     * @param {HTMLVideoElement} videoElement - Elemento de video
     * @param {string} quality - Calidad de compresiÃ³n
     * @returns {Promise<Object>} Datos de la foto comprimida
     */
    async captureCompressedPhoto(videoElement, quality = 'medium') {
        try {
            console.log('ğŸ“¸ Capturando foto con compresiÃ³n automÃ¡tica...');

            // Crear canvas temporal para captura
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // Configurar dimensiones del canvas
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;

            // Capturar frame actual del video
            context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

            // Convertir a blob
            const originalBlob = await new Promise((resolve) => {
                canvas.toBlob(resolve, 'image/jpeg', 0.95);
            });

            console.log(`ğŸ“Š Foto original capturada: ${(originalBlob.size / 1024).toFixed(1)}KB`);

            // Comprimir imagen
            const compressedBlob = await this.imageProcessor.compressImage(originalBlob, quality);

            // Crear miniatura
            const thumbnail = await this.imageProcessor.createThumbnail(compressedBlob);

            // Obtener informaciÃ³n
            const imageInfo = await this.imageProcessor.getImageInfo(compressedBlob);

            return {
                originalBlob,
                compressedBlob,
                thumbnail,
                info: imageInfo,
                quality: quality,
                timestamp: new Date().toISOString(),
                compressionRatio: ((1 - compressedBlob.size / originalBlob.size) * 100).toFixed(1)
            };

        } catch (error) {
            console.error('âŒ Error capturando foto comprimida:', error);
            throw error;
        }
    }

    /**
     * Procesar foto existente (desde input file)
     * @param {File} file - Archivo de imagen
     * @param {string} quality - Calidad de compresiÃ³n
     * @returns {Promise<Object>} Datos de la foto procesada
     */
    async processExistingPhoto(file, quality = 'medium') {
        try {
            console.log('ğŸ”„ Procesando foto existente...');

            // Comprimir imagen
            const compressedBlob = await this.imageProcessor.compressFromFile(file, quality);

            // Crear miniatura
            const thumbnail = await this.imageProcessor.createThumbnail(compressedBlob);

            // Obtener informaciÃ³n
            const imageInfo = await this.imageProcessor.getImageInfo(compressedBlob);

            return {
                originalBlob: file,
                compressedBlob,
                thumbnail,
                info: imageInfo,
                quality: quality,
                timestamp: new Date().toISOString(),
                compressionRatio: ((1 - compressedBlob.size / file.size) * 100).toFixed(1)
            };

        } catch (error) {
            console.error('âŒ Error procesando foto existente:', error);
            throw error;
        }
    }
}

// ===============================================
// ğŸ”§ FUNCIONES DE UTILIDAD Y CONFIGURACIÃ“N
// ===============================================


/**
 * Inicializar el sistema de procesamiento de imÃ¡genes
 */
function initImageProcessor() {
    try {
        // Verificar si la clase ImageProcessor existe
        if (typeof ImageProcessor === 'undefined') {
            console.log('âš ï¸ ImageProcessor class no disponible, usando funcionalidad bÃ¡sica');
            return true; // Continuar sin compresiÃ³n avanzada
        }
        
        // Declarar variable si no existe
        if (typeof imageProcessor === 'undefined') {
            window.imageProcessor = null;
        }
        
        if (!imageProcessor) {
            imageProcessor = new ImageProcessor();
            const success = imageProcessor.init();
            
            if (success) {
                cameraHandler = new CameraHandler(imageProcessor);
                console.log('âœ… Sistema de procesamiento de imÃ¡genes inicializado');
                return true;
            }
        }
        
        return true;

    } catch (error) {
        console.error('âŒ Error inicializando procesador de imÃ¡genes:', error);
        return false;
    }
}

/**
 * Configurar calidad de compresiÃ³n segÃºn el dispositivo
 */
function configureCompressionForDevice() {
    try {
        // Detectar capacidad del dispositivo
        const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isLowEnd = navigator.hardwareConcurrency <= 2;
        const hasLimitedMemory = navigator.deviceMemory && navigator.deviceMemory <= 2;

        let recommendedQuality = 'medium';

        if (isMobile || isLowEnd || hasLimitedMemory) {
            recommendedQuality = 'low';
            console.log('ğŸ“± Dispositivo mÃ³vil/limitado detectado, usando compresiÃ³n baja');
        } else {
            console.log('ğŸ’» Dispositivo potente detectado, usando compresiÃ³n media');
        }

        // Configurar calidad por defecto
        if (imageProcessor) {
            imageProcessor.defaultSetting = recommendedQuality;
        }

        return recommendedQuality;

    } catch (error) {
        console.error('âŒ Error configurando compresiÃ³n para dispositivo:', error);
        return 'medium';
    }
}

/**
 * Obtener estadÃ­sticas de compresiÃ³n
 * @returns {Promise<Object>} EstadÃ­sticas de uso
 */
async function getCompressionStats() {
    try {
        if (!isIndexedDBAvailable()) {
            return { error: 'IndexedDB no disponible' };
        }

        // Obtener todas las fotos
        const transaction = roundsDB.db.transaction(['photos'], 'readonly');
        const store = transaction.objectStore('photos');
        
        const photos = await new Promise((resolve, reject) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error);
        });

        let totalOriginalSize = 0;
        let totalCompressedSize = 0;
        let photoCount = 0;

        photos.forEach(photo => {
            if (photo.originalSize && photo.size) {
                totalOriginalSize += photo.originalSize;
                totalCompressedSize += photo.size;
                photoCount++;
            }
        });

        const averageCompression = photoCount > 0 ? 
            ((1 - totalCompressedSize / totalOriginalSize) * 100).toFixed(1) : 0;

        return {
            photoCount,
            totalOriginalSizeMB: (totalOriginalSize / (1024 * 1024)).toFixed(2),
            totalCompressedSizeMB: (totalCompressedSize / (1024 * 1024)).toFixed(2),
            spaceSavedMB: ((totalOriginalSize - totalCompressedSize) / (1024 * 1024)).toFixed(2),
            averageCompressionPercent: averageCompression
        };

    } catch (error) {
        console.error('âŒ Error obteniendo estadÃ­sticas de compresiÃ³n:', error);
        return { error: error.message };
    }
}

/**
 * Limpiar cache de imÃ¡genes temporales
 */
function cleanImageCache() {
    try {
        // Revocar URLs de objeto que puedan estar en memoria
        // Esta funciÃ³n se puede llamar periÃ³dicamente para limpiar memoria
        
        console.log('ğŸ§¹ Cache de imÃ¡genes limpiado');
        
        // Forzar garbage collection si estÃ¡ disponible
        if (window.gc) {
            window.gc();
        }

    } catch (error) {
        console.error('âŒ Error limpiando cache de imÃ¡genes:', error);
    }
}

// ===============================================
// ğŸ”— FUNCIONES DE INTEGRACIÃ“N CON CÃ“DIGO EXISTENTE
// ===============================================


// ===============================================
// ğŸ“· SISTEMA MEJORADO DE CAPTURA Y ALMACENAMIENTO
// ===============================================

/**
 * Capturar foto con backup automÃ¡tico a GitHub
 */
async function capturePhotoImproved() {
    try {
        console.log('ğŸ“¸ Iniciando captura con backup automÃ¡tico...');
        
        const video = document.getElementById('cameraPreview');
        const canvas = document.getElementById('photoCanvas');
        
        if (!video || !canvas) {
            throw new Error('Elementos de video o canvas no encontrados');
        }
        
        if (!video.videoWidth || !video.videoHeight) {
            throw new Error('Video no estÃ¡ listo para captura');
        }
        
        // Configurar canvas con dimensiones del video
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        // Capturar frame actual
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Convertir a blob con compresiÃ³n balanceada
        const photoBlob = await new Promise((resolve, reject) => {
            canvas.toBlob(
                (blob) => {
                    if (blob) {
                        resolve(blob);
                    } else {
                        reject(new Error('Error generando blob de imagen'));
                    }
                },
                'image/jpeg',
                0.85 // Calidad balanceada: buena calidad, tamaÃ±o razonable
            );
        });
        
        console.log(`ğŸ“Š Foto capturada: ${(photoBlob.size / 1024).toFixed(1)}KB`);
        
        // Preparar datos de la foto
        const photoData = {
            plant: currentPlant,
            turn: currentTurn,
            captureTime: new Date().toISOString(),
            timestamp: new Date().toISOString(),
            roundId: currentRound?.id || null,
            size: photoBlob.size,
            blob: photoBlob
        };
        
        // Guardar foto en IndexedDB si estÃ¡ disponible
        let localPhotoData = null;
        if (isIndexedDBAvailable() && roundsDB) {
            try {
                const photoId = await roundsDB.savePhoto(photoBlob, photoData);
                photoData.id = photoId;
                
                localPhotoData = {
                    id: photoId,
                    blob: photoBlob,
                    url: URL.createObjectURL(photoBlob),
                    size: photoBlob.size,
                    timestamp: photoData.timestamp,
                    stored: 'indexeddb',
                    backedUp: false // Inicialmente no respaldada
                };
                
                console.log('ğŸ’¾ Foto guardada en IndexedDB con ID:', photoId);
                
            } catch (error) {
                console.error('âŒ Error guardando en IndexedDB:', error);
                localPhotoData = createTemporaryPhotoData(photoBlob);
            }
        } else {
            localPhotoData = createTemporaryPhotoData(photoBlob);
        }
        
        // Mostrar preview inmediatamente
        showPhotoPreview(localPhotoData);
        updateCaptureUI();
        
        // NUEVO: Backup automÃ¡tico a GitHub en background
        backupPhotoToGitHub(photoData, localPhotoData);
        
        // Guardar referencia global para uso posterior
        window.currentPhotoData = localPhotoData;
        
        return localPhotoData;
        
    } catch (error) {
        console.error('âŒ Error en captura mejorada:', error);
        showAlert('âŒ Error de Captura', 'No se pudo capturar la foto. Verifica que la cÃ¡mara estÃ© funcionando.');
        throw error;
    }
}

/**
 * Crear datos de foto temporal como fallback
 */
function createTemporaryPhotoData(photoBlob) {
    const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    const photoUrl = URL.createObjectURL(photoBlob);
    
    // Guardar temporalmente en memoria
    if (!window.tempPhotos) {
        window.tempPhotos = new Map();
    }
    window.tempPhotos.set(tempId, {
        blob: photoBlob,
        url: photoUrl,
        timestamp: new Date().toISOString()
    });
    
    return {
        id: tempId,
        blob: photoBlob,
        url: photoUrl,
        size: photoBlob.size,
        timestamp: new Date().toISOString(),
        stored: 'temporary'
    };
}

/**
 * Mostrar preview de la foto capturada
 */
function showPhotoPreview(photoData) {
    const img = document.getElementById('capturedPhoto');
    const video = document.getElementById('cameraPreview');
    
    if (img && photoData.url) {
        img.src = photoData.url;
        img.style.display = 'block';
        img.onclick = () => openPhotoViewer(photoData);
        
        // Agregar indicador de calidad
        const indicator = document.createElement('div');
        indicator.id = 'photoIndicator';
        indicator.style.cssText = `
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8rem;
        `;
        indicator.textContent = `${(photoData.size / 1024).toFixed(0)}KB`;
        
        // Remover indicador anterior si existe
        const oldIndicator = document.getElementById('photoIndicator');
        if (oldIndicator) {
            oldIndicator.remove();
        }
        
        // Agregar nuevo indicador
        const container = img.parentElement;
        container.style.position = 'relative';
        container.appendChild(indicator);
    }
    
    if (video) {
        video.style.display = 'none';
    }
}

/**
 * Actualizar UI despuÃ©s de capturar foto
 */
function updateCaptureUI() {
    const captureBtn = document.getElementById('captureBtn');
    const retakeBtn = document.getElementById('retakeBtn');
    
    if (captureBtn) {
        captureBtn.classList.add('hidden');
    }
    
    if (retakeBtn) {
        retakeBtn.classList.remove('hidden');
    }
    
    // Detener cÃ¡mara para ahorrar recursos
    if (cameraStream) {
        cameraStream.getTracks().forEach(track => {
            track.stop();
            console.log('ğŸ”’ Track de cÃ¡mara detenido:', track.kind);
        });
        cameraStream = null;
    }
}

/**
 * FunciÃ³n mejorada para retomar foto
 */
function retakePhotoImproved() {
    console.log('ğŸ”„ Retomando foto...');
    
    // Limpiar foto actual
    if (window.currentPhotoData) {
        // Revocar URL temporal si existe
        if (window.currentPhotoData.url) {
            URL.revokeObjectURL(window.currentPhotoData.url);
        }
        
        // Eliminar de almacenamiento temporal si es necesario
        if (window.currentPhotoData.stored === 'temporary' && window.tempPhotos) {
            window.tempPhotos.delete(window.currentPhotoData.id);
        }
        
        window.currentPhotoData = null;
    }
    
    // Limpiar UI
    const img = document.getElementById('capturedPhoto');
    const video = document.getElementById('cameraPreview');
    const indicator = document.getElementById('photoIndicator');
    
    if (img) {
        img.style.display = 'none';
        img.src = '';
        img.onclick = null;
    }
    
    if (indicator) {
        indicator.remove();
    }
    
    if (video) {
        video.style.display = 'block';
    }
    
    // Restaurar botones
    const captureBtn = document.getElementById('captureBtn');
    const retakeBtn = document.getElementById('retakeBtn');
    
    if (captureBtn) {
        captureBtn.classList.remove('hidden');
    }
    
    if (retakeBtn) {
        retakeBtn.classList.add('hidden');
    }
    
    // Reiniciar cÃ¡mara
    startCamera();
}

/**
 * FunciÃ³n mejorada para guardar observaciÃ³n con foto
 */
async function saveObservationImproved() {
    try {
        console.log('ğŸ’¾ Guardando observaciÃ³n mejorada...');
        
        const locationId = document.getElementById('observationLocation').value;
        const text = document.getElementById('observationText').value.trim();
        const incidentType = document.getElementById('incidentType').value;
        
        // Validaciones
        if (!locationId) {
            showAlert('âš ï¸ UbicaciÃ³n requerida', 'Selecciona una ubicaciÃ³n para continuar');
            return;
        }
        
        if (isIncidentMode && !incidentType) {
            showAlert('âš ï¸ Tipo requerido', 'Selecciona el tipo de incidencia');
            return;
        }
        
        // Crear objeto de observaciÃ³n
        const observation = {
            id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
            locationId,
            text: text || 'Sin observaciones adicionales',
            timestamp: new Date().toISOString(),
            type: isIncidentMode ? 'incident' : 'observation',
            incidentType: incidentType || null,
            priority: incidentPriority || 'normal',
            plant: currentPlant,
            turn: currentTurn,
            photoData: null,
            hasPhoto: false
        };
        
        // Procesar foto si existe
        if (window.currentPhotoData) {
            observation.photoData = {
                id: window.currentPhotoData.id,
                size: window.currentPhotoData.size,
                timestamp: window.currentPhotoData.timestamp,
                stored: window.currentPhotoData.stored
            };
            observation.hasPhoto = true;

            // NUEVO: Verificar estado de backup
if (window.currentPhotoData.backedUp) {
    observation.photoData.cloudBackup = {
        backedUp: true,
        githubPath: window.currentPhotoData.githubPath,
        downloadUrl: window.currentPhotoData.downloadUrl
    };
    console.log('â˜ï¸ ObservaciÃ³n incluye foto respaldada en la nube');
} else {
    observation.photoData.cloudBackup = {
        backedUp: false,
        pending: true
    };
    console.log('ğŸ“‹ ObservaciÃ³n incluye foto pendiente de respaldo');
}
            
            console.log('ğŸ“¸ ObservaciÃ³n incluye foto:', observation.photoData.id);
        }
        
        // Guardar segÃºn el tipo de observaciÃ³n
        if (isIncidentMode) {
            await saveIncidentData(observation);
        } else {
            await saveObservationData(observation);
        }
        
        // Limpiar y cerrar modal
        cleanupAfterSave();
        closeModal();
        
        // Mostrar confirmaciÃ³n
        const photoText = observation.hasPhoto ? ' con evidencia fotogrÃ¡fica' : '';
        const typeText = isIncidentMode ? 'Incidencia' : 'ObservaciÃ³n';
        showAlert(`âœ… ${typeText} guardada`, `${typeText} registrada correctamente${photoText}`);
        
        console.log('âœ… ObservaciÃ³n guardada exitosamente');
        
    } catch (error) {
        console.error('âŒ Error guardando observaciÃ³n:', error);
        showAlert('âŒ Error', 'Error guardando la observaciÃ³n. Intenta de nuevo.');
    }
}

/**
 * Guardar datos de incidencia
 */
async function saveIncidentData(observation) {
    try {
        // Guardar en IndexedDB si estÃ¡ disponible
        if (isIndexedDBAvailable() && roundsDB) {
            await roundsDB.saveIncident(observation);
            console.log('ğŸ’¾ Incidencia guardada en IndexedDB');
        }
        
        // Guardar en localStorage como respaldo
        const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
        incidents.push(observation);
        localStorage.setItem('incidents', JSON.stringify(incidents));
        
        // Agregar al recorrido actual si existe
        if (currentRound) {
            if (!currentRound.incidents) {
                currentRound.incidents = [];
            }
            currentRound.incidents.push(observation);
        }
        
        // Verificar incidencias crÃ­ticas
        checkCriticalIncident(observation);
        
    } catch (error) {
        console.error('âŒ Error guardando incidencia:', error);
        throw error;
    }
}

/**
 * Guardar datos de observaciÃ³n
 */
async function saveObservationData(observation) {
    try {
        // Agregar al recorrido actual
        if (currentRound && currentRound.locations[observation.locationId]) {
            if (!currentRound.locations[observation.locationId].observations) {
                currentRound.locations[observation.locationId].observations = [];
            }
            currentRound.locations[observation.locationId].observations.push(observation);
            
            console.log('ğŸ“ ObservaciÃ³n agregada al recorrido actual');
        }
        
    } catch (error) {
        console.error('âŒ Error guardando observaciÃ³n:', error);
        throw error;
    }
}

/**
 * Limpiar despuÃ©s de guardar
 */
function cleanupAfterSave() {
    // Limpiar referencia de foto actual
    window.currentPhotoData = null;
    
    // Limpiar campos del formulario
    document.getElementById('observationText').value = '';
    document.getElementById('incidentType').value = '';
    
    // Resetear cÃ¡mara
    resetCamera();
}

// ===============================================
// ğŸ“‹ INICIALIZACIÃ“N Y CONFIGURACIÃ“N AUTOMÃTICA
// ===============================================

/**
 * Inicializar todo el sistema de procesamiento de imÃ¡genes
 * Debe llamarse despuÃ©s de initDatabase()
 */
async function initImageProcessingSystem() {
    try {
        console.log('ğŸ¨ Inicializando sistema de procesamiento de imÃ¡genes...');
        
        // Inicializar procesador
        const success = initImageProcessor();
        if (!success) {
            throw new Error('Error inicializando procesador');
        }
        
        // Configurar para el dispositivo actual
        configureCompressionForDevice();
        
        // Obtener estadÃ­sticas iniciales
        const stats = await getCompressionStats();
        console.log('ğŸ“Š EstadÃ­sticas de compresiÃ³n:', stats);
        
        console.log('âœ… Sistema de procesamiento de imÃ¡genes listo');
        return true;

    } catch (error) {
        console.error('âŒ Error inicializando sistema de procesamiento:', error);
        return false;
    }
}

// ===============================================
// ğŸ“ INSTRUCCIONES DE INTEGRACIÃ“N - PARTE 2
// ===============================================

/*
INTEGRACIÃ“N CON TU CÃ“DIGO EXISTENTE:

1. Agregar inicializaciÃ³n despuÃ©s de IndexedDB:
   
   document.addEventListener('DOMContentLoaded', async function() {
       await initDatabase();
       await initImageProcessingSystem(); // NUEVO
       // resto de tu cÃ³digo...
   });

2. Reemplazar funciÃ³n capturePhoto():
   
   // Cambiar en el HTML:
   onclick="capturePhoto()" 
   // por:
   onclick="capturePhotoCompressed()"

3. Actualizar funciÃ³n saveObservation():
   
   // Cambiar en el HTML:
   onclick="saveObservation()"
   // por:
   onclick="saveObservationWithCompression()"

4. OPCIONAL - Agregar indicador de compresiÃ³n al UI:
   
   // Agregar despuÃ©s del botÃ³n de captura:
   <div id="compressionInfo" style="font-size: 0.8rem; color: #666; text-align: center;">
       ğŸ“¸ CompresiÃ³n automÃ¡tica activada
   </div>

BENEFICIOS INMEDIATOS:
- Las fotos ocuparÃ¡n 70-80% menos espacio
- Mejor rendimiento en dispositivos mÃ³viles
- Miniaturas automÃ¡ticas para previews rÃ¡pidos
- EstadÃ­sticas de uso de espacio

SIGUIENTE PASO:
Una vez integrada la Parte 2, avÃ­same para continuar con la Parte 3 (Google Drive API).
*/

        console.log('ğŸ“‹ Control de Rondas Corporativo v2.0 - Cargado completamente');


// ===============================================
// ğŸ”„ SISTEMA DE LIMPIEZA AUTOMÃTICA OPTIMIZADA
// ===============================================

/**
 * Configurar limpieza automÃ¡tica inteligente
 */
function setupAutomaticCleanup() {
    // Limpieza ligera cada 5 minutos
    setInterval(() => {
        try {
            // Solo limpiar URLs blob corruptas
            let cleaned = 0;
            githubStorage.downloadCache.forEach((url, key) => {
                if (url && url.startsWith('blob:')) {
                    // Test rÃ¡pido de validez
                    fetch(url, { method: 'HEAD', signal: AbortSignal.timeout(1000) })
                        .catch(() => {
                            githubStorage.downloadCache.delete(key);
                            memoryManager.revokeObjectURL(url);
                            cleaned++;
                        });
                }
            });
            
            if (cleaned > 0) {
                console.log(`ğŸ§¹ Limpieza automÃ¡tica: ${cleaned} URLs corruptas eliminadas`);
                addDebugLog(`ğŸ§¹ Auto-limpieza: ${cleaned} URLs`, 'info');
            }
        } catch (error) {
            console.warn('âš ï¸ Error en limpieza automÃ¡tica ligera:', error);
        }
    }, 5 * 60 * 1000); // 5 minutos
    
    // Limpieza profunda cada 30 minutos
    setInterval(() => {
        try {
            console.log('ğŸ§¹ Ejecutando limpieza profunda automÃ¡tica...');
            cleanPhotoCache();
            
            // Limpiar tambiÃ©n cache de turnos antiguos
            Object.keys(sessionStorage).forEach(key => {
                if (key.startsWith('turn_')) {
                    sessionStorage.removeItem(key);
                }
            });
            
        } catch (error) {
            console.warn('âš ï¸ Error en limpieza profunda:', error);
        }
    }, 30 * 60 * 1000); // 30 minutos
    
    console.log('âœ… Sistema de limpieza automÃ¡tica configurado');
    addDebugLog('âœ… Auto-limpieza configurada', 'success');
}

// Inicializar limpieza automÃ¡tica despuÃ©s de 10 segundos
setTimeout(setupAutomaticCleanup, 10000);


// ===============================================
// ğŸ›¡ï¸ PROTECCIONES GLOBALES DE ERRORES
// ===============================================

// Capturar errores no manejados
window.addEventListener('error', function(event) {
    console.error('âŒ Error global capturado:', event.error);
    
    // Reiniciar funcionalidades crÃ­ticas si es necesario
    if (event.error.message.includes('createObjectURL')) {
        console.log('ğŸ”„ Reiniciando sistema de URLs...');
        // Limpiar URLs problemÃ¡ticas
        if (window.memoryManager) {
            memoryManager.cleanup();
        }
    }
});

// Verificar elementos crÃ­ticos del DOM
function verifyDOMElements() {
    const criticalElements = [
        'locationsGrid',
        'urgentIncidentsList', // Cambiar de incidentsList a urgentIncidentsList
        'qrVideoContainer',
        'roundsHistory',
        'filteredRounds',
        'heatMapContainer'
    ];
    
    criticalElements.forEach(elementId => {
        const element = document.getElementById(elementId);
        if (!element) {
            console.warn(`âš ï¸ Elemento crÃ­tico faltante: ${elementId}`);
        }
    });
}

// Ejecutar verificaciÃ³n despuÃ©s de un segundo
setTimeout(verifyDOMElements, 1000);


// ===============================================
// ğŸ“Š FUNCIONES DEL NUEVO DASHBOARD
// ===============================================

/**
 * Inicializar pestaÃ±a de Resumen
 */
function initResumenTab() {
    console.log('ğŸ“… Inicializando pestaÃ±a Resumen...');
    
    // Configurar fecha de hoy por defecto
    const today = new Date().toISOString().split('T')[0];
    const dateFilter = document.getElementById('dateFilter');
    if (dateFilter) {
        dateFilter.value = today;
    }
    
    // Cargar datos iniciales
loadDayStats();
// Aplicar filtros automÃ¡ticamente para mostrar recorridos de hoy
setTimeout(() => applyFilters(), 500);
}

/**
 * Aplicar filtros y cargar recorridos
 */
async function applyFilters() {
    const dateFilter = document.getElementById('dateFilter').value;
    const turnFilter = document.getElementById('turnFilter').value;
    const plantFilter = document.getElementById('plantFilter').value;
    
    if (!dateFilter) {
        showAlert('âš ï¸ Fecha requerida', 'Selecciona una fecha para filtrar los recorridos');
        return;
    }
    
    console.log(`ğŸ” Aplicando filtros: ${dateFilter}, ${turnFilter}, ${plantFilter}`);
    
    try {
        // Obtener recorridos
        let rounds = [];
        if (isIndexedDBAvailable() && roundsDB) {
            rounds = await roundsDB.getRounds();
        } else {
            rounds = JSON.parse(localStorage.getItem('rounds') || '[]');
        }
        
        // Filtrar por fecha
        const selectedDate = new Date(dateFilter);
        const filteredRounds = rounds.filter(round => {
            const roundDate = new Date(round.startTime);
            const sameDay = roundDate.toDateString() === selectedDate.toDateString();
            
            let matchesTurn = true;
            if (turnFilter !== 'todos') {
                matchesTurn = round.turn === turnFilter;
            }
            
            let matchesPlant = true;
            if (plantFilter !== 'todas') {
                matchesPlant = round.plant === plantFilter;
            }
            
            return sameDay && matchesTurn && matchesPlant;
        });
        
        // Actualizar estadÃ­sticas del dÃ­a
        updateDayStats(filteredRounds, selectedDate);
        
        // Mostrar recorridos filtrados
        displayFilteredRounds(filteredRounds);
        
    } catch (error) {
        console.error('âŒ Error aplicando filtros:', error);
        showAlert('âŒ Error', 'Error al filtrar los recorridos');
    }
}

/**
 * Actualizar estadÃ­sticas del dÃ­a seleccionado
 */
function updateDayStats(rounds, selectedDate) {
    const dayRoundsEl = document.getElementById('dayRounds');
    const dayIncidentsEl = document.getElementById('dayIncidents');
    const dayPhotosEl = document.getElementById('dayPhotos');
    const coveragePercentEl = document.getElementById('coveragePercent');
    
    if (dayRoundsEl) dayRoundsEl.textContent = rounds.length;
    
    // Contar incidencias del dÃ­a
    let totalIncidents = 0;
    let totalPhotos = 0;
    let totalCoverage = 0;
    
    rounds.forEach(round => {
        if (round.incidents) {
            totalIncidents += round.incidents.length;
        }
        
        // Contar fotos en ubicaciones
        if (round.locations) {
            Object.values(round.locations).forEach(location => {
                if (location.observations) {
                    totalPhotos += location.observations.filter(obs => obs.hasPhoto).length;
                }
            });
        }
        
        // Calcular cobertura
        if (round.completionPercentage) {
            totalCoverage += round.completionPercentage;
        }
    });
    
    if (dayIncidentsEl) dayIncidentsEl.textContent = totalIncidents;
    if (dayPhotosEl) dayPhotosEl.textContent = totalPhotos;
    
    const avgCoverage = rounds.length > 0 ? Math.round(totalCoverage / rounds.length) : 0;
    if (coveragePercentEl) coveragePercentEl.textContent = `${avgCoverage}%`;
}

/**
 * Mostrar recorridos filtrados en timeline
 */
function displayFilteredRounds(rounds) {
    const container = document.getElementById('filteredRounds');
    if (!container) {
        console.error('âŒ Container filteredRounds not found');
        return;
    }
    
    if (rounds.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #666;">
                ğŸ“… No se encontraron recorridos para los filtros seleccionados
            </div>
        `;
        return;
    }
    
    // Ordenar por hora
    const sortedRounds = rounds.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
    
    const roundsHTML = sortedRounds.map(round => {
        const startTime = new Date(round.startTime);
        const endTime = round.endTime ? new Date(round.endTime) : null;
        const duration = endTime ? Math.round((endTime - startTime) / 60000) : 0;
        
        const incidentsCount = round.incidents ? round.incidents.length : 0;
        const locationsCount = round.locations ? Object.keys(round.locations).length : 0;
        const totalLocations = plantLocations[round.plant] ? plantLocations[round.plant].length : 10;
        const coveragePercent = Math.round((locationsCount / totalLocations) * 100);
        
        const plantIcon = round.plant === 'matriz' ? 'ğŸ¢' : 'ğŸ­';
        const turnIcon = round.turn === 'diurno' ? 'ğŸŒ…' : 'ğŸŒ™';
        const statusClass = round.completed ? 'complete' : '';
        const urgentClass = incidentsCount > 0 ? 'urgent' : '';
        
        return `
            <div class="round-timeline-item ${statusClass} ${urgentClass}">
                <div class="round-header">
                    <div class="round-title">
                        ${plantIcon} ${round.plant.toUpperCase()} - ${turnIcon} ${round.turn.toUpperCase()}
                    </div>
                    <div class="round-time">
                        ${startTime.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}
                        ${endTime ? ` - ${endTime.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}` : ''}
                    </div>
                </div>
                
                <div class="round-summary">
                    ğŸ“ <strong>${locationsCount}/${totalLocations}</strong> ubicaciones visitadas (${coveragePercent}%)
                    ${incidentsCount > 0 ? `<br>ğŸš¨ <strong>${incidentsCount}</strong> incidencias reportadas` : ''}
                    ${duration > 0 ? `<br>â±ï¸ DuraciÃ³n: <strong>${duration} minutos</strong>` : ''}
                </div>
                
                <div class="round-actions">
                    <button onclick="viewRoundDetails('${round.id}')" class="btn btn-primary" style="padding: 5px 15px; font-size: 0.9rem;">
                        ğŸ“‹ MÃ¡s Detalles
                    </button>
                    ${incidentsCount > 0 ? `
                        <button onclick="viewRoundIncidents('${round.id}')" class="btn btn-warning" style="padding: 5px 15px; font-size: 0.9rem;">
                            ğŸš¨ Ver Incidencias
                        </button>
                    ` : ''}
                </div>
            </div>
        `;
    }).join('');
    
    container.innerHTML = roundsHTML;
    console.log(`âœ… ${rounds.length} recorridos mostrados en timeline`);
}

/**
 * Cargar estadÃ­sticas del dÃ­a actual
 */
async function loadDayStats() {
    const today = new Date();
    try {
        let rounds = [];
        if (isIndexedDBAvailable() && roundsDB) {
            rounds = await roundsDB.getRounds();
        } else {
            rounds = JSON.parse(localStorage.getItem('rounds') || '[]');
        }
        
        // Filtrar recorridos de hoy
        const todayRounds = rounds.filter(round => {
            const roundDate = new Date(round.startTime);
            return roundDate.toDateString() === today.toDateString();
        });
        
        updateDayStats(todayRounds, today);
        
    } catch (error) {
        console.error('âŒ Error cargando estadÃ­sticas del dÃ­a:', error);
    }
}

/**
 * Inicializar pestaÃ±a de Mapa de Calor
 */
function initMapaCalorTab() {
    console.log('ğŸ”¥ Inicializando pestaÃ±a Mapa de Calor...');
    
    const container = document.getElementById('heatMapContainer');
    if (container) {
        container.innerHTML = `
            <div style="text-align: center; padding: 50px; color: #666;">
                ğŸ”¥ Selecciona una planta para generar el mapa de calor
            </div>
        `;
    }
}

/**
 * Generar mapa de calor para una planta
 */
async function loadHeatMap(plant) {
    console.log(`ğŸ”¥ Generando mapa de calor para: ${plant}`);
    
    const container = document.getElementById('heatMapContainer');
    const legend = document.getElementById('heatMapLegend');
    const period = document.getElementById('heatMapPeriod').value;
    
    if (!container) return;
    
    container.innerHTML = '<div style="text-align: center; padding: 40px;">ğŸ”„ Generando mapa de calor...</div>';
    
    try {
        // Obtener incidencias
        let incidents = [];
        if (isIndexedDBAvailable() && roundsDB) {
            incidents = await roundsDB.getIncidents();
        } else {
            incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
        }
        
        // Filtrar por planta y perÃ­odo
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - parseInt(period));
        
        const filteredIncidents = incidents.filter(incident => {
            const incidentDate = new Date(incident.timestamp);
            return incident.plant === plant && incidentDate >= cutoffDate;
        });
        
        // Contar incidencias por ubicaciÃ³n
        const locations = plantLocations[plant];
        const heatData = {};
        
        locations.forEach(location => {
            heatData[location.id] = {
                name: location.name,
                count: filteredIncidents.filter(inc => inc.locationId === location.id).length
            };
        });
        
        // Generar HTML del mapa
        const maxCount = Math.max(...Object.values(heatData).map(d => d.count), 1);
        
        const heatMapHTML = `
            <h3>ğŸ”¥ Mapa de Calor - ${plant.toUpperCase()} (Ãšltimos ${period} dÃ­as)</h3>
            <div class="heat-map-grid">
                ${Object.entries(heatData).map(([locationId, data]) => {
                    const intensity = data.count / maxCount;
                    let level = 0;
                    if (intensity > 0.75) level = 3;
                    else if (intensity > 0.5) level = 2;
                    else if (intensity > 0.25) level = 1;
                    
                    return `
                        <div class="heat-location heat-level-${level}" onclick="showLocationDetails('${locationId}', ${data.count})">
                            <div style="font-size: 1.1rem; margin-bottom: 5px;">${data.name}</div>
                            <div style="font-size: 1.5rem; font-weight: bold;">${data.count}</div>
                            <div style="font-size: 0.8rem; opacity: 0.9;">incidencias</div>
                        </div>
                    `;
                }).join('')}
            </div>
        `;
        
        container.innerHTML = heatMapHTML;
        
        // Mostrar leyenda
        if (legend) {
            legend.classList.remove('hidden');
        }
        
        console.log(`âœ… Mapa de calor generado para ${plant}`);
        
    } catch (error) {
        console.error('âŒ Error generando mapa de calor:', error);
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #e74c3c;">
                âŒ Error generando mapa de calor
            </div>
        `;
    }
}

/**
 * Inicializar pestaÃ±a de Incidencias Urgentes
 */
function initIncidenciasUrgentesTab() {
    console.log('ğŸš¨ Inicializando pestaÃ±a Incidencias Urgentes...');
    loadUrgentIncidents();
}

/**
 * Cargar incidencias urgentes
 */
async function loadUrgentIncidents() {
    try {
        let incidents = [];
        if (isIndexedDBAvailable() && roundsDB) {
            incidents = await roundsDB.getIncidents();
        } else {
            incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
        }
        
        // Filtrar solo urgentes no resueltas
        const urgentIncidents = incidents.filter(incident => 
            incident.priority === 'urgent' && !incident.resolved
        );
        
        // Actualizar contador
        const urgentCount = document.getElementById('urgentCount');
        if (urgentCount) {
            urgentCount.textContent = urgentIncidents.length;
        }
        
        // Mostrar lista
        displayUrgentIncidents(urgentIncidents);
        
    } catch (error) {
        console.error('âŒ Error cargando incidencias urgentes:', error);
    }
}

/**
 * Mostrar incidencias urgentes
 */
function displayUrgentIncidents(incidents) {
    const container = document.getElementById('urgentIncidentsList');
    if (!container) return;
    
    if (incidents.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #666;">
                âœ… No hay incidencias urgentes en este momento
            </div>
        `;
        return;
    }
    
    const incidentsHTML = incidents.map(incident => {
        const location = plantLocations[incident.plant]?.find(loc => loc.id === incident.locationId);
        const locationName = location ? location.name : incident.locationId;
        const plantIcon = incident.plant === 'matriz' ? 'ğŸ¢' : 'ğŸ­';
        const timeAgo = getTimeAgo(new Date(incident.timestamp));
        
        return `
            <div class="urgent-incident">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                    <div>
                        <div class="incident-priority priority-urgent">ğŸš¨ URGENTE</div>
                        <h4 style="margin: 10px 0 5px 0; color: #d32f2f;">
                            ${plantIcon} ${incident.plant.toUpperCase()} - ${locationName}
                        </h4>
                        <div style="color: #666; font-size: 0.9rem;">
                            ğŸ“… ${new Date(incident.timestamp).toLocaleString('es-ES')} (${timeAgo})
                        </div>
                    </div>
                    <button onclick="resolveIncident('${incident.id}')" class="btn btn-success" style="padding: 5px 10px; font-size: 0.8rem;">
                        âœ… Resolver
                    </button>
                </div>
                
                <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <strong>ğŸ“ DescripciÃ³n:</strong><br>
                    ${incident.text}
                </div>
                
                ${incident.hasPhoto ? `
                    <div style="text-align: center;">
                        <button onclick="viewIncidentPhoto('${incident.id}')" class="btn btn-primary" style="padding: 8px 15px;">
                            ğŸ“¸ Ver Evidencia FotogrÃ¡fica
                        </button>
                    </div>
                ` : ''}
            </div>
        `;
    }).join('');
    
    container.innerHTML = incidentsHTML;
}

/**
 * Inicializar pestaÃ±a de Analytics
 */
function initAnalyticsTab() {
    console.log('ğŸ“Š Inicializando pestaÃ±a Analytics...');
    // Por ahora mantener funcionalidad bÃ¡sica
    createSimpleAnalytics();
}

/**
 * Obtener tiempo transcurrido en formato legible
 */
function getTimeAgo(date) {
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);
    
    if (diffMins < 60) return `hace ${diffMins} min`;
    if (diffHours < 24) return `hace ${diffHours}h`;
    return `hace ${diffDays} dÃ­as`;
}

// Inicializar dashboard al cargar
document.addEventListener('DOMContentLoaded', function() {
    // Configurar fecha por defecto al cargar
    const dateFilter = document.getElementById('dateFilter');
    if (dateFilter) {
        const today = new Date().toISOString().split('T')[0];
        dateFilter.value = today;
    }
});


// ===============================================
// ğŸ“Š FUNCIONES ADICIONALES DEL DASHBOARD
// ===============================================

/**
 * Ver detalles completos de un recorrido especÃ­fico
 */
async function viewRoundDetails(roundId) {
    try {
        console.log('ğŸ“‹ Viendo detalles del recorrido:', roundId);
        
        // Buscar recorrido
        let round;
        if (isIndexedDBAvailable() && roundsDB) {
            const rounds = await roundsDB.getRounds();
            round = rounds.find(r => r.id === roundId);
        } else {
            const allRounds = JSON.parse(localStorage.getItem('rounds') || '[]');
            round = allRounds.find(r => r.id === roundId);
        }
        
        if (!round) {
            showAlert('âŒ Error', 'Recorrido no encontrado');
            return;
        }
        
        // Crear contenido detallado
        const startTime = new Date(round.startTime);
        const endTime = round.endTime ? new Date(round.endTime) : null;
        const duration = endTime ? Math.round((endTime - startTime) / 60000) : 0;
        const locationsCount = round.locations ? Object.keys(round.locations).length : 0;
        const totalLocations = plantLocations[round.plant] ? plantLocations[round.plant].length : 10;
        const coveragePercent = Math.round((locationsCount / totalLocations) * 100);
        const incidentsCount = round.incidents ? round.incidents.length : 0;
        
        let detailsHTML = `
            <div style="max-height: 70vh; overflow-y: auto;">
                <h3>ğŸ“‹ Detalles del Recorrido</h3>
                
                <!-- InformaciÃ³n General -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 15px 0;">
                    <h4>â„¹ï¸ InformaciÃ³n General</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                        <div><strong>ğŸ­ Planta:</strong> ${round.plant.toUpperCase()}</div>
                        <div><strong>â° Turno:</strong> ${round.turn === 'diurno' ? 'ğŸŒ… Diurno' : 'ğŸŒ™ Nocturno'}</div>
                        <div><strong>ğŸ“… Inicio:</strong> ${startTime.toLocaleString('es-ES')}</div>
                        ${endTime ? `<div><strong>ğŸ Fin:</strong> ${endTime.toLocaleString('es-ES')}</div>` : '<div><strong>ğŸ Estado:</strong> En progreso</div>'}
                        <div><strong>â±ï¸ DuraciÃ³n:</strong> ${duration > 0 ? `${duration} minutos` : 'N/A'}</div>
                        <div><strong>ğŸ“Š Cobertura:</strong> ${coveragePercent}% (${locationsCount}/${totalLocations})</div>
                    </div>
                </div>
        `;
        
        // Ubicaciones visitadas
        if (round.locations && Object.keys(round.locations).length > 0) {
            detailsHTML += `
                <div style="background: white; padding: 20px; border-radius: 10px; margin: 15px 0; border-left: 4px solid #28a745;">
                    <h4>ğŸ“ Ubicaciones Visitadas</h4>
                    <div style="max-height: 200px; overflow-y: auto;">
            `;
            
            for (const locationId in round.locations) {
                const location = round.locations[locationId];
                const locationInfo = plantLocations[round.plant]?.find(loc => loc.id === locationId);
                const locationName = locationInfo ? locationInfo.name : locationId;
                const visitTime = new Date(location.timestamp);
                const obsCount = location.observations ? location.observations.length : 0;
                const photoCount = location.observations ? location.observations.filter(obs => obs.hasPhoto).length : 0;
                
                detailsHTML += `
                    <div style="background: #f8f9fa; padding: 10px; margin: 8px 0; border-radius: 5px; border-left: 3px solid #007bff;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${locationName}</strong><br>
                                <small style="color: #666;">ğŸ• ${visitTime.toLocaleTimeString('es-ES')}</small>
                            </div>
                            <div style="text-align: right; font-size: 0.9rem;">
                                ğŸ“ ${obsCount} observaciones<br>
                                ğŸ“¸ ${photoCount} fotos
                            </div>
                        </div>
                    </div>
                `;
            }
            detailsHTML += '</div></div>';
        }
        
        // Incidencias reportadas
        if (round.incidents && round.incidents.length > 0) {
            detailsHTML += `
                <div style="background: white; padding: 20px; border-radius: 10px; margin: 15px 0; border-left: 4px solid #dc3545;">
                    <h4>ğŸš¨ Incidencias Reportadas</h4>
                    <div style="max-height: 200px; overflow-y: auto;">
            `;
            
            for (const incident of round.incidents) {
                const locationInfo = plantLocations[round.plant]?.find(loc => loc.id === incident.locationId);
                const locationName = locationInfo ? locationInfo.name : incident.locationId;
                const incidentTime = new Date(incident.timestamp);
                const priorityColor = incident.priority === 'urgent' ? '#dc3545' : incident.priority === 'high' ? '#ffc107' : '#007bff';
                const priorityText = incident.priority === 'urgent' ? 'ğŸ”´ URGENTE' : incident.priority === 'high' ? 'ğŸŸ¡ ALTA' : 'ğŸ”µ NORMAL';
                
                detailsHTML += `
                    <div style="background: #fff5f5; padding: 15px; margin: 8px 0; border-radius: 5px; border-left: 3px solid ${priorityColor};">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                            <div>
                                <div style="background: ${priorityColor}; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.8rem; display: inline-block;">
                                    ${priorityText}
                                </div>
                                <div style="margin-top: 5px;"><strong>${incident.incidentType?.toUpperCase() || 'GENERAL'}</strong> - ${locationName}</div>
                                <small style="color: #666;">ğŸ• ${incidentTime.toLocaleString('es-ES')}</small>
                            </div>
                            ${incident.hasPhoto ? '<div style="color: #007bff;">ğŸ“¸ Con evidencia</div>' : ''}
                        </div>
                        <p style="margin: 10px 0 0 0; color: #555;">${incident.text}</p>
                    </div>
                `;
            }
            detailsHTML += '</div></div>';
        }
        
        // EstadÃ­sticas del recorrido
        detailsHTML += `
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; margin: 15px 0;">
                <h4 style="margin: 0 0 15px 0;">ğŸ“Š EstadÃ­sticas del Recorrido</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px;">
                    <div style="text-align: center;">
                        <div style="font-size: 1.5rem; font-weight: bold;">${locationsCount}</div>
                        <div style="font-size: 0.9rem; opacity: 0.9;">Ubicaciones</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.5rem; font-weight: bold;">${incidentsCount}</div>
                        <div style="font-size: 0.9rem; opacity: 0.9;">Incidencias</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.5rem; font-weight: bold;">${coveragePercent}%</div>
                        <div style="font-size: 0.9rem; opacity: 0.9;">Cobertura</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.5rem; font-weight: bold;">${duration}min</div>
                        <div style="font-size: 0.9rem; opacity: 0.9;">DuraciÃ³n</div>
                    </div>
                </div>
            </div>
            </div>
        `;
        
        // Mostrar en modal personalizado
        showCustomModal('ğŸ“‹ Detalles del Recorrido', detailsHTML);
        
    } catch (error) {
        console.error('âŒ Error viendo detalles del recorrido:', error);
        showAlert('âŒ Error', 'Error al cargar los detalles del recorrido');
    }
}

/**
 * Ver incidencias de un recorrido especÃ­fico
 */
async function viewRoundIncidents(roundId) {
    try {
        console.log('ğŸš¨ Viendo incidencias del recorrido:', roundId);
        
        // Buscar recorrido
        let round;
        if (isIndexedDBAvailable() && roundsDB) {
            const rounds = await roundsDB.getRounds();
            round = rounds.find(r => r.id === roundId);
        } else {
            const allRounds = JSON.parse(localStorage.getItem('rounds') || '[]');
            round = allRounds.find(r => r.id === roundId);
        }
        
        if (!round || !round.incidents || round.incidents.length === 0) {
            showAlert('â„¹ï¸ Sin incidencias', 'Este recorrido no tiene incidencias reportadas');
            return;
        }
        
        let incidentsHTML = `
            <div style="max-height: 70vh; overflow-y: auto;">
                <h3>ğŸš¨ Incidencias del Recorrido</h3>
                <p style="color: #666; margin-bottom: 20px;">
                    ğŸ“… ${new Date(round.startTime).toLocaleDateString('es-ES')} - 
                    ğŸ­ ${round.plant.toUpperCase()} - 
                    ${round.turn === 'diurno' ? 'ğŸŒ… Diurno' : 'ğŸŒ™ Nocturno'}
                </p>
        `;
        
        round.incidents.forEach((incident, index) => {
            const locationInfo = plantLocations[round.plant]?.find(loc => loc.id === incident.locationId);
            const locationName = locationInfo ? locationInfo.name : incident.locationId;
            const incidentTime = new Date(incident.timestamp);
            const priorityColor = incident.priority === 'urgent' ? '#dc3545' : incident.priority === 'high' ? '#ffc107' : '#007bff';
            const priorityText = incident.priority === 'urgent' ? 'ğŸ”´ URGENTE' : incident.priority === 'high' ? 'ğŸŸ¡ ALTA' : 'ğŸ”µ NORMAL';
            
            incidentsHTML += `
                <div style="background: white; border: 2px solid ${priorityColor}; padding: 20px; margin: 15px 0; border-radius: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                        <div>
                            <div style="background: ${priorityColor}; color: white; padding: 4px 12px; border-radius: 15px; font-size: 0.9rem; display: inline-block; margin-bottom: 10px;">
                                ${priorityText}
                            </div>
                            <h4 style="margin: 0; color: #333;">
                                ${incident.incidentType?.toUpperCase() || 'INCIDENCIA GENERAL'}
                            </h4>
                            <p style="margin: 5px 0; color: #666;">
                                ğŸ“ ${locationName}<br>
                                ğŸ• ${incidentTime.toLocaleString('es-ES')}
                            </p>
                        </div>
                        ${incident.hasPhoto ? `
                            <button onclick="viewIncidentPhoto('${incident.id}')" class="btn btn-primary" style="padding: 8px 15px; font-size: 0.9rem;">
                                ğŸ“¸ Ver Evidencia
                            </button>
                        ` : ''}
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        <strong>ğŸ“ DescripciÃ³n:</strong><br>
                        <p style="margin: 10px 0 0 0;">${incident.text}</p>
                    </div>
                </div>
            `;
        });
        
        incidentsHTML += '</div>';
        
        // Mostrar en modal personalizado
        showCustomModal('ğŸš¨ Incidencias del Recorrido', incidentsHTML);
        
    } catch (error) {
        console.error('âŒ Error viendo incidencias del recorrido:', error);
        showAlert('âŒ Error', 'Error al cargar las incidencias del recorrido');
    }
}

/**
 * Mostrar detalles de una ubicaciÃ³n en mapa de calor
 */
function showLocationDetails(locationId, incidentCount) {
    const location = plantLocations[currentPlant]?.find(loc => loc.id === locationId) || 
                     plantLocations.matriz?.find(loc => loc.id === locationId) ||
                     plantLocations.ekzotikart?.find(loc => loc.id === locationId);
    
    if (!location) {
        showAlert('âŒ Error', 'InformaciÃ³n de ubicaciÃ³n no encontrada');
        return;
    }
    
    const severity = incidentCount === 0 ? 'Sin problemas' : 
                     incidentCount <= 2 ? 'Nivel bajo' :
                     incidentCount <= 5 ? 'Nivel moderado' : 'Nivel alto';
                     
    const severityColor = incidentCount === 0 ? '#4CAF50' : 
                          incidentCount <= 2 ? '#FFC107' :
                          incidentCount <= 5 ? '#FF9800' : '#F44336';
    
    const detailsHTML = `
        <div style="text-align: center;">
            <h3>ğŸ“ ${location.name}</h3>
            <p style="color: #666; margin-bottom: 20px;">${location.description}</p>
            
            <div style="background: ${severityColor}; color: white; padding: 20px; border-radius: 10px; margin: 20px 0;">
                <div style="font-size: 2.5rem; font-weight: bold; margin-bottom: 10px;">${incidentCount}</div>
                <div style="font-size: 1.2rem;">Incidencias registradas</div>
                <div style="font-size: 1rem; opacity: 0.9; margin-top: 5px;">${severity}</div>
            </div>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: left;">
                <h4>ğŸ’¡ Recomendaciones:</h4>
                ${incidentCount === 0 ? 
                    '<p>âœ… Esta ubicaciÃ³n no presenta problemas. Mantener el nivel actual de supervisiÃ³n.</p>' :
                incidentCount <= 2 ? 
                    '<p>âš ï¸ Realizar inspecciones adicionales para identificar posibles causas.</p>' :
                incidentCount <= 5 ? 
                    '<p>ğŸ” Priorizar esta Ã¡rea en prÃ³ximos recorridos. Considerar implementar medidas preventivas.</p>' :
                    '<p>ğŸš¨ ÃREA CRÃTICA - Requiere intervenciÃ³n inmediata y revisiÃ³n de protocolos de seguridad.</p>'
                }
            </div>
        </div>
    `;
    
    showCustomModal('ğŸ”¥ Detalles del Mapa de Calor', detailsHTML);
}

/**
 * Resolver una incidencia urgente
 */
async function resolveIncident(incidentId) {
    try {
        console.log('âœ… Resolviendo incidencia:', incidentId);
        
        // Buscar y actualizar incidencia
        if (isIndexedDBAvailable() && roundsDB) {
            // TODO: Implementar updateIncident en roundsDB
            console.log('ğŸ“ Marcando como resuelta en IndexedDB...');
        }
        
        // Actualizar en localStorage
        const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
        const incidentIndex = incidents.findIndex(inc => inc.id === incidentId);
        
        if (incidentIndex !== -1) {
            incidents[incidentIndex].resolved = true;
            incidents[incidentIndex].resolvedAt = new Date().toISOString();
            localStorage.setItem('incidents', JSON.stringify(incidents));
        }
        
        // Recargar lista de urgentes
        loadUrgentIncidents();
        
        showAlert('âœ… Incidencia resuelta', 'La incidencia ha sido marcada como resuelta');
        
    } catch (error) {
        console.error('âŒ Error resolviendo incidencia:', error);
        showAlert('âŒ Error', 'Error al resolver la incidencia');
    }
}

/**
 * Marcar todas las incidencias urgentes como resueltas
 */
async function markAllAsResolved() {
    if (!confirm('Â¿EstÃ¡s seguro de marcar TODAS las incidencias urgentes como resueltas?')) {
        return;
    }
    
    try {
        console.log('âœ… Resolviendo todas las incidencias urgentes...');
        
        const incidents = JSON.parse(localStorage.getItem('incidents') || '[]');
        let resolvedCount = 0;
        
        incidents.forEach(incident => {
            if (incident.priority === 'urgent' && !incident.resolved) {
                incident.resolved = true;
                incident.resolvedAt = new Date().toISOString();
                resolvedCount++;
            }
        });
        
        localStorage.setItem('incidents', JSON.stringify(incidents));
        
        // Recargar lista
        loadUrgentIncidents();
        
        showAlert('âœ… OperaciÃ³n completada', `${resolvedCount} incidencias urgentes han sido resueltas`);
        
    } catch (error) {
        console.error('âŒ Error resolviendo todas las incidencias:', error);
        showAlert('âŒ Error', 'Error al resolver las incidencias');
    }
}

/**
 * Filtrar incidencias urgentes
 */
function filterUrgentIncidents() {
    // Por ahora usar la funciÃ³n loadUrgentIncidents
    // TODO: Implementar filtros especÃ­ficos
    loadUrgentIncidents();
}

/**
 * Modal personalizado mejorado
 */
function showCustomModal(title, content) {
    // Eliminar modal existente
    const existingModal = document.getElementById('customModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    const modalHTML = `
        <div id="customModal" class="modal" style="display: block; z-index: 10000;">
            <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header" style="position: sticky; top: 0; background: white; z-index: 1; border-bottom: 2px solid #eee; padding: 20px 20px 15px 20px;">
                    <h3 style="margin: 0;">${title}</h3>
                    <button class="close-modal" onclick="closeCustomModal()" style="background: none; border: none; font-size: 2rem; cursor: pointer; color: #999; position: absolute; top: 15px; right: 20px;">&times;</button>
                </div>
                <div style="padding: 20px;">
                    ${content}
                </div>
                <div style="text-align: center; padding: 20px; border-top: 1px solid #eee; background: #f8f9fa;">
                    <button onclick="closeCustomModal()" class="btn btn-secondary">âŒ Cerrar</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

/**
 * Cerrar modal personalizado
 */
function closeCustomModal() {
    const modal = document.getElementById('customModal');
    if (modal) {
        modal.remove();
    }
}


    </script>
    
    <!-- CORREGIDO: jsQR cargado con mÃºltiples fallbacks -->
    <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js" 
            onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js';"
            onload="console.log('ğŸ“¦ jsQR pre-cargado desde:', this.src);">
    </script>

<!-- Panel de Debug Visual para MÃ³vil -->
        <div id="debugPanel" class="debug-panel hidden">
            <div class="debug-header">
                <h4>ğŸ”§ Debug Panel</h4>
                <div class="debug-controls">
                    <button onclick="clearDebugLog()" class="debug-btn">ğŸ—‘ï¸</button>
                    <button onclick="toggleDebugPanel()" class="debug-btn">âŒ</button>
                </div>
            </div>
            
            <!-- Estado del Sistema -->
            <div class="debug-section">
                <h5>ğŸ“Š Estado del Sistema</h5>
                <div class="debug-status-grid">
                    <div class="status-item">
                        <span class="status-label">IndexedDB:</span>
                        <span id="debugIndexedDB" class="status-value">â“</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">GitHub:</span>
                        <span id="debugGitHub" class="status-value">â“</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Fotos Backup:</span>
                        <span id="debugPhotosBackup" class="status-value">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Cola Upload:</span>
                        <span id="debugUploadQueue" class="status-value">0</span>
                    </div>
                </div>
            </div>
            
            <!-- EstadÃ­sticas en Tiempo Real -->
            <div class="debug-section">
                <h5>ğŸ“ˆ EstadÃ­sticas</h5>
                <div class="debug-stats">
                    <div>ğŸ“¸ Total Subidas: <span id="debugTotalUploads">0</span></div>
                    <div>ğŸ’¾ Almacenamiento: <span id="debugStorageUsed">0 MB</span></div>
                    <div>âš ï¸ Errores: <span id="debugErrors">0</span></div>
                    <div>ğŸ•’ Ãšltima Sync: <span id="debugLastSync">Nunca</span></div>
                </div>
            </div>
            
            <!-- Log de Actividad -->
            <div class="debug-section">
                <h5>ğŸ“ Log de Actividad</h5>
                <div id="debugLog" class="debug-log">
                    <div class="log-entry info">ğŸš€ Panel de debug inicializado</div>
                </div>
            </div>
            
            <!-- Controles de Prueba -->
            <div class="debug-section">
                <h5>ğŸ§ª Controles de Prueba</h5>
                <div class="debug-test-buttons">
                    <button onclick="testGitHubConnection()" class="debug-test-btn">ğŸ”— Test GitHub</button>
                    <button onclick="processUploadQueueManual()" class="debug-test-btn">ğŸ”„ Procesar Cola</button>
                    <button onclick="syncAllDataForSupervisor()" class="debug-test-btn" style="background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);">ğŸ‘” Sync Supervisor</button>
                    <button onclick="showDebugInfo()" class="debug-test-btn">â„¹ï¸ Info Sistema</button>
                    <button onclick="exportDebugData()" class="debug-test-btn">ğŸ“¤ Exportar Log</button>
                    <button onclick="cleanPhotoCache()" class="debug-test-btn" style="background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 100%);">ğŸ§¹ Limpiar Cache</button>
                    <button onclick="reconfigureGitHubToken()" class="debug-test-btn" style="background: linear-gradient(135deg, #ff9500 0%, #ff6b35 100%);">ğŸ” Reconfigurar Token</button>
                    <button onclick="clearGitHubToken()" class="debug-test-btn" style="background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);">ğŸ—‘ï¸ Limpiar Token</button>
                </div>
            </div>
        </div>

        <!-- BotÃ³n Flotante para Activar Debug -->
        <button id="debugToggleBtn" class="debug-toggle-btn" onclick="toggleDebugPanel()">
            ğŸ”§
        </button>

</body>
</html>